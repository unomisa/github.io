<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>java | J‘G Blog</title><meta name="description" content="到底什么是classpath？             classpath是JVM用到的一个环境变量，它用来指示JVM如何搜索class。              因为Java是编译型语言，源码文件是.java，而编译后的.class文件才是真正可以被JVM执行的字节码。因此，JVM需要知道，如果要加载一个abc.xyz.Hello的类，应该去哪搜索对应的Hello.class文件。所以，cla"><meta name="author" content="JG"><meta name="copyright" content="JG"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://unomisa.github.io/2020/08/26/java/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="java"><meta property="og:url" content="https://unomisa.github.io/2020/08/26/java/"><meta property="og:site_name" content="J‘G Blog"><meta property="og:description" content="到底什么是classpath？             classpath是JVM用到的一个环境变量，它用来指示JVM如何搜索class。              因为Java是编译型语言，源码文件是.java，而编译后的.class文件才是真正可以被JVM执行的字节码。因此，JVM需要知道，如果要加载一个abc.xyz.Hello的类，应该去哪搜索对应的Hello.class文件。所以，cla"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/unomisa/photo-cloud/blogImg/U%7BK(I%5DFXA1FFAG)G%5BGEV$02.png"><meta property="article:published_time" content="2020-08-26T02:48:18.925Z"><meta property="article:modified_time" content="2020-08-27T04:35:15.431Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="prev" title="Java基础知识" href="https://unomisa.github.io/2020/08/27/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://pic1.zhimg.com/v2-6a23112368d020c4b353e8ae991716e0_b.webp" onerror="onerror=null;src='https://pic1.zhimg.com/v2-6a23112368d020c4b353e8ae991716e0_b.webp'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#到底什么是classpath？"><span class="toc-number">1.</span> <span class="toc-text">到底什么是classpath？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#面向对象编程-OOP"><span class="toc-number">2.</span> <span class="toc-text">面向对象编程(OOP)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#所有类的父类-Object类"><span class="toc-number">3.</span> <span class="toc-text">所有类的父类:Object类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#因为所有的class最终都继承自Object，而Object定义了几个重要的方法："><span class="toc-number">3.1.</span> <span class="toc-text">因为所有的class最终都继承自Object，而Object定义了几个重要的方法：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#在必要的情况下，我们可以覆写Object的这几个方法。"><span class="toc-number">3.1.1.</span> <span class="toc-text">在必要的情况下，我们可以覆写Object的这几个方法。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#动态加载"><span class="toc-number">4.</span> <span class="toc-text">动态加载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。"><span class="toc-number">4.1.</span> <span class="toc-text">JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#输入"><span class="toc-number">4.2.</span> <span class="toc-text">输入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#import-java-util-Scanner"><span class="toc-number">4.2.1.</span> <span class="toc-text">import java.util.Scanner;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组"><span class="toc-number">4.3.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-数组名-length-可以直接得到数组长度"><span class="toc-number">4.3.1.</span> <span class="toc-text">1.数组名.length 可以直接得到数组长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#与C语言不同的是，Java允许使用int型变量的值指定数组元素的个数。"><span class="toc-number">4.3.2.</span> <span class="toc-text">与C语言不同的是，Java允许使用int型变量的值指定数组元素的个数。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for-与数组类型相同的变量名-数组名"><span class="toc-number">4.3.3.</span> <span class="toc-text">for (与数组类型相同的变量名 : 数组名) {</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Arrays-toString-数组名-将数组内容返回字符串表示"><span class="toc-number">4.3.4.</span> <span class="toc-text">Arrays.toString( 数组名 )将数组内容返回字符串表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Arrays-sort-数组名-直接对数组进行排序"><span class="toc-number">4.3.5.</span> <span class="toc-text">Arrays.sort( 数组名 )直接对数组进行排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二维数组"><span class="toc-number">4.3.6.</span> <span class="toc-text">二维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更高维度的数组"><span class="toc-number">4.3.7.</span> <span class="toc-text">更高维度的数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clone-返回复制的数组"><span class="toc-number">4.3.8.</span> <span class="toc-text">clone(  ) 返回复制的数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList"><span class="toc-number">4.3.9.</span> <span class="toc-text">ArrayList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#带泛型的数组"><span class="toc-number">4.3.10.</span> <span class="toc-text">带泛型的数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串"><span class="toc-number">4.4.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-实际上字符串在String内部是通过一个char-数组表示的，因此，按下面的写法也是可以的："><span class="toc-number">4.4.1.</span> <span class="toc-text">1.实际上字符串在String内部是通过一个char[]数组表示的，因此，按下面的写法也是可以的：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Java字符串的一个重要特点就是字符串不可变。这种不可变性是通过内部的private-final-char-字段，以及没有任何修改char-的方法实现的。"><span class="toc-number">4.4.2.</span> <span class="toc-text">2.Java字符串的一个重要特点就是字符串不可变。这种不可变性是通过内部的private final char[]字段，以及没有任何修改char[]的方法实现的。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#始终牢记：Java的String和char在内存中总是以Unicode编码表示。"><span class="toc-number">4.4.3.</span> <span class="toc-text">始终牢记：Java的String和char在内存中总是以Unicode编码表示。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Java编译器对String做了特殊处理，使得我们可以直接用-拼接字符串。"><span class="toc-number">4.4.4.</span> <span class="toc-text">3.Java编译器对String做了特殊处理，使得我们可以直接用+拼接字符串。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断字符串"><span class="toc-number">4.4.5.</span> <span class="toc-text">判断字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#修改字符串"><span class="toc-number">4.4.6.</span> <span class="toc-text">修改字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查找字符串"><span class="toc-number">4.4.7.</span> <span class="toc-text">查找字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分割字符串"><span class="toc-number">4.4.8.</span> <span class="toc-text">分割字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拼接字符串"><span class="toc-number">4.4.9.</span> <span class="toc-text">拼接字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#格式化字符串"><span class="toc-number">4.4.10.</span> <span class="toc-text">格式化字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#转换为字符串"><span class="toc-number">4.4.11.</span> <span class="toc-text">转换为字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串转换为其他类型"><span class="toc-number">4.4.12.</span> <span class="toc-text">字符串转换为其他类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String和char-的相互转换"><span class="toc-number">4.4.13.</span> <span class="toc-text">String和char[]的相互转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Integer-getInteger-String-获取int类型的系统属性值"><span class="toc-number">4.4.14.</span> <span class="toc-text">Integer.getInteger(String) 获取int类型的系统属性值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串-getBytes-编码-可以手动把字符串转换成其他编码，返回byte"><span class="toc-number">4.4.15.</span> <span class="toc-text">字符串.getBytes( 编码 )可以手动把字符串转换成其他编码，返回byte[ ]</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类"><span class="toc-number">4.5.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建新对象时，优先选用静态工厂方法而不是new操作符。"><span class="toc-number">4.5.1.</span> <span class="toc-text">创建新对象时，优先选用静态工厂方法而不是new操作符。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-将字段声明为private的好处可以防止外部代码将字段设置为不合理的值-因为只有在本类方法中才能调用它，而在本类方法中可以对参数进行检查。"><span class="toc-number">4.5.2.</span> <span class="toc-text">1. 将字段声明为private的好处可以防止外部代码将字段设置为不合理的值,因为只有在本类方法中才能调用它，而在本类方法中可以对参数进行检查。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-可变参数用：类型…-变量名-定义，可变参数可以当作数组类型使用"><span class="toc-number">4.5.3.</span> <span class="toc-text">2. 可变参数用：类型… 变量名 定义，可变参数可以当作数组类型使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-没有在构造方法中初始化字段时，引用类型的字段默认是null，数值类型的字段用默认值，int类型默认值是0，布尔类型默认值是false"><span class="toc-number">4.5.4.</span> <span class="toc-text">3.没有在构造方法中初始化字段时，引用类型的字段默认是null，数值类型的字段用默认值，int类型默认值是0，布尔类型默认值是false</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-在类中定义字段时可以直接为字段初始化"><span class="toc-number">4.5.5.</span> <span class="toc-text">4.在类中定义字段时可以直接为字段初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-一个构造方法可以调用其他构造方法，这样做的目的是便于代码复用。调用其他构造方法的语法是this-…-："><span class="toc-number">4.5.6.</span> <span class="toc-text">5.一个构造方法可以调用其他构造方法，这样做的目的是便于代码复用。调用其他构造方法的语法是this(…)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-方法名相同，但各自的参数不同，称为方法重载（Overload）"><span class="toc-number">4.5.7.</span> <span class="toc-text">6.方法名相同，但各自的参数不同，称为方法重载（Overload）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承"><span class="toc-number">4.5.8.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象名-instanceof-类名-实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。"><span class="toc-number">4.5.9.</span> <span class="toc-text">对象名  instanceof  类名  实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-组合"><span class="toc-number">4.5.10.</span> <span class="toc-text">7.组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-加上-Override可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名-参数-，编译器会报错。"><span class="toc-number">4.5.11.</span> <span class="toc-text">8.加上@Override可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名(参数)，编译器会报错。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-final关键字"><span class="toc-number">4.5.12.</span> <span class="toc-text">9.final关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-abstract关键字"><span class="toc-number">4.5.13.</span> <span class="toc-text">10.abstract关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-接口-interface"><span class="toc-number">4.5.14.</span> <span class="toc-text">11.接口(interface)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#合理设计interface和abstract-class的继承关系，可以充分复用代码。"><span class="toc-number">4.5.15.</span> <span class="toc-text">合理设计interface和abstract class的继承关系，可以充分复用代码。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-static关键字"><span class="toc-number">4.5.16.</span> <span class="toc-text">12.static关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-包"><span class="toc-number">4.5.17.</span> <span class="toc-text">13.包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-访问权限"><span class="toc-number">4.5.18.</span> <span class="toc-text">14.访问权限</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#枚举类"><span class="toc-number">4.6.</span> <span class="toc-text">枚举类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#和int定义的常量相比，使用enum定义枚举有如下好处："><span class="toc-number">4.6.1.</span> <span class="toc-text">和int定义的常量相比，使用enum定义枚举有如下好处：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#enum的比较"><span class="toc-number">4.6.2.</span> <span class="toc-text">enum的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#enum定义的类型就是class，只不过它有以下几个特点："><span class="toc-number">4.6.3.</span> <span class="toc-text">enum定义的类型就是class，只不过它有以下几个特点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#因为enum是一个class，每个枚举的值都是class实例，因此，这些实例有一些方法："><span class="toc-number">4.6.4.</span> <span class="toc-text">因为enum是一个class，每个枚举的值都是class实例，因此，这些实例有一些方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#但是，如果不小心修改了枚举的顺序，编译器是无法检查出这种逻辑错误的。要编写健壮的代码，就不要依靠ordinal-的返回值。因为enum本身是class，所以我们可以定义private的构造方法，并且，给每个枚举常量添加字段"><span class="toc-number">4.6.5.</span> <span class="toc-text">但是，如果不小心修改了枚举的顺序，编译器是无法检查出这种逻辑错误的。要编写健壮的代码，就不要依靠ordinal()的返回值。因为enum本身是class，所以我们可以定义private的构造方法，并且，给每个枚举常量添加字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结："><span class="toc-number">4.6.6.</span> <span class="toc-text">小结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringBuilder"><span class="toc-number">4.7.</span> <span class="toc-text">StringBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-和String对象不同，它是一个可变对象，可以预分配缓冲区，这样，往StringBuilder中新增字符时，不会创建新的临时对象："><span class="toc-number">4.7.1.</span> <span class="toc-text">1.和String对象不同，它是一个可变对象，可以预分配缓冲区，这样，往StringBuilder中新增字符时，不会创建新的临时对象：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-StringBuilder类的方法都会返回this，方便进行链式操作"><span class="toc-number">4.7.2.</span> <span class="toc-text">2.StringBuilder类的方法都会返回this，方便进行链式操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-要高效拼接字符串，应该使用StringBuilder"><span class="toc-number">4.7.3.</span> <span class="toc-text">3.要高效拼接字符串，应该使用StringBuilder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用StringBuilder还可以进行链式操作"><span class="toc-number">4.7.4.</span> <span class="toc-text">使用StringBuilder还可以进行链式操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringJoiner"><span class="toc-number">4.8.</span> <span class="toc-text">StringJoiner</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#用来用分隔符拼接数组"><span class="toc-number">4.8.1.</span> <span class="toc-text">用来用分隔符拼接数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringJoiner内部实际上就是使用了StringBuilder，所以拼接效率和StringBuilder几乎是一模一样的。"><span class="toc-number">4.8.2.</span> <span class="toc-text">StringJoiner内部实际上就是使用了StringBuilder，所以拼接效率和StringBuilder几乎是一模一样的。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String-names-“Bob”-“Alice”-“Grace”"><span class="toc-number">4.8.3.</span> <span class="toc-text">String[] names &#x3D; {“Bob”, “Alice”, “Grace”};</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何把一个基本类型视为对象（引用类型）？答：包装类型"><span class="toc-number">4.9.</span> <span class="toc-text">如何把一个基本类型视为对象（引用类型）？答：包装类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#"><span class="toc-number">4.9.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Integer"><span class="toc-number">4.9.2.</span> <span class="toc-text">Integer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java的包装类型还定义了一些有用的静态变量"><span class="toc-number">4.9.3.</span> <span class="toc-text">Java的包装类型还定义了一些有用的静态变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#处理无符号整型"><span class="toc-number">4.9.4.</span> <span class="toc-text">处理无符号整型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#最后，所有的整数和浮点数的包装类型都继承自Number，因此，可以非常方便地直接通过包装类型获取各种基本类型："><span class="toc-number">4.9.5.</span> <span class="toc-text">最后，所有的整数和浮点数的包装类型都继承自Number，因此，可以非常方便地直接通过包装类型获取各种基本类型：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaBean"><span class="toc-number">4.10.</span> <span class="toc-text">JavaBean</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#枚举JavaBean属性"><span class="toc-number">4.10.1.</span> <span class="toc-text">枚举JavaBean属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#public-String-getName-return-this-name"><span class="toc-number">4.10.2.</span> <span class="toc-text">public String getName() { return this.name; }</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BigInteger（java-math-BigInteger）"><span class="toc-number">4.11.</span> <span class="toc-text">BigInteger（java.math.BigInteger）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#用来表示任意大小的整数。BigInteger内部用一个int-数组来模拟一个非常大的整数："><span class="toc-number">4.11.1.</span> <span class="toc-text">用来表示任意大小的整数。BigInteger内部用一个int[]数组来模拟一个非常大的整数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对BigInteger做运算的时候，只能使用实例方法，例如，加法运算："><span class="toc-number">4.11.2.</span> <span class="toc-text">对BigInteger做运算的时候，只能使用实例方法，例如，加法运算：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BigInteger用于表示任意大小的整数；"><span class="toc-number">4.11.3.</span> <span class="toc-text">BigInteger用于表示任意大小的整数；</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BigDecimal（java-math-BigDecimal-）"><span class="toc-number">4.12.</span> <span class="toc-text">BigDecimal（java.math.BigDecimal;）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#可以表示一个任意大小且精度完全准确的浮点数。"><span class="toc-number">4.12.1.</span> <span class="toc-text">可以表示一个任意大小且精度完全准确的浮点数。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BigDecimal用scale-表示小数位数"><span class="toc-number">4.12.2.</span> <span class="toc-text">BigDecimal用scale(  )表示小数位数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stripTrailingZeros-方法，可以将一个BigDecimal格式化为一个相等的，但去掉了末尾0的BigDecimal"><span class="toc-number">4.12.3.</span> <span class="toc-text">stripTrailingZeros(  )方法，可以将一个BigDecimal格式化为一个相等的，但去掉了末尾0的BigDecimal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setScale-可以可以对一个BigDecimal设置它的scale，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断"><span class="toc-number">4.12.4.</span> <span class="toc-text">setScale(  )可以可以对一个BigDecimal设置它的scale，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对BigDecimal做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断："><span class="toc-number">4.12.5.</span> <span class="toc-text">对BigDecimal做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#divideAndRemainder-方法，返回的数组包含两个BigDecimal，分别是商和余数，其中商总是整数，余数不会大于除数。"><span class="toc-number">4.12.6.</span> <span class="toc-text">divideAndRemainder(  )方法，返回的数组包含两个BigDecimal，分别是商和余数，其中商总是整数，余数不会大于除数。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#比较BigDecimal"><span class="toc-number">4.12.7.</span> <span class="toc-text">比较BigDecimal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如果查看BigDecimal的源码，可以发现，实际上一个BigDecimal是通过一个BigInteger和一个scale来表示的，即BigInteger表示一个完整的整数，而scale表示小数位数"><span class="toc-number">4.12.8.</span> <span class="toc-text">如果查看BigDecimal的源码，可以发现，实际上一个BigDecimal是通过一个BigInteger和一个scale来表示的，即BigInteger表示一个完整的整数，而scale表示小数位数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用工具类"><span class="toc-number">4.13.</span> <span class="toc-text">常用工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Math"><span class="toc-number">4.13.1.</span> <span class="toc-text">Math</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#随机数"><span class="toc-number">4.14.</span> <span class="toc-text">随机数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Random（伪随机）"><span class="toc-number">4.14.1.</span> <span class="toc-text">Random（伪随机）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SecureRandom（安全随机数）"><span class="toc-number">4.14.2.</span> <span class="toc-text">SecureRandom（安全随机数）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java的异常"><span class="toc-number">4.15.</span> <span class="toc-text">Java的异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java内置了一套异常处理机制，总是使用异常来表示错误。"><span class="toc-number">4.15.1.</span> <span class="toc-text">Java内置了一套异常处理机制，总是使用异常来表示错误。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#因为Java的异常是class，它的继承关系如下："><span class="toc-number">4.15.2.</span> <span class="toc-text">因为Java的异常是class，它的继承关系如下：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java规定："><span class="toc-number">4.15.3.</span> <span class="toc-text">Java规定：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在方法定义的时候，使用throws-Xxx表示该方法可能抛出的异常类型。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错。"><span class="toc-number">4.15.4.</span> <span class="toc-text">在方法定义的时候，使用throws Xxx表示该方法可能抛出的异常类型。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java的try-…-catch机制还提供了finally语句，finally语句块保证有无错误都会执行。"><span class="toc-number">4.15.5.</span> <span class="toc-text">Java的try … catch机制还提供了finally语句，finally语句块保证有无错误都会执行。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一个catch语句也可以匹配多个非继承关系的异常。"><span class="toc-number">4.15.6.</span> <span class="toc-text">一个catch语句也可以匹配多个非继承关系的异常。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过printStackTrace-可以打印出方法的调用栈"><span class="toc-number">4.15.7.</span> <span class="toc-text">通过printStackTrace()可以打印出方法的调用栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在catch中抛出异常，不会影响finally的执行。JVM会先执行finally，然后抛出异常。"><span class="toc-number">4.15.8.</span> <span class="toc-text">在catch中抛出异常，不会影响finally的执行。JVM会先执行finally，然后抛出异常。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义异常注意事项"><span class="toc-number">4.15.9.</span> <span class="toc-text">自定义异常注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用JDK-Logging"><span class="toc-number">4.15.10.</span> <span class="toc-text">使用JDK Logging</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用Commons-Logging"><span class="toc-number">4.15.11.</span> <span class="toc-text">使用Commons Logging</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#反射"><span class="toc-number">4.16.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是反射"><span class="toc-number">4.16.1.</span> <span class="toc-text">什么是反射?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有什么用"><span class="toc-number">4.16.2.</span> <span class="toc-text">有什么用?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过Class实例获取class信息的方法称为反射（Reflection）。"><span class="toc-number">4.16.3.</span> <span class="toc-text">通过Class实例获取class信息的方法称为反射（Reflection）。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承关系"><span class="toc-number">4.16.4.</span> <span class="toc-text">继承关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态代理"><span class="toc-number">4.16.5.</span> <span class="toc-text">动态代理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#注解"><span class="toc-number">4.17.</span> <span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”："><span class="toc-number">4.17.1.</span> <span class="toc-text">注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java的注解可以分为三类："><span class="toc-number">4.17.2.</span> <span class="toc-text">Java的注解可以分为三类：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定义注解："><span class="toc-number">4.17.3.</span> <span class="toc-text">定义注解：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注解定义后也是一种class，所有的注解都继承自java-lang-annotation-Annotation，读取注解，需要使用反射API。"><span class="toc-number">4.17.4.</span> <span class="toc-text">注解定义后也是一种class，所有的注解都继承自java.lang.annotation.Annotation，读取注解，需要使用反射API。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#元注解"><span class="toc-number">4.17.5.</span> <span class="toc-text">元注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用注解"><span class="toc-number">4.17.6.</span> <span class="toc-text">使用注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#泛型"><span class="toc-number">4.18.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型是一种“代码模板”，可以用一套代码套用各种类型。"><span class="toc-number">4.18.1.</span> <span class="toc-text">泛型是一种“代码模板”，可以用一套代码套用各种类型。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型接口"><span class="toc-number">4.18.2.</span> <span class="toc-text">泛型接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编写泛型"><span class="toc-number">4.18.3.</span> <span class="toc-text">编写泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用泛型声明注意："><span class="toc-number">4.18.4.</span> <span class="toc-text">使用泛型声明注意：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态方法"><span class="toc-number">4.18.5.</span> <span class="toc-text">静态方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java语言的泛型实现方式是擦拭法（Type-Erasure）。"><span class="toc-number">4.18.6.</span> <span class="toc-text">Java语言的泛型实现方式是擦拭法（Type Erasure）。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不恰当的覆写方法"><span class="toc-number">4.18.7.</span> <span class="toc-text">不恰当的覆写方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#泛型继承"><span class="toc-number">4.18.8.</span> <span class="toc-text">泛型继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pair不是Pair的子类，因此，add-Pair-不接受参数类型Pair。"><span class="toc-number">4.18.9.</span> <span class="toc-text">Pair不是Pair的子类，因此，add(Pair)不接受参数类型Pair。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#extends通配符"><span class="toc-number">4.18.10.</span> <span class="toc-text">extends通配符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#super通配符"><span class="toc-number">4.18.11.</span> <span class="toc-text">super通配符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用extends限定泛型类型"><span class="toc-number">4.18.12.</span> <span class="toc-text">使用extends限定泛型类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无限定通配符"><span class="toc-number">4.18.13.</span> <span class="toc-text">无限定通配符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集合"><span class="toc-number">4.19.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合。"><span class="toc-number">4.19.1.</span> <span class="toc-text">在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java集合的设计有几个特点："><span class="toc-number">4.19.2.</span> <span class="toc-text">Java集合的设计有几个特点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterator-迭代器"><span class="toc-number">4.19.3.</span> <span class="toc-text">Iterator(迭代器)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collections"><span class="toc-number">4.19.4.</span> <span class="toc-text">Collections</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List"><span class="toc-number">4.19.5.</span> <span class="toc-text">List</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-number">4.19.6.</span> <span class="toc-text">Map</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#setting-properties"><span class="toc-number">5.</span> <span class="toc-text">setting.properties</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Queue-队列"><span class="toc-number">5.0.1.</span> <span class="toc-text">Queue(队列)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PriorityQueue-优先队列、有序队列"><span class="toc-number">5.0.2.</span> <span class="toc-text">PriorityQueue(优先队列、有序队列)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Deque-双端队列"><span class="toc-number">5.0.3.</span> <span class="toc-text">Deque(双端队列)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO"><span class="toc-number">5.1.</span> <span class="toc-text">IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IO是指Input-Output，即输入和输出。以内存为中心："><span class="toc-number">5.1.1.</span> <span class="toc-text">IO是指Input&#x2F;Output，即输入和输出。以内存为中心：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InputStream-OutputStream"><span class="toc-number">5.1.2.</span> <span class="toc-text">InputStream &#x2F; OutputStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如果数据源不是文本，就只能使用InputStream，如果数据源是文本，使用Reader更方便一些。Writer和OutputStream是类似的。"><span class="toc-number">5.1.3.</span> <span class="toc-text">如果数据源不是文本，就只能使用InputStream，如果数据源是文本，使用Reader更方便一些。Writer和OutputStream是类似的。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Reader-Writer"><span class="toc-number">5.1.4.</span> <span class="toc-text">Reader &#x2F; Writer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步和异步"><span class="toc-number">5.1.5.</span> <span class="toc-text">同步和异步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#File对象"><span class="toc-number">5.1.6.</span> <span class="toc-text">File对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#读取classpath资源"><span class="toc-number">5.1.7.</span> <span class="toc-text">读取classpath资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#序列化与反序列化"><span class="toc-number">5.1.8.</span> <span class="toc-text">序列化与反序列化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#日期与时间"><span class="toc-number">5.2.</span> <span class="toc-text">日期与时间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本概念"><span class="toc-number">5.2.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Date"><span class="toc-number">5.2.2.</span> <span class="toc-text">Date</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Calendar"><span class="toc-number">5.2.3.</span> <span class="toc-text">Calendar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TimeZone"><span class="toc-number">5.2.4.</span> <span class="toc-text">TimeZone</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#新-java-time包"><span class="toc-number">5.2.5.</span> <span class="toc-text">(新)java.time包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单元测试"><span class="toc-number">5.3.</span> <span class="toc-text">单元测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#单元测试就是针对最小的功能单元编写测试代码，即对单个方法的测试"><span class="toc-number">5.3.1.</span> <span class="toc-text">单元测试就是针对最小的功能单元编写测试代码，即对单个方法的测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#注解-1"><span class="toc-number">5.3.2.</span> <span class="toc-text">注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用Fixture"><span class="toc-number">5.3.3.</span> <span class="toc-text">使用Fixture</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#正则表达式"><span class="toc-number">5.4.</span> <span class="toc-text">正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#正则表达式可以用字符串来描述规则，并用来匹配字符串。"><span class="toc-number">5.4.1.</span> <span class="toc-text">正则表达式可以用字符串来描述规则，并用来匹配字符串。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java字符串用-表示"><span class="toc-number">5.4.2.</span> <span class="toc-text">java字符串用\表示\</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#正则表达式的匹配规则是从左到右按规则匹配。"><span class="toc-number">5.4.3.</span> <span class="toc-text">正则表达式的匹配规则是从左到右按规则匹配。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如果想匹配非ASCII字符，例如中文，那就用-u-的十六进制表示，例如：a-u548cc匹配字符串”a和c”，中文字符和的Unicode编码是548c。"><span class="toc-number">5.4.4.</span> <span class="toc-text">如果想匹配非ASCII字符，例如中文，那就用\u####的十六进制表示，例如：a\u548cc匹配字符串”a和c”，中文字符和的Unicode编码是548c。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用步骤"><span class="toc-number">5.4.5.</span> <span class="toc-text">使用步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匹配规则"><span class="toc-number">5.4.6.</span> <span class="toc-text">匹配规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#复杂匹配规则"><span class="toc-number">5.4.7.</span> <span class="toc-text">复杂匹配规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pattern"><span class="toc-number">5.4.8.</span> <span class="toc-text">Pattern</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#加密与安全"><span class="toc-number">5.5.</span> <span class="toc-text">加密与安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#应对潜在的安全威胁，需要做到三防"><span class="toc-number">5.5.1.</span> <span class="toc-text">应对潜在的安全威胁，需要做到三防</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#编码算法"><span class="toc-number">5.5.2.</span> <span class="toc-text">编码算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#哈希算法-Hash"><span class="toc-number">5.5.3.</span> <span class="toc-text">哈希算法(Hash)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#加密算法"><span class="toc-number">5.5.4.</span> <span class="toc-text">加密算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多线程"><span class="toc-number">5.6.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程基础"><span class="toc-number">5.6.1.</span> <span class="toc-text">多线程基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程重要方法"><span class="toc-number">5.6.2.</span> <span class="toc-text">线程重要方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建新线程"><span class="toc-number">5.6.3.</span> <span class="toc-text">创建新线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在线程中执行语句和在main-中执行的区别"><span class="toc-number">5.6.4.</span> <span class="toc-text">在线程中执行语句和在main()中执行的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的状态"><span class="toc-number">5.6.5.</span> <span class="toc-text">线程的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中断线程"><span class="toc-number">5.6.6.</span> <span class="toc-text">中断线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#守护线程"><span class="toc-number">5.6.7.</span> <span class="toc-text">守护线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程同步"><span class="toc-number">5.6.8.</span> <span class="toc-text">线程同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#死锁"><span class="toc-number">5.6.9.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程协调"><span class="toc-number">5.6.10.</span> <span class="toc-text">多线程协调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">5.6.11.</span> <span class="toc-text">ThreadLocal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java-util-concurrent包"><span class="toc-number">5.6.12.</span> <span class="toc-text">java.util.concurrent包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Maven基础"><span class="toc-number">5.7.</span> <span class="toc-text">Maven基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Maven是什么？"><span class="toc-number">5.7.1.</span> <span class="toc-text">Maven是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Maven项目结构"><span class="toc-number">5.7.2.</span> <span class="toc-text">Maven项目结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Maven构建流程"><span class="toc-number">5.7.3.</span> <span class="toc-text">Maven构建流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模块管理"><span class="toc-number">5.7.4.</span> <span class="toc-text">模块管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mvnw-Maven-Wrapper"><span class="toc-number">5.7.5.</span> <span class="toc-text">mvnw(Maven Wrapper)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#发布Artifact"><span class="toc-number">5.7.6.</span> <span class="toc-text">发布Artifact</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="color"></div><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/unomisa/photo-cloud/blogImg/U%7BK(I%5DFXA1FFAG)G%5BGEV$02.png)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">J‘G Blog</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 目录</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">java</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-08-26 10:48:18"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-08-26</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-08-27 12:35:15"><i class="fas fa-history fa-fw"></i> 更新于 2020-08-27</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="到底什么是classpath？"><a href="#到底什么是classpath？" class="headerlink" title="到底什么是classpath？"></a>到底什么是classpath？</h1><div class="note info">
            <p>classpath是JVM用到的一个环境变量，它用来指示JVM如何搜索class。</p>
          </div>

<ul>
<li>因为Java是编译型语言，源码文件是.java，而编译后的.class文件才是真正可以被JVM执行的字节码。因此，JVM需要知道，如果要加载一个abc.xyz.Hello的类，应该去哪搜索对应的Hello.class文件。所以，classpath就是一组目录的集合，它设置的搜索路径与操作系统相关。例如，在Windows系统上，用;分隔，带空格的目录用””括起来，可能长这样：</li>
</ul>
<p><code>C:\work\project1\bin;C:\shared;&quot;D:\My Documents\project1\bin&quot;</code></p>
<h1 id="面向对象编程-OOP"><a href="#面向对象编程-OOP" class="headerlink" title="面向对象编程(OOP)"></a>面向对象编程(OOP)</h1><blockquote>
<p>六句真言：继承不抽象，拿来不要还。封装加权限，接口要简单。多态不变态，接口不依赖。每日默念，必定成仙。</p>
</blockquote>
<h1 id="所有类的父类-Object类"><a href="#所有类的父类-Object类" class="headerlink" title="所有类的父类:Object类"></a>所有类的父类:Object类</h1><h2 id="因为所有的class最终都继承自Object，而Object定义了几个重要的方法："><a href="#因为所有的class最终都继承自Object，而Object定义了几个重要的方法：" class="headerlink" title="因为所有的class最终都继承自Object，而Object定义了几个重要的方法："></a>因为所有的class最终都继承自Object，而Object定义了几个重要的方法：</h2><div class="note default">
            <p>toString(  )：把instance输出为String；</p>
          </div>

<div class="note default">
            <p>equals(  )：判断两个instance是否逻辑相等；</p>
          </div>

<div class="note default">
            <p>hashCode(  )：计算一个instance的哈希值。</p>
          </div>

<div class="note info">
            <h3 id="在必要的情况下，我们可以覆写Object的这几个方法。"><a href="#在必要的情况下，我们可以覆写Object的这几个方法。" class="headerlink" title="在必要的情况下，我们可以覆写Object的这几个方法。"></a>在必要的情况下，我们可以覆写Object的这几个方法。</h3>
          </div>

<h1 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h1><h2 id="JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。"><a href="#JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。" class="headerlink" title="JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。"></a>JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。</h2><ul>
<li>例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Main.java</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           create(args[<span class="number">0</span>]);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">     Person p = <span class="keyword">new</span> Person(name);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>​<br>    - 当执行Main.java时，由于用到了Main，因此，JVM首先会把Main.class加载到内存。然而，并不会加载Person.class，除非程序执行到create()方法，JVM发现需要加载Person类时，才会首次加载Person.class。如果没有执行create()方法，那么Person.class根本就不会被加载。</p>
<p>这就是JVM动态加载class的特性。</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><h3 id="import-java-util-Scanner"><a href="#import-java-util-Scanner" class="headerlink" title="import java.util.Scanner;"></a>import java.util.Scanner;</h3><p>Scanner cin=new Scanner(System.in);<br> int a[]=new int[10];<br> for(int i=0;i&lt;10;i++){<br>        a[i]=cin.nextInt();<br> }</p>
<ul>
<li>为数组依次输入值</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="1-数组名-length-可以直接得到数组长度"><a href="#1-数组名-length-可以直接得到数组长度" class="headerlink" title="1.数组名.length 可以直接得到数组长度"></a>1.数组名.length 可以直接得到数组长度</h3><h3 id="与C语言不同的是，Java允许使用int型变量的值指定数组元素的个数。"><a href="#与C语言不同的是，Java允许使用int型变量的值指定数组元素的个数。" class="headerlink" title="与C语言不同的是，Java允许使用int型变量的值指定数组元素的个数。"></a>与C语言不同的是，Java允许使用int型变量的值指定数组元素的个数。</h3><ul>
<li>int size=30;<br>double number[ ]=new double[size];</li>
</ul>
<h3 id="for-与数组类型相同的变量名-数组名"><a href="#for-与数组类型相同的变量名-数组名" class="headerlink" title="for (与数组类型相同的变量名 : 数组名) {"></a>for (与数组类型相同的变量名 : 数组名) {</h3><pre><code>    System.out.println(n);
}</code></pre><ul>
<li><p>使用for each 语句遍历数组</p>
<ul>
<li>传统for遍历可以得到索引，该种for遍历是直接拿到数组元素。根据需求使用其中一种遍历方式</li>
</ul>
</li>
</ul>
<h3 id="Arrays-toString-数组名-将数组内容返回字符串表示"><a href="#Arrays-toString-数组名-将数组内容返回字符串表示" class="headerlink" title="Arrays.toString( 数组名 )将数组内容返回字符串表示"></a>Arrays.toString( 数组名 )将数组内容返回字符串表示</h3><h3 id="Arrays-sort-数组名-直接对数组进行排序"><a href="#Arrays-sort-数组名-直接对数组进行排序" class="headerlink" title="Arrays.sort( 数组名 )直接对数组进行排序"></a>Arrays.sort( 数组名 )直接对数组进行排序</h3><ul>
<li>数组排序实际上修改了数组本身</li>
</ul>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><ul>
<li><p>1.二维数组的length取决于它的一位数组个数</p>
</li>
<li><p>2.二维数组的每个数组元素的长度并不要求相同</p>
<ul>
<li>int a[ ][ ]=new int [3][ ];<br>a[0]=new int[6];<br>a[1]=new int [12];<br>a[2]=new int[8]</li>
</ul>
</li>
<li><p>Arrays.deepToString(二维数组名)将二维数组内容返回字符串表示</p>
</li>
</ul>
<h3 id="更高维度的数组"><a href="#更高维度的数组" class="headerlink" title="更高维度的数组"></a>更高维度的数组</h3><ul>
<li>二维数组的元素为一维数组，而三维数组的元素为二维数组，以此类推</li>
</ul>
<h3 id="clone-返回复制的数组"><a href="#clone-返回复制的数组" class="headerlink" title="clone(  ) 返回复制的数组"></a>clone(  ) 返回复制的数组</h3><ul>
<li>不能使用=号来连接两个数组，会造成引用相同，更改其中一个数组两个都会改变</li>
</ul>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><ul>
<li>实际上ArrayList内部就是一个Object[]数组，配合存储一个当前分配的长度，就可以充当“可变数组”：</li>
</ul>
<h3 id="带泛型的数组"><a href="#带泛型的数组" class="headerlink" title="带泛型的数组"></a>带泛型的数组</h3><ul>
<li>可以声明带泛型的数组，但不能用new操作符创建带泛型的数组：</li>
</ul>
<p>Pair<String>[] ps = null; // ok<br>Pair<String>[] ps = new Pair<String>[2]; // compile error!</p>
<pre><code>- 必须通过强制转型实现带泛型的数组：</code></pre><p>@SuppressWarnings(“unchecked”)<br>Pair<String>[] ps = (Pair<String>[]) new Pair[2];</p>
<pre><code>- 尽量不要这样声明：//扔掉arr引用，像前面一样直接声明</code></pre><p>✘Pair[] arr = new Pair[2];//会多出一个可以操作泛型数组的引用arr<br>Pair<String>[] ps = (Pair<String>[]) arr;</p>
<p>ps[0] = new Pair<String>(“a”, “b”);//ps是泛型数组，编译器会检查是否为String<br>arr[1] = new Pair<Integer>(1, 2);//但arr不是，编译器不会检查其类型，可能造成错误</p>
<p>// ClassCastException:<br>Pair<String> p = ps[1];<br>String s = p.getFirst();</p>
<ul>
<li>借助Class<T>来创建泛型数组：</li>
</ul>
<p>T[] createArray(Class<T> cls) {<br>    return (T[]) Array.newInstance(cls, 5);<br>}</p>
<pre><code>- 我们还可以利用可变参数创建泛型数组T[]：</code></pre><p>public class ArrayHelper {<br>    @SafeVarargs<br>    static <T> T[] asArray(T… objs) {<br>        return objs;<br>    }<br>}</p>
<p>String[] ss = ArrayHelper.asArray(“a”, “b”, “c”);<br>Integer[] ns = ArrayHelper.asArray(1, 2, 3);</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="1-实际上字符串在String内部是通过一个char-数组表示的，因此，按下面的写法也是可以的："><a href="#1-实际上字符串在String内部是通过一个char-数组表示的，因此，按下面的写法也是可以的：" class="headerlink" title="1.实际上字符串在String内部是通过一个char[]数组表示的，因此，按下面的写法也是可以的："></a>1.实际上字符串在String内部是通过一个char[]数组表示的，因此，按下面的写法也是可以的：</h3><ul>
<li>String s2 = new String(new char[] {‘H’, ‘e’, ‘l’, ‘l’, ‘o’, ‘!’});</li>
<li>注意：char[]后面没有 ‘=’</li>
</ul>
<h3 id="2-Java字符串的一个重要特点就是字符串不可变。这种不可变性是通过内部的private-final-char-字段，以及没有任何修改char-的方法实现的。"><a href="#2-Java字符串的一个重要特点就是字符串不可变。这种不可变性是通过内部的private-final-char-字段，以及没有任何修改char-的方法实现的。" class="headerlink" title="2.Java字符串的一个重要特点就是字符串不可变。这种不可变性是通过内部的private final char[]字段，以及没有任何修改char[]的方法实现的。"></a>2.Java字符串的一个重要特点就是字符串不可变。这种不可变性是通过内部的private final char[]字段，以及没有任何修改char[]的方法实现的。</h3><h3 id="始终牢记：Java的String和char在内存中总是以Unicode编码表示。"><a href="#始终牢记：Java的String和char在内存中总是以Unicode编码表示。" class="headerlink" title="始终牢记：Java的String和char在内存中总是以Unicode编码表示。"></a>始终牢记：Java的String和char在内存中总是以Unicode编码表示。</h3><h3 id="3-Java编译器对String做了特殊处理，使得我们可以直接用-拼接字符串。"><a href="#3-Java编译器对String做了特殊处理，使得我们可以直接用-拼接字符串。" class="headerlink" title="3.Java编译器对String做了特殊处理，使得我们可以直接用+拼接字符串。"></a>3.Java编译器对String做了特殊处理，使得我们可以直接用+拼接字符串。</h3><ul>
<li>因为Java编译器在编译时就自动把多个连续的+操作编码为StringConcatFactory的操作。在运行期，StringConcatFactory会自动把字符串连接操作优化为数组复制或者StringBuilder操作。</li>
</ul>
<h3 id="判断字符串"><a href="#判断字符串" class="headerlink" title="判断字符串"></a>判断字符串</h3><ul>
<li><p>字符串.equals( 字符串 )来判断两个字符串是否相等</p>
<ul>
<li>本质上是判断两个实例是否相等</li>
<li>要忽略大小写比较，使用equalsIgnoreCase()方法。</li>
</ul>
</li>
<li><p>字符串.contains( 子串 )来判断是否包含字串</p>
<ul>
<li>如：”Hello”.contains(“ll”); // true</li>
</ul>
</li>
<li><p>字符串.startsWith(子串) 判断是否以…开头</p>
<ul>
<li>“Hello”.startsWith(“He”); // true</li>
</ul>
</li>
<li><p>字符串.endsWith(子串) 判断是否以…结尾</p>
<ul>
<li>“Hello”.endsWith(“lo”); // true</li>
</ul>
</li>
<li><p>字符串.isEmpty(  ) 判断字符串是否为空</p>
<ul>
<li>“”.isEmpty(  ); // true，因为字符串长度为0</li>
<li>“  “.isEmpty(  ); // false，因为字符串长度不为0</li>
</ul>
</li>
<li><p>字符串.isBlank(  ) 判断字符串是否为空白字符串</p>
<ul>
<li>“  \n”.isBlank(  ); // true，因为只包含空白字符</li>
<li>“ Hello “.isBlank(  ); // false，因为包含非空白字符</li>
</ul>
</li>
</ul>
<h3 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h3><ul>
<li><p>字符串.replaceAll( 需要替换的字符,替换的结果字符)来将字符串中的特定字符替换成其他字符并返回替换后的字符串</p>
<ul>
<li><p>可以这个方法来将字符串中空格字符去掉：字符串.replaceAll(“ “,’’’’);</p>
</li>
<li><p>字符串.trim(  )去掉首尾空白字符，但是中间的不行</p>
<ul>
<li>空白字符包括空格，\t，\r，\n：</li>
<li>无法删除中文空格’\u3000’(2个字节的空格)</li>
</ul>
</li>
</ul>
</li>
<li><p>要在字符串中替换子串，有两种方法。一种是根据字符或字符串替换：</p>
<ul>
<li>“hello”.replace(‘l’, ‘w’); // “hewwo”，所有字符’l’被替换为’w’</li>
<li>“hello”.replace(“ll”, “<del>“); // “he</del>o”，所有子串”ll”被替换为”~~”</li>
</ul>
</li>
<li><p>另一种是通过正则表达式替换：</p>
<ul>
<li>String s = “A,,B;C ,D”;<br>s.replaceAll(“[,;\s]+”, “,”); // “A,B,C,D”</li>
</ul>
</li>
</ul>
<h3 id="查找字符串"><a href="#查找字符串" class="headerlink" title="查找字符串"></a>查找字符串</h3><ul>
<li><p>字符串.indexOf(子串) 查找字符或者子串第一次出现的地方</p>
<ul>
<li>“Hello”.indexOf(“l”); // 2</li>
</ul>
</li>
<li><p>字符串.lastIndexOf(子串) 查找字符或者子串是后一次出现的地方</p>
<ul>
<li>“Hello”.lastIndexOf(“l”); // 3</li>
</ul>
</li>
<li><p>字符串.substring(截取开始处下标，截取结束点下标)  截取字符串中的子串</p>
<ul>
<li>“Hello”.substring(2); // “llo”</li>
<li>“Hello”.substring(2, 4); “ll”</li>
</ul>
</li>
</ul>
<h3 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h3><ul>
<li><p>字符串.split( 正则表达式 ) ，将分割后的字符串存到一个字符串数组中并返回</p>
<ul>
<li>String s = “A,B,C,D”;<br>String[] ss = s.split(“\,”); // {“A”, “B”, “C”, “D”}</li>
</ul>
</li>
</ul>
<h3 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h3><ul>
<li><p>静态方法(使用类名调用)join(字符串,数组)，它用指定的字符串连接字符串数组</p>
<ul>
<li>String[] arr = {“A”, “B”, “C”};<br>String s = String.join(“<strong>*”, arr); // “A*</strong>B***C”</li>
<li>这个方法在内部使用了StringJoiner来拼接字符串，在不需要指定“开头”和“结尾”的时候，用String.join()更方便：</li>
</ul>
</li>
</ul>
<h3 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h3><ul>
<li><p>静态方法format(  ) 可以传入其他参数，替换占位符，然后生成新的字符串：</p>
<ul>
<li>String s = “Hi %s, your score is %d!”;<br>System.out.println(String.format(s, “Bob”,60));<br>//Hi Bob, your score is 60!</li>
</ul>
</li>
</ul>
<h3 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h3><ul>
<li><p>静态方法valueOf(  ),把任意基本类型或引用类型转换为字符串</p>
<ul>
<li>String.valueOf(123); // “123”</li>
<li>String.valueOf(45.67); // “45.67”</li>
<li>String.valueOf(true); // “true”</li>
<li>String.valueOf(new Object()); // 类似java.lang.Object@636be97c</li>
</ul>
</li>
</ul>
<h3 id="字符串转换为其他类型"><a href="#字符串转换为其他类型" class="headerlink" title="字符串转换为其他类型"></a>字符串转换为其他类型</h3><ul>
<li><p>字符串转int</p>
<ul>
<li><p>Integer.parseInt(  字符串  )</p>
<ul>
<li>int n1 = Integer.parseInt(“123”); // 123</li>
<li>int n2 = Integer.parseInt(“ff”, 16); // 按十六进制转换，255</li>
</ul>
</li>
</ul>
</li>
<li><p>字符串转boolean</p>
<ul>
<li><p>Boolean.parseBoolean</p>
<ul>
<li>boolean b1 = Boolean.parseBoolean(“true”); // true</li>
<li>boolean b2 = Boolean.parseBoolean(“FALfsSE”); // false</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="String和char-的相互转换"><a href="#String和char-的相互转换" class="headerlink" title="String和char[]的相互转换"></a>String和char[]的相互转换</h3><ul>
<li>char[] cs = “Hello”.toCharArray();   // String -&gt; char[]</li>
<li>String s = new String(cs);   // char[] -&gt; String</li>
</ul>
<h3 id="Integer-getInteger-String-获取int类型的系统属性值"><a href="#Integer-getInteger-String-获取int类型的系统属性值" class="headerlink" title="Integer.getInteger(String) 获取int类型的系统属性值"></a>Integer.getInteger(String) 获取int类型的系统属性值</h3><ul>
<li>Integer.getInteger(“java.version”); // 版本号，11</li>
<li>java.version表示系统属性</li>
</ul>
<h3 id="字符串-getBytes-编码-可以手动把字符串转换成其他编码，返回byte"><a href="#字符串-getBytes-编码-可以手动把字符串转换成其他编码，返回byte" class="headerlink" title="字符串.getBytes( 编码 )可以手动把字符串转换成其他编码，返回byte[ ]"></a>字符串.getBytes( 编码 )可以手动把字符串转换成其他编码，返回byte[ ]</h3><ul>
<li>byte[] b2 = “Hello”.getBytes(“UTF-8”); // 按UTF-8编码转换</li>
<li>byte[] b2 = “Hello”.getBytes(“GBK”); // 按GBK编码转换</li>
<li>要把已知编码的byte[]转换为String，可以这样做：</li>
<li>byte[] b = …<br>String s1 = new String(b, “GBK”); // 按GBK转换<br>String s2 = new String(b, StandardCharsets.UTF_8); // 按UTF-8转换</li>
</ul>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="创建新对象时，优先选用静态工厂方法而不是new操作符。"><a href="#创建新对象时，优先选用静态工厂方法而不是new操作符。" class="headerlink" title="创建新对象时，优先选用静态工厂方法而不是new操作符。"></a>创建新对象时，优先选用静态工厂方法而不是new操作符。</h3><h3 id="1-将字段声明为private的好处可以防止外部代码将字段设置为不合理的值-因为只有在本类方法中才能调用它，而在本类方法中可以对参数进行检查。"><a href="#1-将字段声明为private的好处可以防止外部代码将字段设置为不合理的值-因为只有在本类方法中才能调用它，而在本类方法中可以对参数进行检查。" class="headerlink" title="1. 将字段声明为private的好处可以防止外部代码将字段设置为不合理的值,因为只有在本类方法中才能调用它，而在本类方法中可以对参数进行检查。"></a>1. 将字段声明为private的好处可以防止外部代码将字段设置为不合理的值,因为只有在本类方法中才能调用它，而在本类方法中可以对参数进行检查。</h3><ul>
<li><p>所以在类中设置字段时，可以都将其设置为private，也许这是一个好习惯</p>
</li>
<li><p>在创建方法时，尽量完成对传入的参数的合理性判断</p>
<ul>
<li>如对年龄字段限制在0~150等等</li>
</ul>
</li>
</ul>
<h3 id="2-可变参数用：类型…-变量名-定义，可变参数可以当作数组类型使用"><a href="#2-可变参数用：类型…-变量名-定义，可变参数可以当作数组类型使用" class="headerlink" title="2. 可变参数用：类型… 变量名 定义，可变参数可以当作数组类型使用"></a>2. 可变参数用：类型… 变量名 定义，可变参数可以当作数组类型使用</h3><ul>
<li><p>class Group {<br>  private String[] names;<br>  public void setNames(String…names) {</p>
<pre><code>this.names = names;</code></pre><p>  }<br>}</p>
<ul>
<li><p>调用方式:对象名.setNames(“刘力郡”,”陶俊杰”);</p>
</li>
<li><p>若将形式参数改为String names[]</p>
<ul>
<li>调用方式将变更为：                                                            对象名.setNames(new String[] {“刘力郡”,陶俊杰”});</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-没有在构造方法中初始化字段时，引用类型的字段默认是null，数值类型的字段用默认值，int类型默认值是0，布尔类型默认值是false"><a href="#3-没有在构造方法中初始化字段时，引用类型的字段默认是null，数值类型的字段用默认值，int类型默认值是0，布尔类型默认值是false" class="headerlink" title="3.没有在构造方法中初始化字段时，引用类型的字段默认是null，数值类型的字段用默认值，int类型默认值是0，布尔类型默认值是false"></a>3.没有在构造方法中初始化字段时，引用类型的字段默认是null，数值类型的字段用默认值，int类型默认值是0，布尔类型默认值是false</h3><h3 id="4-在类中定义字段时可以直接为字段初始化"><a href="#4-在类中定义字段时可以直接为字段初始化" class="headerlink" title="4.在类中定义字段时可以直接为字段初始化"></a>4.在类中定义字段时可以直接为字段初始化</h3><ul>
<li>如:class Student{<br>int age=10;<br>}</li>
</ul>
<h3 id="5-一个构造方法可以调用其他构造方法，这样做的目的是便于代码复用。调用其他构造方法的语法是this-…-："><a href="#5-一个构造方法可以调用其他构造方法，这样做的目的是便于代码复用。调用其他构造方法的语法是this-…-：" class="headerlink" title="5.一个构造方法可以调用其他构造方法，这样做的目的是便于代码复用。调用其他构造方法的语法是this(…)："></a>5.一个构造方法可以调用其他构造方法，这样做的目的是便于代码复用。调用其他构造方法的语法是this(…)：</h3><h3 id="6-方法名相同，但各自的参数不同，称为方法重载（Overload）"><a href="#6-方法名相同，但各自的参数不同，称为方法重载（Overload）" class="headerlink" title="6.方法名相同，但各自的参数不同，称为方法重载（Overload）"></a>6.方法名相同，但各自的参数不同，称为方法重载（Overload）</h3><ul>
<li><p>注意：方法重载的返回值类型通常都是相同的。</p>
</li>
<li><p>举个例子，String类提供了多个重载方法indexOf()，可以查找子串：</p>
<ul>
<li>int indexOf(int ch)：根据字符的Unicode码查找；</li>
<li>int indexOf(String str)：根据字符串查找；</li>
<li>int indexOf(int ch, int fromIndex)：根据字符查找，但指定起始位置；</li>
<li>int indexOf(String str, int fromIndex)根据字符串查找，但指定起始位置。</li>
</ul>
</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li><p>所谓继承就是在原先有的类的基础上添加想要的功能</p>
</li>
<li><p>在Java中，没有明确写extends的类，编译器会自动加上extends Object</p>
<ul>
<li>所以只有Object特殊，它没有父类。</li>
<li>所以除了Object类，所有的类都会显式或隐式使用super(  )调用父类的构造函数</li>
</ul>
</li>
<li><p>继承的好处：继承可以复用代码，子类可以拿走父类的所有功能和属性，只需要为子类编写新的功能和属性就行了</p>
<ul>
<li>编程的思想也就是继承：不用什么功能都自己来写，可以使用各种库中写好的方法，这样编程效率会快很多</li>
<li>构造方法不会被继承</li>
</ul>
</li>
<li><p>任何class的构造方法，第一行语句必须是调用父类的构造方法。如果父类没有默认的构造方法，子类就必须显式调用super()并给出参数以便让编译器定位到父类的一个合适的构造方法。</p>
</li>
</ul>
<h3 id="对象名-instanceof-类名-实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。"><a href="#对象名-instanceof-类名-实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。" class="headerlink" title="对象名  instanceof  类名  实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。"></a>对象名  instanceof  类名  实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。</h3><ul>
<li>需要判断的原因是父类对象实例是不能下转为子类对象实例的，不能凭空多出子类的功能</li>
<li>如果是则返回true,反之false</li>
<li>通常情况下，我们应该用instanceof判断数据类型，因为面向抽象编程的时候，我们不关心具体的子类型。只有在需要精确判断一个类型是不是某个class的时候，我们才使用==判断class实例。</li>
</ul>
<h3 id="7-组合"><a href="#7-组合" class="headerlink" title="7.组合"></a>7.组合</h3><h3 id="8-加上-Override可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名-参数-，编译器会报错。"><a href="#8-加上-Override可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名-参数-，编译器会报错。" class="headerlink" title="8.加上@Override可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名(参数)，编译器会报错。"></a>8.加上@Override可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名(参数)，编译器会报错。</h3><ul>
<li>挺有用的多用以养成好习惯</li>
</ul>
<h3 id="9-final关键字"><a href="#9-final关键字" class="headerlink" title="9.final关键字"></a>9.final关键字</h3><ul>
<li><p>关于字段：对于一个类的实例字段，同样可以用final修饰。用final修饰的字段在初始化(需要为它直接初始化或在构造方法中初始化)后不能被修改。</p>
<ul>
<li>如果选择在构造方法中初始化的话，每个重载的构造方法都必须含有为final字段初始化的语句</li>
</ul>
</li>
<li><p>关于方法：如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为final。用final修饰的方法不能被Override(重写)</p>
</li>
<li><p>关于类：如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为final。用final修饰的类不能被继承：</p>
</li>
</ul>
<h3 id="10-abstract关键字"><a href="#10-abstract关键字" class="headerlink" title="10.abstract关键字"></a>10.abstract关键字</h3><ul>
<li>把一个方法声明为abstract，表示它是一个抽象方法，本身没有实现任何方法语句。而包含抽象方法的类必须为抽象类。抽象类不能实例化对象；</li>
</ul>
<h3 id="11-接口-interface"><a href="#11-接口-interface" class="headerlink" title="11.接口(interface)"></a>11.接口(interface)</h3><ul>
<li><p>所谓interface，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有(抽象类是可以有字段和非抽象方法的)。因为接口定义的所有方法默认都是public abstract的，所以这两个修饰符不需要写出来（写不写效果都一样）。</p>
</li>
<li><p>当一个具体的class去实现一个interface时，需要使用implements关键字。</p>
</li>
<li><p>在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个interface</p>
</li>
<li><p>接口继承</p>
<ul>
<li>一个interface可以继承自另一个interface。interface继承自interface使用extends，它相当于扩展了接口的方法</li>
</ul>
</li>
<li><p>default方法</p>
<ul>
<li><p>实现类可以不必覆写default方法。</p>
<ul>
<li>default方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是default方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</li>
<li>default方法和抽象类的普通方法是有所不同的。因为interface没有字段，default方法无法访问字段，而抽象类的普通方法可以访问实例字段。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="合理设计interface和abstract-class的继承关系，可以充分复用代码。"><a href="#合理设计interface和abstract-class的继承关系，可以充分复用代码。" class="headerlink" title="合理设计interface和abstract class的继承关系，可以充分复用代码。"></a>合理设计interface和abstract class的继承关系，可以充分复用代码。</h3><h3 id="12-static关键字"><a href="#12-static关键字" class="headerlink" title="12.static关键字"></a>12.static关键字</h3><ul>
<li><p>静态字段</p>
<ul>
<li><p>不推荐用 实例变量.静态字段 去访问静态字段，因为在Java程序中，实例对象并没有静态字段。在代码中，实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为类名.静态字段来访问静态对象。</p>
<ul>
<li>推荐用类名来访问静态字段。可以把静态字段理解为描述class本身的字段（非实例字段）。</li>
</ul>
</li>
</ul>
</li>
<li><p>静态方法</p>
<ul>
<li>静态方法属于class而不属于实例，因此，静态方法内部，无法访问this变量，也无法访问实例字段，它只能访问静态字段。</li>
</ul>
</li>
</ul>
<h3 id="13-包"><a href="#13-包" class="headerlink" title="13.包"></a>13.包</h3><ul>
<li><p>import static的语法，它可以导入可以导入一个类的静态字段和静态方法：</p>
<ul>
<li>导入System类的所有静态字段和静态方法:</li>
<li>import static java.lang.System.*;</li>
</ul>
</li>
<li><p>编写class的时候，编译器会自动帮我们做两个import动作：</p>
<ul>
<li><p>默认自动import当前package的其他class；</p>
</li>
<li><p>默认自动import java.lang.*。</p>
<ul>
<li><p>在写import的时候，可以使用*，表示把这个包下面的所有class都导入进来（但不包括子包的class）</p>
</li>
<li><p>注意：自动导入的是java.lang包，但类似java.lang.reflect这些包仍需要手动导入。</p>
<ul>
<li>子包的类不会导入</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用倒置的域名来确保唯一性。例如：</p>
<ul>
<li>org.apache</li>
<li>org.apache.commons.log</li>
<li>com.liaoxuefeng.sample</li>
</ul>
</li>
</ul>
<h3 id="14-访问权限"><a href="#14-访问权限" class="headerlink" title="14.访问权限"></a>14.访问权限</h3><ul>
<li><p>public</p>
<ul>
<li>定义为public的class、interface可以被其他任何类访问</li>
</ul>
</li>
<li><p>protected</p>
<ul>
<li>protected作用于继承关系。定义为protected的字段和方法可以被子类访问，以及子类的子类</li>
</ul>
</li>
<li><p>private</p>
<ul>
<li>定义为private的field、method无法被其他类访问，private访问权限被限定在class的内部</li>
</ul>
</li>
<li><p>推荐把private方法放到后面，因为public方法定义了类对外提供的功能，阅读代码的时候，应该先关注public方法：</p>
</li>
</ul>
<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><h3 id="和int定义的常量相比，使用enum定义枚举有如下好处："><a href="#和int定义的常量相比，使用enum定义枚举有如下好处：" class="headerlink" title="和int定义的常量相比，使用enum定义枚举有如下好处："></a>和int定义的常量相比，使用enum定义枚举有如下好处：</h3><ul>
<li><p>首先，enum常量本身带有类型信息，即Weekday.SUN类型是Weekday，编译器会自动检查出类型错误。</p>
<ul>
<li><p>其次，不可能引用到非枚举的值，因为无法通过编译。</p>
<ul>
<li><p>最后，不同类型的枚举不能互相比较或者赋值，因为类型不符。例如，不能给一个Weekday枚举类型的变量赋值为Color枚举类型的值：</p>
<ul>
<li>这就使得编译器可以在编译期自动检查出所有可能的潜在错误。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="enum的比较"><a href="#enum的比较" class="headerlink" title="enum的比较"></a>enum的比较</h3><ul>
<li>使用enum定义的枚举类是一种引用类型。前面我们讲到，引用类型比较，要使用equals()方法，如果使用==比较，它比较的是两个引用类型的变量是否是同一个对象。因此，引用类型比较，要始终使用equals()方法，但enum类型可以例外。</li>
</ul>
<p>这是因为enum类型的每个常量在JVM中只有一个唯一实例，所以可以直接用==比较：</p>
<h3 id="enum定义的类型就是class，只不过它有以下几个特点："><a href="#enum定义的类型就是class，只不过它有以下几个特点：" class="headerlink" title="enum定义的类型就是class，只不过它有以下几个特点："></a>enum定义的类型就是class，只不过它有以下几个特点：</h3><ul>
<li>定义的enum类型总是继承自java.lang.Enum，且无法被继承；</li>
<li>只能定义出enum的实例，而无法通过new操作符创建enum的实例；</li>
<li>定义的每个实例都是引用类型的唯一实例；</li>
<li>可以将enum类型用于switch语句。</li>
</ul>
<h3 id="因为enum是一个class，每个枚举的值都是class实例，因此，这些实例有一些方法："><a href="#因为enum是一个class，每个枚举的值都是class实例，因此，这些实例有一些方法：" class="headerlink" title="因为enum是一个class，每个枚举的值都是class实例，因此，这些实例有一些方法："></a>因为enum是一个class，每个枚举的值都是class实例，因此，这些实例有一些方法：</h3><ul>
<li><p>name(  )返回常量名</p>
<ul>
<li>例如：String s = Weekday.SUN.name(); // “SUN”</li>
</ul>
</li>
<li><p>ordinal(  )返回定义的常量的顺序，从0开始计数</p>
<ul>
<li>例如：int n = Weekday.MON.ordinal(); // 1<br>即第二个定义的</li>
<li>改变枚举常量定义的顺序就会导致ordinal(  )返回值发生变化。</li>
</ul>
</li>
</ul>
<h3 id="但是，如果不小心修改了枚举的顺序，编译器是无法检查出这种逻辑错误的。要编写健壮的代码，就不要依靠ordinal-的返回值。因为enum本身是class，所以我们可以定义private的构造方法，并且，给每个枚举常量添加字段"><a href="#但是，如果不小心修改了枚举的顺序，编译器是无法检查出这种逻辑错误的。要编写健壮的代码，就不要依靠ordinal-的返回值。因为enum本身是class，所以我们可以定义private的构造方法，并且，给每个枚举常量添加字段" class="headerlink" title="但是，如果不小心修改了枚举的顺序，编译器是无法检查出这种逻辑错误的。要编写健壮的代码，就不要依靠ordinal()的返回值。因为enum本身是class，所以我们可以定义private的构造方法，并且，给每个枚举常量添加字段"></a>但是，如果不小心修改了枚举的顺序，编译器是无法检查出这种逻辑错误的。要编写健壮的代码，就不要依靠ordinal()的返回值。因为enum本身是class，所以我们可以定义private的构造方法，并且，给每个枚举常量添加字段</h3><ul>
<li>public class Main {<br>  public static void main(String[] args) {<pre><code>Weekday day = Weekday.SUN;
if (day.dayValue == 6 || day.dayValue == 0) {
    System.out.println(&quot;Today is &quot; + day.toString() + &quot;. Work at home!&quot;);
} else {
    System.out.println(&quot;Today is &quot; + day + &quot;. Work at office!&quot;);
}</code></pre>  }<br>}</li>
</ul>
<p>enum Weekday {<br>    MON(1, “星期一”), TUE(2, “星期二”), WED(3, “星期三”), THU(4, “星期四”), FRI(5, “星期五”), SAT(6, “星期六”), SUN(0, “星期日”);</p>
<pre><code>public final int dayValue;
private final String chinese;

private Weekday(int dayValue, String chinese) {
    this.dayValue = dayValue;
    this.chinese = chinese;
}

@Override
public String toString() {
    return this.chinese;
}</code></pre><p>}</p>
<pre><code>- 输出：Today is 星期日. Work at home!
- 这样就无需担心顺序的变化，新增枚举常量时，也需要指定一个int值。
- 这样可以让代码更加健壮，不容易出bug

    - 理解这种思想

- 默认情况下，对枚举常量调用toString()会返回和name()一样的字符串。但是，toString()可以被覆写，而name()则不行。我们可以给Weekday添加toString()方法：

    - 覆写toString()的目的是在输出时更有可读性。

- 可以再设置枚举变量是为其设置一些属性，增加可读性</code></pre><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><ul>
<li>Java使用enum定义枚举类型，它被编译器编译为final class Xxx extends Enum { … }；</li>
</ul>
<p>通过name()获取常量定义的字符串，注意不要使用toString()；</p>
<p>通过ordinal()返回常量定义的顺序（无实质意义）；</p>
<p>可以为enum编写构造方法、字段和方法</p>
<p>enum的构造方法要声明为private，字段强烈建议声明为final；</p>
<p>enum适合用在switch语句中。</p>
<h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><h3 id="1-和String对象不同，它是一个可变对象，可以预分配缓冲区，这样，往StringBuilder中新增字符时，不会创建新的临时对象："><a href="#1-和String对象不同，它是一个可变对象，可以预分配缓冲区，这样，往StringBuilder中新增字符时，不会创建新的临时对象：" class="headerlink" title="1.和String对象不同，它是一个可变对象，可以预分配缓冲区，这样，往StringBuilder中新增字符时，不会创建新的临时对象："></a>1.和String对象不同，它是一个可变对象，可以预分配缓冲区，这样，往StringBuilder中新增字符时，不会创建新的临时对象：</h3><h3 id="2-StringBuilder类的方法都会返回this，方便进行链式操作"><a href="#2-StringBuilder类的方法都会返回this，方便进行链式操作" class="headerlink" title="2.StringBuilder类的方法都会返回this，方便进行链式操作"></a>2.StringBuilder类的方法都会返回this，方便进行链式操作</h3><h3 id="3-要高效拼接字符串，应该使用StringBuilder"><a href="#3-要高效拼接字符串，应该使用StringBuilder" class="headerlink" title="3.要高效拼接字符串，应该使用StringBuilder"></a>3.要高效拼接字符串，应该使用StringBuilder</h3><h3 id="使用StringBuilder还可以进行链式操作"><a href="#使用StringBuilder还可以进行链式操作" class="headerlink" title="使用StringBuilder还可以进行链式操作"></a>使用StringBuilder还可以进行链式操作</h3><ul>
<li><p>StringBuilder sb = new StringBuilder();<br>  sb.append(“Mr “)</p>
<pre><code>.append(&quot;Bob&quot;)
.append(&quot;!&quot;)
.insert(0, &quot;Hello, &quot;);</code></pre><p>  System.out.println(sb.toString());</p>
<ul>
<li>输出：Hello, Mr Bob!</li>
<li>查看StringBuilder的源码，可以发现，进行链式操作的关键是，定义的append()方法会返回this，这样，就可以不断调用自身的其他方法。</li>
</ul>
</li>
</ul>
<h2 id="StringJoiner"><a href="#StringJoiner" class="headerlink" title="StringJoiner"></a>StringJoiner</h2><h3 id="用来用分隔符拼接数组"><a href="#用来用分隔符拼接数组" class="headerlink" title="用来用分隔符拼接数组"></a>用来用分隔符拼接数组</h3><h3 id="StringJoiner内部实际上就是使用了StringBuilder，所以拼接效率和StringBuilder几乎是一模一样的。"><a href="#StringJoiner内部实际上就是使用了StringBuilder，所以拼接效率和StringBuilder几乎是一模一样的。" class="headerlink" title="StringJoiner内部实际上就是使用了StringBuilder，所以拼接效率和StringBuilder几乎是一模一样的。"></a>StringJoiner内部实际上就是使用了StringBuilder，所以拼接效率和StringBuilder几乎是一模一样的。</h3><h3 id="String-names-“Bob”-“Alice”-“Grace”"><a href="#String-names-“Bob”-“Alice”-“Grace”" class="headerlink" title="String[] names = {“Bob”, “Alice”, “Grace”};"></a>String[] names = {“Bob”, “Alice”, “Grace”};</h3><p>StringJoiner sj = new StringJoiner(“,”);<br>for (String name : names) {<br>        sj.add(name);<br>    }<br>System.out.println(sj.toString());</p>
<ul>
<li><p>构造时传入了一个分隔符”，“，然后使用add方法拼接并自动加上所设分隔符</p>
</li>
<li><p>输出：Bob,Alice,Grace</p>
</li>
<li><p>可以增加构造参数为new StringJoiner(“，”,”Hello “,”!”);<br>\这样可以设置前缀和后缀</p>
<ul>
<li>输出：Hello Bob,Alice,Grace!</li>
</ul>
</li>
</ul>
<h2 id="如何把一个基本类型视为对象（引用类型）？答：包装类型"><a href="#如何把一个基本类型视为对象（引用类型）？答：包装类型" class="headerlink" title="如何把一个基本类型视为对象（引用类型）？答：包装类型"></a>如何把一个基本类型视为对象（引用类型）？答：包装类型</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h3><ul>
<li><p>// 通过new操作符创建Integer实例(不推荐使用,会有编译警告):</p>
<pre><code>Integer n1 = new Integer(100);</code></pre><p>// 通过静态方法valueOf(int)创建Integer实例:</p>
<pre><code>Integer n2 = Integer.valueOf(100);</code></pre><p>// 通过静态方法valueOf(String)创建Integer实例:</p>
<pre><code>Integer n3 = Integer.valueOf(&quot;100&quot;);</code></pre><ul>
<li>Java编译器可以帮助我们自动在int和Integer之间转型：</li>
</ul>
</li>
</ul>
<p>Integer n = 100; // 编译器自动使用Integer.valueOf(int)<br>int x = n; // 编译器自动使用Integer.intValue()</p>
<pre><code>    - 这种直接把int变为Integer的赋值写法，称为自动装箱（Auto Boxing），反过来，把Integer变为int的赋值写法，称为自动拆箱（Auto Unboxing）。

        - 注意：自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码。

- 方法2更好，因为方法1总是创建新的Integer实例，方法2把内部优化留给Integer的实现者去做，即使在当前版本没有优化，也有可能在下一个版本进行优化。</code></pre><p>我们把能创建“新”对象的静态方法称为静态工厂方法。Integer.valueOf()就是静态工厂方法，它尽可能地返回缓存的实例以节省内存。</p>
<ul>
<li><p>静态方法parseInt(  )可以把字符串解析成一个整数</p>
<ul>
<li>int x1 = Integer.parseInt(“100”); // 100</li>
</ul>
</li>
</ul>
<p>int x2 = Integer.parseInt(“100”, 16); // 256,因为按16进制解析</p>
<ul>
<li><p>Integer还可以把整数格式化为指定进制的字符串</p>
<ul>
<li>System.out.println(Integer.toString(100)); // “100”,表示为10进制<br>System.out.println(Integer.toString(100, 36)); // “2s”,表示为36进制<br>System.out.println(Integer.toHexString(100)); // “64”,表示为16进制<br>System.out.println(Integer.toOctalString(100)); // “144”,表示为8进制<br>System.out.println(Integer.toBinaryString(100)); // “1100100”,表示为2进制</li>
</ul>
</li>
</ul>
<h3 id="Java的包装类型还定义了一些有用的静态变量"><a href="#Java的包装类型还定义了一些有用的静态变量" class="headerlink" title="Java的包装类型还定义了一些有用的静态变量"></a>Java的包装类型还定义了一些有用的静态变量</h3><ul>
<li>// int可表示的最大/最小值:<br>int max = Integer.MAX_VALUE; // 2147483647<br>int min = Integer.MIN_VALUE; // -2147483648</li>
</ul>
<p>// long类型占用的bit和byte数量:<br>int sizeOfLong = Long.SIZE; // 64 (bits)<br>int bytesOfLong = Long.BYTES; // 8 (bytes)</p>
<pre><code>- 这里的作用就相当于获取int最大最小的表示范围</code></pre><h3 id="处理无符号整型"><a href="#处理无符号整型" class="headerlink" title="处理无符号整型"></a>处理无符号整型</h3><ul>
<li><p>例如，byte是有符号整型，范围是-128<del>+127，但如果把byte看作无符号整型，它的范围就是0</del>255。我们把一个负的byte按无符号整型转换为int：</p>
<ul>
<li><p>byte x = -1;<br>byte y = 127;<br>System.out.println(Byte.toUnsignedInt(x)); // 255<br>System.out.println(Byte.toUnsignedInt(y)); // 127</p>
<ul>
<li>超过了byte可以表示的范围所以变成int类型了</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="最后，所有的整数和浮点数的包装类型都继承自Number，因此，可以非常方便地直接通过包装类型获取各种基本类型："><a href="#最后，所有的整数和浮点数的包装类型都继承自Number，因此，可以非常方便地直接通过包装类型获取各种基本类型：" class="headerlink" title="最后，所有的整数和浮点数的包装类型都继承自Number，因此，可以非常方便地直接通过包装类型获取各种基本类型："></a>最后，所有的整数和浮点数的包装类型都继承自Number，因此，可以非常方便地直接通过包装类型获取各种基本类型：</h3><ul>
<li>// 向上转型为Number:<br>Number num = new Integer(999);</li>
</ul>
<p>// 获取byte, int, long, float, double:<br>byte b = num.byteValue();<br>int n = num.intValue();<br>long ln = num.longValue();<br>float f = num.floatValue();<br>double d = num.doubleValue();</p>
<h2 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h2><h3 id="枚举JavaBean属性"><a href="#枚举JavaBean属性" class="headerlink" title="枚举JavaBean属性"></a>枚举JavaBean属性</h3><h3 id="public-String-getName-return-this-name"><a href="#public-String-getName-return-this-name" class="headerlink" title="public String getName() { return this.name; }"></a>public String getName() { return this.name; }</h3><pre><code>public void setName(String name) { this.name = name; }

public int getAge() { return this.age; }
public void setAge(int age) { this.age = age; }</code></pre><ul>
<li>如果读写方法符合以下这种命名规范,那么这种class被称为JavaBean</li>
</ul>
<h2 id="BigInteger（java-math-BigInteger）"><a href="#BigInteger（java-math-BigInteger）" class="headerlink" title="BigInteger（java.math.BigInteger）"></a>BigInteger（java.math.BigInteger）</h2><h3 id="用来表示任意大小的整数。BigInteger内部用一个int-数组来模拟一个非常大的整数："><a href="#用来表示任意大小的整数。BigInteger内部用一个int-数组来模拟一个非常大的整数：" class="headerlink" title="用来表示任意大小的整数。BigInteger内部用一个int[]数组来模拟一个非常大的整数："></a>用来表示任意大小的整数。BigInteger内部用一个int[]数组来模拟一个非常大的整数：</h3><h3 id="对BigInteger做运算的时候，只能使用实例方法，例如，加法运算："><a href="#对BigInteger做运算的时候，只能使用实例方法，例如，加法运算：" class="headerlink" title="对BigInteger做运算的时候，只能使用实例方法，例如，加法运算："></a>对BigInteger做运算的时候，只能使用实例方法，例如，加法运算：</h3><p>BigInteger i1 = new BigInteger(“1234567890”);<br>BigInteger i2 = new BigInteger(“12345678901234567890”);<br>BigInteger sum = i1.add(i2); // 12345678902469135780</p>
<h3 id="BigInteger用于表示任意大小的整数；"><a href="#BigInteger用于表示任意大小的整数；" class="headerlink" title="BigInteger用于表示任意大小的整数；"></a>BigInteger用于表示任意大小的整数；</h3><p>BigInteger是不变类，并且继承自Number；</p>
<p>将BigInteger转换成基本类型时可使用longValueExact()等方法保证结果准确。</p>
<h2 id="BigDecimal（java-math-BigDecimal-）"><a href="#BigDecimal（java-math-BigDecimal-）" class="headerlink" title="BigDecimal（java.math.BigDecimal;）"></a>BigDecimal（java.math.BigDecimal;）</h2><h3 id="可以表示一个任意大小且精度完全准确的浮点数。"><a href="#可以表示一个任意大小且精度完全准确的浮点数。" class="headerlink" title="可以表示一个任意大小且精度完全准确的浮点数。"></a>可以表示一个任意大小且精度完全准确的浮点数。</h3><h3 id="BigDecimal用scale-表示小数位数"><a href="#BigDecimal用scale-表示小数位数" class="headerlink" title="BigDecimal用scale(  )表示小数位数"></a>BigDecimal用scale(  )表示小数位数</h3><ul>
<li>例如：<br>BigDecimal d1 = new BigDecimal(“123.45”);<br>BigDecimal d2 = new BigDecimal(“123.4500”);<br>BigDecimal d3 = new BigDecimal(“1234500”);<br>System.out.println(d1.scale()); // 2,两位小数<br>System.out.println(d2.scale()); // 4<br>System.out.println(d3.scale()); // 0</li>
</ul>
<h3 id="stripTrailingZeros-方法，可以将一个BigDecimal格式化为一个相等的，但去掉了末尾0的BigDecimal"><a href="#stripTrailingZeros-方法，可以将一个BigDecimal格式化为一个相等的，但去掉了末尾0的BigDecimal" class="headerlink" title="stripTrailingZeros(  )方法，可以将一个BigDecimal格式化为一个相等的，但去掉了末尾0的BigDecimal"></a>stripTrailingZeros(  )方法，可以将一个BigDecimal格式化为一个相等的，但去掉了末尾0的BigDecimal</h3><ul>
<li>例如：<br>BigDecimal d1 = new BigDecimal(“123.4500”);<br>BigDecimal d2 = d1.stripTrailingZeros();<br>System.out.println(d1.scale()); // 4<br>System.out.println(d2.scale()); // 2,因为去掉了00</li>
</ul>
<p>BigDecimal d3 = new BigDecimal(“1234500”);<br>BigDecimal d4 = d3.stripTrailingZeros();<br>System.out.println(d3.scale()); // 0<br>System.out.println(d4.scale()); // -2，表示是一个整数并且末尾有两个0</p>
<h3 id="setScale-可以可以对一个BigDecimal设置它的scale，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断"><a href="#setScale-可以可以对一个BigDecimal设置它的scale，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断" class="headerlink" title="setScale(  )可以可以对一个BigDecimal设置它的scale，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断"></a>setScale(  )可以可以对一个BigDecimal设置它的scale，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断</h3><ul>
<li>import java.math.BigDecimal;<br>import java.math.RoundingMode;    //用到了这个类的参数</li>
</ul>
<p>public class Main {<br>    public static void main(String[] args) {<br>        BigDecimal d1 = new BigDecimal(“123.456789”);<br>        BigDecimal d2 = d1.setScale(4, RoundingMode.HALF_UP); // 四舍五入，123.4568<br>        BigDecimal d3 = d1.setScale(4, RoundingMode.DOWN); // 直接截断，123.4567<br>        System.out.println(d2);<br>        System.out.println(d3);<br>    }<br>}</p>
<h3 id="对BigDecimal做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断："><a href="#对BigDecimal做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断：" class="headerlink" title="对BigDecimal做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断："></a>对BigDecimal做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断：</h3><ul>
<li>BigDecimal d1 = new BigDecimal(“123.456”);<br>BigDecimal d2 = new BigDecimal(“23.456789”);<br>BigDecimal d3 = d1.divide(d2, 10, RoundingMode.HALF_UP); // 保留10位小数并四舍五入，5.2631244626<br>BigDecimal d4 = d1.divide(d2); // 报错：ArithmeticException，因为除不尽</li>
</ul>
<h3 id="divideAndRemainder-方法，返回的数组包含两个BigDecimal，分别是商和余数，其中商总是整数，余数不会大于除数。"><a href="#divideAndRemainder-方法，返回的数组包含两个BigDecimal，分别是商和余数，其中商总是整数，余数不会大于除数。" class="headerlink" title="divideAndRemainder(  )方法，返回的数组包含两个BigDecimal，分别是商和余数，其中商总是整数，余数不会大于除数。"></a>divideAndRemainder(  )方法，返回的数组包含两个BigDecimal，分别是商和余数，其中商总是整数，余数不会大于除数。</h3><ul>
<li><p>BigDecimal n = new BigDecimal(“12.345”);<br>BigDecimal m = new BigDecimal(“0.12”);<br>BigDecimal[] dr = n.divideAndRemainder(m);<br>System.out.println(dr[0]); // 102<br>System.out.println(dr[1]); // 0.105</p>
</li>
<li><p>我们可以利用这个方法判断两个BigDecimal是否是整数倍数：</p>
<ul>
<li>BigDecimal n = new BigDecimal(“12.75”);<br>BigDecimal m = new BigDecimal(“0.15”);<br>BigDecimal[] dr = n.divideAndRemainder(m);<br>if (dr[1].signum() == 0) {<br>// n是m的整数倍<br>}</li>
</ul>
</li>
</ul>
<h3 id="比较BigDecimal"><a href="#比较BigDecimal" class="headerlink" title="比较BigDecimal"></a>比较BigDecimal</h3><ul>
<li><p>在比较两个BigDecimal的值是否相等时，要特别注意，使用equals()方法不但要求两个BigDecimal的值相等，还要求它们的scale()相等</p>
<ul>
<li>BigDecimal d1 = new BigDecimal(“123.456”);<br>BigDecimal d2 = new BigDecimal(“123.45600”);<br>System.out.println(d1.equals(d2)); // false,因为scale不同<br>System.out.println(d1.equals(d2.stripTrailingZeros())); // true,因为d2去除尾部0后scale变为2<br>System.out.println(d1.compareTo(d2)); // 0</li>
</ul>
</li>
<li><p>compareTo(  )方法来比较，它根据两个值的大小分别返回负数、正数和0，分别表示小于、大于和等于。</p>
<ul>
<li>总是使用compareTo(  )比较两个BigDecimal的值，不要使用equals(  )！</li>
</ul>
</li>
</ul>
<h3 id="如果查看BigDecimal的源码，可以发现，实际上一个BigDecimal是通过一个BigInteger和一个scale来表示的，即BigInteger表示一个完整的整数，而scale表示小数位数"><a href="#如果查看BigDecimal的源码，可以发现，实际上一个BigDecimal是通过一个BigInteger和一个scale来表示的，即BigInteger表示一个完整的整数，而scale表示小数位数" class="headerlink" title="如果查看BigDecimal的源码，可以发现，实际上一个BigDecimal是通过一个BigInteger和一个scale来表示的，即BigInteger表示一个完整的整数，而scale表示小数位数"></a>如果查看BigDecimal的源码，可以发现，实际上一个BigDecimal是通过一个BigInteger和一个scale来表示的，即BigInteger表示一个完整的整数，而scale表示小数位数</h3><h2 id="常用工具类"><a href="#常用工具类" class="headerlink" title="常用工具类"></a>常用工具类</h2><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><ul>
<li><p>求绝对值：</p>
<ul>
<li>Math.abs(-100); // 100<br>Math.abs(-7.8); // 7.8</li>
</ul>
</li>
<li><p>取最大或最小值：</p>
<ul>
<li>Math.max(100, 99); // 100<br>Math.min(1.2, 2.3); // 1.2</li>
</ul>
</li>
<li><p>计算xy次方：</p>
<ul>
<li>Math.pow(2, 10); // 2的10次方=1024</li>
</ul>
</li>
<li><p>计算√x：</p>
<ul>
<li>Math.sqrt(2); // 1.414…</li>
</ul>
</li>
<li><p>计算ex次方：</p>
<ul>
<li>Math.exp(2); // 7.389…</li>
</ul>
</li>
<li><p>计算以e为底的对数：</p>
<ul>
<li>Math.log(4); // 1.386…</li>
</ul>
</li>
<li><p>计算以10为底的对数：</p>
<ul>
<li>Math.log10(100); // 2</li>
</ul>
</li>
<li><p>三角函数：</p>
<ul>
<li>Math.sin(3.14); // 0.00159…<br>Math.cos(3.14); // -0.9999…<br>Math.tan(3.14); // -0.0015…<br>Math.asin(1.0); // 1.57079…<br>Math.acos(1.0); // 0.0</li>
</ul>
</li>
<li><p>Math还提供了几个数学常量：</p>
<ul>
<li>double pi = Math.PI; // 3.14159…<br>double e = Math.E; // 2.7182818…<br>Math.sin(Math.PI / 6); // sin(π/6) = 0.5</li>
</ul>
</li>
<li><p>生成一个随机数x，x的范围是0 &lt;= x &lt; 1</p>
<ul>
<li><p>Math.random(); // 0.53907… 每次都不一样</p>
</li>
<li><p>如果我们要生成一个区间在[MIN, MAX)的随机数，可以借助Math.random()实现</p>
<ul>
<li>double x = Math.random(); // x的范围是[0,1)<br>double min = 10;<br>double max = 50;<br>double y = x * (max - min) + min; // y的范围是[10,50)<br>long n = (long) y; // n的范围是[10,50)的整数<br>System.out.println(y);  //28.46395517103491<br>System.out.println(n);  //28</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><h3 id="Random（伪随机）"><a href="#Random（伪随机）" class="headerlink" title="Random（伪随机）"></a>Random（伪随机）</h3><ul>
<li>Random用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。</li>
</ul>
<p>要生成一个随机数，可以使用nextInt()、nextLong()、nextFloat()、nextDouble()</p>
<pre><code>- Random r = new Random();</code></pre><p>r.nextInt(); // 2071575453,每次都不一样<br>r.nextInt(10); // 5,生成一个[0,10)之间的int<br>r.nextLong(); // 8811649292570369305,每次都不一样<br>r.nextFloat(); // 0.54335…生成一个[0,1)之间的float<br>r.nextDouble(); // 0.3716…生成一个[0,1)之间的double</p>
<pre><code>- 有童鞋问，每次运行程序，生成的随机数都是不同的，没看出伪随机数的特性来。</code></pre><p>这是因为我们创建Random实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同。<br>        - 如果我们在创建Random实例时指定一个种子，就会得到完全确定的随机数序列</p>
<pre><code>        - Random r = new Random(12345);
    for (int i = 0; i &lt; 10; i++) {
        System.out.println(r.nextInt(100));
    }
    // 51, 80, 41, 28, 55...

            - 这样便会每次运行结果都会相同

- 前面我们使用的Math.random()实际上内部调用了Random类，所以它也是伪随机数，只是我们无法指定种子。</code></pre><h3 id="SecureRandom（安全随机数）"><a href="#SecureRandom（安全随机数）" class="headerlink" title="SecureRandom（安全随机数）"></a>SecureRandom（安全随机数）</h3><ul>
<li><p>SecureRandom就是用来创建安全的随机数的</p>
<ul>
<li>SecureRandom的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”</li>
</ul>
</li>
<li><p>SecureRandom无法指定种子，它使用RNG（random number generator）算法。JDK的SecureRandom实际上有多种不同的底层实现，有的使用安全随机种子加上伪随机数算法来产生安全的随机数，有的使用真正的随机数生成器。实际使用的时候，可以优先获取高强度的安全随机数生成器，如果没有提供，再使用普通等级的安全随机数生成器</p>
<ul>
<li>import java.util.Arrays;<br>import java.security.SecureRandom;<br>import java.security.NoSuchAlgorithmException;</li>
</ul>
</li>
</ul>
<p>public class Main {<br>    public static void main(String[] args) {<br>        SecureRandom sr = null;<br>        try {<br>            sr = SecureRandom.getInstanceStrong(); // 获取高强度安全随机数生成器<br>        } catch (NoSuchAlgorithmException e) {<br>            sr = new SecureRandom(); // 获取普通的安全随机数生成器<br>        }<br>        byte[] buffer = new byte[16];<br>        sr.nextBytes(buffer); // 用安全随机数填充buffer<br>        System.out.println(Arrays.toString(buffer));<br>    }//[-21, 67, 90, 41, -76, -20, 91, -84, 56, -65, -18, 52, 28, 70, -66, -2]<br>}</p>
<h2 id="Java的异常"><a href="#Java的异常" class="headerlink" title="Java的异常"></a>Java的异常</h2><h3 id="Java内置了一套异常处理机制，总是使用异常来表示错误。"><a href="#Java内置了一套异常处理机制，总是使用异常来表示错误。" class="headerlink" title="Java内置了一套异常处理机制，总是使用异常来表示错误。"></a>Java内置了一套异常处理机制，总是使用异常来表示错误。</h3><p>异常是一种class，因此它本身带有类型信息。异常可以在任何地方抛出，但只需要在上层捕获，这样就和方法调用分离了</p>
<ul>
<li><p>try {<br>  String s = processFile(“C:\test.txt”);<br>  // ok:<br>} catch (FileNotFoundException e) {<br>  // file not found:<br>} catch (SecurityException e) {<br>  // no read permission:<br>} catch (IOException e) {<br>  // io error:<br>} catch (Exception e) {<br>  // other error:<br>}//注意以上catch的先后</p>
<ul>
<li>存在多个catch的时候，catch的顺序非常重要：子类必须写在前面。</li>
</ul>
</li>
</ul>
<h3 id="因为Java的异常是class，它的继承关系如下："><a href="#因为Java的异常是class，它的继承关系如下：" class="headerlink" title="因为Java的异常是class，它的继承关系如下："></a>因为Java的异常是class，它的继承关系如下：</h3><ul>
<li><p>从继承关系可知：Throwable是异常体系的根，它继承自Object。Throwable有两个体系：Error和Exception，Error表示严重的错误，程序对此一般无能为力，例如：</p>
<ul>
<li>①OutOfMemoryError：内存耗尽</li>
</ul>
</li>
</ul>
<p>②NoClassDefFoundError：无法加载某个Class</p>
<p>③StackOverflowError：栈溢出</p>
<ul>
<li><p>而Exception则是运行时的错误，它可以被捕获并处理。</p>
<ul>
<li>某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如：</li>
</ul>
</li>
</ul>
<p>①NumberFormatException：数值类型的格式错误</p>
<p>②FileNotFoundException：未找到文件</p>
<p>③SocketException：读取网络失败<br>    - Exception分为两大类</p>
<pre><code>- 1.RuntimeException以及它的子类；
- 2.非RuntimeException（包括IOExceptionReflectiveOperationException等等）</code></pre><h3 id="Java规定："><a href="#Java规定：" class="headerlink" title="Java规定："></a>Java规定：</h3><p>① 必须捕获的异常，包括Exception及其子类，但不包括RuntimeException及其子类，这种类型的异常称为Checked Exception。 </p>
<p>② 不需要捕获的异常，包括Error及其子类，RuntimeException及其子类。</p>
<h3 id="在方法定义的时候，使用throws-Xxx表示该方法可能抛出的异常类型。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错。"><a href="#在方法定义的时候，使用throws-Xxx表示该方法可能抛出的异常类型。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错。" class="headerlink" title="在方法定义的时候，使用throws Xxx表示该方法可能抛出的异常类型。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错。"></a>在方法定义的时候，使用throws Xxx表示该方法可能抛出的异常类型。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错。</h3><ul>
<li>String.getBytes(String)方法定义是：</li>
</ul>
<p>public byte[] getBytes(String charsetName) throws UnsupportedEncodingException {<br>    …<br>}</p>
<ul>
<li><p>static byte[] toGBK(String s) {</p>
<pre><code>return s.getBytes(&quot;GBK&quot;);</code></pre><p> }</p>
<ul>
<li><p>调用方toGBK(  )没有捕获可能抛出的异常，会出现编译错误</p>
</li>
<li><p>我们也可以不捕获它，而是在方法定义处用throws表示toGBK()方法可能会抛出UnsupportedEncodingException，就可以让toGBK()方法通过编译器检查：</p>
<ul>
<li><p>static byte[] toGBK(String s) throws UnsupportedEncodingException {<br>return s.getBytes(“GBK”);<br>}</p>
<ul>
<li>同理，调用toGBK(  )方法的方法也需要处理会抛出的异常，main(  )方法也是</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Java的try-…-catch机制还提供了finally语句，finally语句块保证有无错误都会执行。"><a href="#Java的try-…-catch机制还提供了finally语句，finally语句块保证有无错误都会执行。" class="headerlink" title="Java的try … catch机制还提供了finally语句，finally语句块保证有无错误都会执行。"></a>Java的try … catch机制还提供了finally语句，finally语句块保证有无错误都会执行。</h3><p>可见，finally是用来保证一些代码必须执行的。</p>
<ul>
<li>finally语句不是必须的，可写可不写；</li>
<li>finally总是最后执行。</li>
</ul>
<h3 id="一个catch语句也可以匹配多个非继承关系的异常。"><a href="#一个catch语句也可以匹配多个非继承关系的异常。" class="headerlink" title="一个catch语句也可以匹配多个非继承关系的异常。"></a>一个catch语句也可以匹配多个非继承关系的异常。</h3><ul>
<li><p>如果两个非继承关系的异常处理相同，那么可以用’ | ‘将他们合并在同一个catch语句中</p>
<ul>
<li>例如： catch (IOException e) {<br>  System.out.println(“Bad input”);<br>} catch (NumberFormatException e) {<br>  System.out.println(“Bad input”);<br>}</li>
<li>catch (IOException | NumberFormatException e) { // IOException或NumberFormatException<br>  System.out.println(“Bad input”);<br>}</li>
</ul>
</li>
</ul>
<h3 id="通过printStackTrace-可以打印出方法的调用栈"><a href="#通过printStackTrace-可以打印出方法的调用栈" class="headerlink" title="通过printStackTrace()可以打印出方法的调用栈"></a>通过printStackTrace()可以打印出方法的调用栈</h3><ul>
<li><p>使用例子：<br>public class Main {<br>  public static void main(String[] args) {</p>
<pre><code>try {
    process1();
} catch (Exception e) {
    e.printStackTrace();
}</code></pre><p>  }</p>
<p>  static void process1() {</p>
<pre><code>process2();</code></pre><p>  }</p>
<p>  static void process2() {</p>
<pre><code>Integer.parseInt(null); // 会抛出NumberFormatException</code></pre><p>  }<br>}</p>
<ul>
<li>运行结果类似：</li>
</ul>
</li>
</ul>
<p>java.lang.NumberFormatException: null<br>    at java.base/java.lang.Integer.parseInt(Integer.java:614)<br>    at java.base/java.lang.Integer.parseInt(Integer.java:770)<br>    at Main.process2(Main.java:16)<br>    at Main.process1(Main.java:12)<br>    at Main.main(Main.java:5)</p>
<pre><code>- printStackTrace()对于调试错误非常有用，上述信息表示：NumberFormatException是在java.lang.Integer.parseInt方法中被抛出的，从下往上看，调用层次依次是：</code></pre><p>⑴main()调用process1()；<br>⑵process1()调用process2()；<br>⑶process2()调用Integer.parseInt(String)；<br>⑷Integer.parseInt(String)调用Integer.parseInt(String, int)。</p>
<h3 id="在catch中抛出异常，不会影响finally的执行。JVM会先执行finally，然后抛出异常。"><a href="#在catch中抛出异常，不会影响finally的执行。JVM会先执行finally，然后抛出异常。" class="headerlink" title="在catch中抛出异常，不会影响finally的执行。JVM会先执行finally，然后抛出异常。"></a>在catch中抛出异常，不会影响finally的执行。JVM会先执行finally，然后抛出异常。</h3><ul>
<li><p>finally抛出异常后，原来在catch中准备抛出的异常就“消失”了，因为只能抛出一个异常。没有被抛出的异常称为“被屏蔽”的异常（Suppressed Exception）</p>
<ul>
<li>通常不要在finally中抛出异常。如果在finally中抛出异常，应该原始异常加入到原有异常中(方法是先用origin变量保存原始异常，然后调用Throwable.addSuppressed()，把原始异常添加进来)。调用方可通过Throwable.getSuppressed()获取所有添加的Suppressed Exception。如下：</li>
<li>public class Main {<br>public static void main(String[] args) throws Exception {<br>  Exception origin = null;<br>  try {<pre><code>System.out.println(Integer.parseInt(&quot;abc&quot;));</code></pre>  } catch (Exception e) {<pre><code>origin = e;
throw e;</code></pre>  } finally {<pre><code>Exception e = new IllegalArgumentException();
if (origin != null) {
    e.addSuppressed(origin);
}
throw e;</code></pre>  }<br>}<br>}</li>
</ul>
</li>
</ul>
<h3 id="自定义异常注意事项"><a href="#自定义异常注意事项" class="headerlink" title="自定义异常注意事项"></a>自定义异常注意事项</h3><h3 id="使用JDK-Logging"><a href="#使用JDK-Logging" class="headerlink" title="使用JDK Logging"></a>使用JDK Logging</h3><ul>
<li>import java.util.logging.Level;<br>import java.util.logging.Logger;</li>
</ul>
<p>public class Hello {<br>    public static void main(String[] args) {<br>        Logger logger = Logger.getGlobal();<br>        logger.info(“start process…”);<br>        logger.warning(“memory is running out…”);<br>        logger.fine(“ignored.”);<br>        logger.severe(“process will be terminated…”);<br>    }<br>}</p>
<pre><code>- Jun 15, 2020 2:12:55 AM Hello main</code></pre><p>INFO: start process…<br>Jun 15, 2020 2:12:55 AM Hello main<br>WARNING: memory is running out…<br>Jun 15, 2020 2:12:55 AM Hello main<br>SEVERE: process will be terminated…</p>
<pre><code>- 4条日志，只打印了3条，logger.fine()没有打印。这是因为，日志的输出可以设定级别。JDK的Logging定义了7个日志级别，从严重到普通：

    - ①SEVERE</code></pre><p>②WARNING<br>③INFO<br>④CONFIG<br>⑤FINE<br>⑥FINER<br>⑦FINEST</p>
<pre><code>- 因为默认级别是INFO，因此，INFO级别以下的日志，不会被打印出来。使用日志级别的好处在于，调整级别，就可以屏蔽掉很多调试相关的日志输出。</code></pre><h3 id="使用Commons-Logging"><a href="#使用Commons-Logging" class="headerlink" title="使用Commons Logging"></a>使用Commons Logging</h3><ul>
<li><p>和Java标准库提供的日志不同，Commons Logging是一个第三方日志库，它是由Apache创建的日志模块。</p>
</li>
<li><p>Commons Logging的特色是，它可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统。默认情况下，Commons Loggin自动搜索并使用Log4j（Log4j是另一个流行的日志系统），如果没有找到Log4j，再使用JDK Logging。</p>
<ul>
<li>利用JVM动态加载class的特性，我们才能在运行期根据条件加载不同的实现类。例如，Commons Logging总是优先使用Log4j，只有当Log4j不存在时，才使用JDK的logging。</li>
</ul>
</li>
<li><p>使用Commons Logging只需要和两个类打交道，并且只有两步：</p>
</li>
</ul>
<p>第一步，通过LogFactory获取Log类的实例； 第二步，使用Log实例的方法打日志。</p>
<ul>
<li><p>Commons Logging的日志方法，例如info()，除了标准的info(String)外，还提供了一个非常有用的重载方法：info(String, Throwable)，这使得记录异常更加简单：</p>
<ul>
<li>try {<br>…<br>} catch (Exception e) {<br>log.error(“got exception!”, e);<br>}</li>
</ul>
</li>
</ul>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射?"></a>什么是反射?</h3><ul>
<li>Java的反射是指程序在运行期可以拿到一个对象的所有信息。</li>
</ul>
<h3 id="有什么用"><a href="#有什么用" class="headerlink" title="有什么用?"></a>有什么用?</h3><ul>
<li>反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。</li>
</ul>
<h3 id="通过Class实例获取class信息的方法称为反射（Reflection）。"><a href="#通过Class实例获取class信息的方法称为反射（Reflection）。" class="headerlink" title="通过Class实例获取class信息的方法称为反射（Reflection）。"></a>通过Class实例获取class信息的方法称为反射（Reflection）。</h3><ul>
<li><p>Class类</p>
<ul>
<li>这个Class实例是JVM内部创建的，如果我们查看JDK源码，可以发现Class类的构造方法是private，只有JVM能创建Class实例，我们自己的Java程序是无法创建Class实例的。</li>
</ul>
</li>
<li><p>由于JVM为每个加载的class创建了对应的Class实例，并在实例中保存了该class的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个Class实例，我们就可以通过这个Class实例获取到该实例对应的class的所有信息。</p>
<ul>
<li><p>如何获取一个class的Class实例？有三个方法：</p>
<ul>
<li>方法一：直接通过一个class的静态变量class获取：</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Class cls = String.class;<br>        - 方法二：如果我们有一个实例变量，可以通过该实例变量提供的getClass()方法获取：</p>
<p>String s = “Hello”;<br>Class cls = s.getClass();<br>        - 方法三：如果知道一个class的完整类名，可以通过静态方法Class.forName()获取：</p>
<p>Class cls = Class.forName(“java.lang.String”);</p>
<pre><code>- 获取父类的Class

    - 有了Class实例，我们还可以获取它的父类的Class：

    Class i = Integer.class;
    Class n = i.getSuperclass();
    System.out.println(n);
    Class o = n.getSuperclass();
    System.out.println(o);
    System.out.println(o.getSuperclass());


        - 输出为：</code></pre><p>class java.lang.Number<br>class java.lang.Object<br>null<br>            - 此外，对所有interface的Class调用getSuperclass()返回的是null，获取接口的父接口要用getInterfaces(  )：</p>
<pre><code>- 获取interface

    - 由于一个类可能实现一个或多个接口，通过Class我们就可以查询到实现的接口类型。例如，查询Integer实现的接口：

    Class s = Integer.class;
    Class[] is = s.getInterfaces();//接口可能有多个，所以用数组存储
    for (Class i : is) {
        System.out.println(i);
    }

        - 输出为：</code></pre><p>interface java.lang.Comparable<br>            - 要特别注意：getInterfaces(  )只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型</p>
<p>想要得到父类的接口可以先获取Class，如：Class s = Integer.class.getSuperclass(  );然后在返回接口</p>
<ul>
<li>对任意的一个Object实例，只要获取了它的Class，就可以获取它的一切信息。</li>
</ul>
<p>先看看如何通过Class实例获取字段信息。Class类提供了以下几个方法来获取字段：</p>
<pre><code>- ①Field getField(name)：根据字段名获取某个public的field（包括父类）</code></pre><p>②Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）<br>③Field[] getFields()：获取所有public的field（包括父类）<br>④Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）</p>
<ul>
<li><p>一个Field对象包含了一个字段的所有信息：</p>
<ul>
<li><p>getName()：返回字段名称，例如，”name”；</p>
</li>
<li><p>getType()：返回字段类型，也是一个Class实例，例如，String.class；</p>
</li>
<li><p>getModifiers()：返回字段的修饰符，它是一个int，不同的bit表示不同的含义。</p>
<ul>
<li>可以通过返回的int值的二进制来判断各个属性的值</li>
</ul>
</li>
<li><p>以String类的value字段为例，它的定义是：</p>
</li>
</ul>
</li>
</ul>
<p>public final class String {<br>    private final byte[] value;<br>}</p>
<pre><code>- 使用反射获取该字段的信息：</code></pre><p>//利用反射拿到一个实例 f  ↓<br>Field f = String.class.getDeclaredField(“value”);<br>f.getName(); // “value”<br>f.getType(); // class [B 表示byte[]类型<br>int m = f.getModifiers();//m=18=10010，对应下面各个属性的真假↙<br>Modifier.isFinal(m); // true<br>Modifier.isPublic(m); // false<br>Modifier.isProtected(m); // false<br>Modifier.isPrivate(m); // true<br>Modifier.isStatic(m); // false</p>
<pre><code>- 获取字段值

    - 利用反射拿到字段的一个Field实例只是第一步，还可以拿到一个实例对应的该字段的值。

        - 例如，对于一个Person实例，我们可以先拿到name字段对应的Field，再获取这个实例的name字段的值：</code></pre><p>import java.lang.reflect.Field;<br>public class Main {<br>    public static void main(String[] args) throws Exception {<br>        Object p = new Person(“Xiao Ming”);<br>        Class c = p.getClass();     //得到类的class<br>        Field f = c.getDeclaredField(“name”);//得到这个class的name字段<br>        f.setAccessible(true);       //不管这个字段是不是public，一律允许访问。<br>        Object value = f.get(p);   //关于p对象的f字段的值<br>        System.out.println(value); // “Xiao Ming”<br>    }<br>}   </p>
<p>class Person {<br>    private String name;</p>
<pre><code>public Person(String name) {
    this.name = name;
}</code></pre><p>}</p>
<pre><code>- 在这里获取了private的值，如果使用反射可以获取private字段的值，那么类的封装还有什么意义？

    - 答案是正常情况下，我们总是通过p.name来访问Person的name字段，编译器会根据public、protected和private决定是否允许访问字段，这样就达到了数据封装的目的。</code></pre><p>而反射是一种非常规的用法，使用反射，首先代码非常繁琐，其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标实例任何信息的情况下，获取特定字段的值。</p>
<p>此外，setAccessible(true)可能会失败。如果JVM运行期存在SecurityManager，那么它会根据规则进行检查，有可能阻止setAccessible(true)。例如，某个SecurityManager可能不允许对java和javax开头的package的类调用setAccessible(true)，这样可以保证JVM核心库的安全。</p>
<ul>
<li><p>设置字段值</p>
<ul>
<li><p>设置字段值是通过Field.set(Object, Object)实现的，其中第一个Object参数是指定的实例，第二个Object参数是待修改的值。</p>
<ul>
<li>import java.lang.reflect.Field;<br>public class Main {<br>public static void main(String[] args) throws Exception {<br>Person p = new Person(“Xiao Ming”);<br>System.out.println(p.getName()); // “Xiao Ming”<br>Class c = p.getClass();<br>Field f = c.getDeclaredField(“name”);<br>f.setAccessible(true);<br>✄   f.set(p, “Xiao Hong”);//p对象的f字段<br>System.out.println(p.getName()); // “Xiao Hong”<br>}<br>}</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>class Person {<br>    private String name;</p>
<pre><code>public Person(String name) {
    this.name = name;
}

public String getName() {
    return this.name;
}</code></pre><p>}</p>
<ul>
<li><p>通过反射读写字段是一种非常规方法，它会破坏对象的封装。</p>
</li>
<li><p>能通过Class实例获取所有Field对象，同样的，可以通过Class实例获取所有Method信息。</p>
<ul>
<li>Class类提供了以下几个方法来获取Method：</li>
</ul>
</li>
</ul>
<p>① Method getMethod(name, Class…)：获取某个public的Method（包括父类）<br>② Method getDeclaredMethod(name, Class…)：获取当前类的某个Method（不包括父类）<br>③ Method[] getMethods()：获取所有public的Method（包括父类）<br>④ Method[] getDeclaredMethods()：获取当前类的所有Method（不包括父类）</p>
<pre><code>    - public class Main {
public static void main(String[] args) throws Exception {
    Class stdClass = Student.class;
    // 获取public方法getScore，参数为String:
    System.out.println(stdClass.getMethod(&quot;getScore&quot;, String.class));
    // 获取继承的public方法getName，无参数:
    System.out.println(stdClass.getMethod(&quot;getName&quot;));
    // 获取private方法getGrade，参数为int:
    System.out.println(stdClass.getDeclaredMethod(&quot;getGrade&quot;, int.class));
}</code></pre><p>}</p>
<p>class Student extends Person {<br>    public int getScore(String type) {<br>        return 99;<br>    }<br>    private int getGrade(int year) {<br>        return 1;<br>    }<br>}</p>
<p>class Person {<br>    public String getName() {<br>        return “Person”;<br>    }<br>}</p>
<pre><code>- 输出：</code></pre><p>public int Student.getScore(java.lang.String)<br>public java.lang.String Person.getName()<br>private int Student.getGrade(int)</p>
<pre><code>- 一个Method对象包含一个方法的所有信息：</code></pre><p>①getName()：返回方法名称，例如：”getScore”；<br>②getReturnType()：返回方法返回值类型，也是一个Class实例，例如：String.class；<br>③getParameterTypes()：返回方法的参数类型，是一个Class数组，例如：{String.class, int.class}；<br>④getModifiers()：返回方法的修饰符，它是一个int，不同的bit表示不同的含义。</p>
<pre><code>- 当获取到一个Method对象时，就可以对它进行调用。以下面的代码为例：</code></pre><p>String s = “Hello world”;<br>String r = s.substring(6); // “world”</p>
<p>如果用反射来调用substring方法，需要以下代码：<br>import java.lang.reflect.Method;<br>public class Main {<br>    public static void main(String[] args) throws Exception {<br>        // String对象:<br>        String s = “Hello world”;<br>        // 获取String substring(int)方法，参数为int:<br>        Method m = String.class.getMethod(“substring”, int.class);<br>        // 在s对象上调用该方法并获取结果:<br>        String r = (String) m.invoke(s, 6);<br>        // 打印调用结果:<br>        System.out.println(r);//world<br>    }<br>}</p>
<pre><code>- 调用静态方法

    - 如果获取到的Method表示一个静态方法，调用静态方法时，由于无需指定实例对象，所以invoke方法传入的第一个参数永远为null。

        - 以Integer.parseInt(String)为例：</code></pre><p>// 调用该静态方法并获取结果:<br>        Integer n = (Integer) m.invoke(null, “12345”);</p>
<pre><code>- 调用非public方法

    - 和Field类似，对于非public方法，虽然可以通过Class.getDeclaredMethod()获取该方法实例，但直接对其调用将得到一个IllegalAccessException。为了调用非public方法，通过Method.setAccessible(true)允许其调用：

        - import java.lang.reflect.Method;</code></pre><p>public class Main {<br>    public static void main(String[] args) throws Exception {<br>        Person p = new Person();<br>        Method m = p.getClass().getDeclaredMethod(“setName”, String.class);<br>        m.setAccessible(true);//同样，该方法可能调用失败<br>        m.invoke(p, “Bob”);<br>        System.out.println(p.name);//Bob<br>    }<br>}</p>
<p>class Person {<br>    String name;<br>    private void setName(String name) {<br>        this.name = name;<br>    }<br>}</p>
<pre><code>- 使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）。</code></pre><ul>
<li><p>调用构造方法</p>
<ul>
<li>我们通常使用new操作符创建新的实例：<br>Person p = new Person(  );</li>
</ul>
</li>
</ul>
<p>如果通过反射来创建新的实例，可以调用Class提供的newInstance()方法：<br>Person p = Person.class.newInstance(  );</p>
<p>调用Class.newInstance(  )的局限是，它只能调用该类的public无参数构造方法。如果构造方法带有参数，或者不是public，就无法直接通过Class.newInstance()来调用。</p>
<pre><code>- import java.lang.reflect.Constructor;</code></pre><p>public class Main {<br>    public static void main(String[] args) throws Exception {<br>        // 获取构造方法Integer(int):<br>        Constructor cons1 = Integer.class.getConstructor(int.class);</p>
<pre><code>    // 调用构造方法:
    Integer n1 = (Integer) cons1.newInstance(123);
    System.out.println(n1);//123

    // 获取构造方法Integer(String)
    Constructor cons2 = Integer.class.getConstructor(String.class);
    Integer n2 = (Integer) cons2.newInstance(&quot;456&quot;);
    System.out.println(n2);//456
}</code></pre><p>}</p>
<pre><code>- 通过Class实例获取Constructor的方法如下：</code></pre><p>①getConstructor(Class…)：获取某个public的Constructor；<br>②getDeclaredConstructor(Class…)：获取某个Constructor；<br>③getConstructors()：获取所有public的Constructor；<br>④getDeclaredConstructors()：获取所有Constructor。</p>
<p>注意Constructor总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。</p>
<p>调用非public的Constructor时，必须首先通过setAccessible(true)设置允许访问。setAccessible(true)可能会失败。</p>
<h3 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h3><ul>
<li>当我们判断一个实例是否是某个类型时，正常情况下，使用instanceof操作符：</li>
</ul>
<p>Object n = Integer.valueOf(123);<br>boolean isDouble = n instanceof Double; // false<br>boolean isInteger = n instanceof Integer; // true<br>boolean isNumber = n instanceof Number; // true<br>boolean isSerializable = n instanceof java.io.Serializable; // true</p>
<ul>
<li><p>如果是两个Class实例，要判断一个向上转型是否成立，可以调用isAssignableFrom(  )：</p>
<ul>
<li>// Integer i = ?<br>Integer.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Integer<br>// Number n = ?<br>Number.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Number<br>// Object o = ?<br>Object.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Object<br>// Integer i = ?<br>Integer.class.isAssignableFrom(Number.class); // false，因为Number不能赋值给Integer</li>
</ul>
</li>
</ul>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><ul>
<li>Java标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个interface的实例。</li>
</ul>
<p>什么叫运行期动态创建？听起来好像很复杂。所谓动态代理，是和静态相对应的。我们来看静态代码怎么写： </p>
<pre><code>- 定义接口：</code></pre><p>public interface Hello {<br>    void morning(String name);<br>}</p>
<p>编写实现类：<br>public class HelloWorld implements Hello {<br>    public void morning(String name) {<br>        System.out.println(“Good morning, “ + name);<br>    }<br>}</p>
<p>创建实例，转型为接口并调用：<br>Hello hello = new HelloWorld();<br>hello.morning(“Bob”);</p>
<ul>
<li><p>还有一种方式是动态代码，我们仍然先定义了接口Hello，但是我们并不去编写实现类，而是直接通过JDK提供的一个Proxy.newProxyInstance()创建了一个Hello接口对象。这种没有实现类但是在运行期动态创建了一个接口对象的方式，我们称为动态代码。JDK提供的动态创建接口对象的方式，就叫动态代理。</p>
<ul>
<li>import java.lang.reflect.InvocationHandler;<br>import java.lang.reflect.Method;<br>import java.lang.reflect.Proxy;</li>
</ul>
</li>
</ul>
<p>public class Main {<br>    public static void main(String[] args) {<br>        InvocationHandler handler = new InvocationHandler() {<br>            @Override<br>            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {<br>                System.out.println(method);<br>                if (method.getName().equals(“morning”)) {<br>                    System.out.println(“Good morning, “ + args[0]);<br>                }<br>                return null;<br>            }<br>        };//类似匿名类实现方式<br>        Hello hello = (Hello) Proxy.newProxyInstance(<br>            Hello.class.getClassLoader(), // 传入ClassLoader<br>            new Class[] { Hello.class }, // 传入要实现的接口，可能不止一个所以用class数组表示？<br>            handler); // 传入处理调用方法的InvocationHandler<br>        hello.morning(“Bob”);<br>    }<br>}</p>
<p>interface Hello {<br>    void morning(String name);<br>}</p>
<pre><code>- 输出：</code></pre><p>public abstract void Hello.morning(java.lang.String)<br>Good morning, Bob<br>        - 使用思路是：<br>⑴  定义一个InvocationHandler实例，它负责实现接口的方法调用；<br>⑵  通过Proxy.newProxyInstance()创建interface实例，它需要3个参数：<br>      ①使用的ClassLoader，通常就是接口类的ClassLoader；<br>      ②需要实现的接口数组，至少需要传入一个接口进去；<br>      ③用来处理接口方法调用的InvocationHandler实例。<br>⑶将返回的Object强制转型为接口。<br>        - public class Main {<br>    public static void main(String[] args) {<br>        Hello hello = new Hello() {<br>            @Override<br>            public void morning(String name){<br>                System.out.println(“Goode morning,”+name);<br>            }<br>        };<br>        hello.morning(“Bob”);<br>    }<br>}</p>
<p>interface Hello {<br>    void morning(String name);<br>}</p>
<pre><code>- 使用匿名类实现，这两者会有什么区别呢?</code></pre><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”："><a href="#注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”：" class="headerlink" title="注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”："></a>注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”：</h3><p>注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。</p>
<h3 id="Java的注解可以分为三类："><a href="#Java的注解可以分为三类：" class="headerlink" title="Java的注解可以分为三类："></a>Java的注解可以分为三类：</h3><ul>
<li>第一类是由编译器使用的注解，例如：</li>
</ul>
<p>@Override：让编译器检查该方法是否正确地实现了覆写；<br>@SuppressWarnings：告诉编译器忽略此处代码产生的警告。<br>这类注解不会被编译进入.class文件，它们在编译后就被编译器扔掉了。</p>
<ul>
<li>第二类是由工具处理.class文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入.class文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。</li>
<li>第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了@PostConstruct的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</li>
</ul>
<h3 id="定义注解："><a href="#定义注解：" class="headerlink" title="定义注解："></a>定义注解：</h3><ul>
<li><p>java语言使用@interface语法来定义注解（Annotation），它的格式如下：</p>
<ul>
<li>public @interface Report {<br>int type() default 0;<br>String level() default “info”;<br>String value() default “”;<br>}</li>
<li>注解的参数类似无参数方法，可以用default设定一个默认值（强烈推荐）。最常用的参数应当命名为value。</li>
</ul>
</li>
<li><p>第一步，用@interface定义注解：</p>
</li>
</ul>
<p>public @interface Report {<br>}</p>
<pre><code>- 第二步，添加参数、默认值：</code></pre><p>把最常用的参数定义为value()，推荐所有参数都尽量设置默认值。</p>
<p>public @interface Report {<br>    int type() default 0;<br>    String level() default “info”;<br>    String value() default “”;<br>}</p>
<pre><code>- 第三步，用元注解配置注解：</code></pre><p>@Target(ElementType.TYPE)<br>@Retention(RetentionPolicy.RUNTIME)<br>public @interface Report {<br>    int type() default 0;<br>    String level() default “info”;<br>    String value() default “”;<br>}<br>其中，必须设置@Target和@Retention，@Retention一般设置为RUNTIME，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写@Inherited和@Repeatable。</p>
<h3 id="注解定义后也是一种class，所有的注解都继承自java-lang-annotation-Annotation，读取注解，需要使用反射API。"><a href="#注解定义后也是一种class，所有的注解都继承自java-lang-annotation-Annotation，读取注解，需要使用反射API。" class="headerlink" title="注解定义后也是一种class，所有的注解都继承自java.lang.annotation.Annotation，读取注解，需要使用反射API。"></a>注解定义后也是一种class，所有的注解都继承自java.lang.annotation.Annotation，读取注解，需要使用反射API。</h3><p>是class不是类，class是上面关于反射的</p>
<ul>
<li>Java提供的使用反射API读取Annotation的方法包括：</li>
</ul>
<p>判断某个注解是否存在于Class、Field、Method或Constructor：<br>//都是静态方法<br>▢    Class.isAnnotationPresent(Class)<br>▢    Field.isAnnotationPresent(Class)<br>▢    Method.isAnnotationPresent(Class)<br>▢    Constructor.isAnnotationPresent(Class)</p>
<pre><code>- 例如：</code></pre><p>// 判断@Report是否存在于Person类:<br>Person.class.isAnnotationPresent(Report.class);</p>
<ul>
<li>使用反射API读取Annotation：</li>
</ul>
<p>▢   Class.getAnnotation(Class)<br>▢   Field.getAnnotation(Class)<br>▢   Method.getAnnotation(Class)<br>▢   Constructor.getAnnotation(Class)</p>
<pre><code>- 例如：</code></pre><p>// 获取Person定义的@Report注解:<br>//竟然可以用注解创建对象。↓<br>Report report = Person.class.getAnnotation(Report.class);<br>//若注解Report不存在将返回空<br>int type = report.type();//然后获取注解的一些值？<br>String level = report.level();</p>
<ul>
<li><p>读取方法、字段和构造方法的Annotation和Class类似。但要读取方法参数的Annotation就比较麻烦一点，因为方法参数本身可以看成一个数组，而每个参数又可以定义多个注解，所以，一次获取方法参数的所有注解就必须用一个二维数组来表示。</p>
<ul>
<li>例如，对于以下方法定义的注解：</li>
</ul>
</li>
</ul>
<p>public void hello(@NotNull @Range(max=5) String name, @NotNull String prefix) {}</p>
<pre><code>- 要读取方法参数的注解，我们先用反射获取Method实例，然后读取方法参数的所有注解：</code></pre><p>// 获取Method实例:<br>Method m = …<br>// 获取所有参数的Annotation:<br>Annotation[][] annos = m.getParameterAnnotations();//每个一维数组存储一个参数的注解<br>// 第一个参数（索引为0）的所有Annotation:<br>Annotation[] annosOfName = annos[0];<br>for (Annotation anno : annosOfName) {//这里好像只求了第一个一维数组的注解<br>    if (anno instanceof Range) { // @Range注解<br>        Range r = (Range) anno;<br>    }<br>    if (anno instanceof NotNull) { // @NotNull注解<br>        NotNull n = (NotNull) anno;<br>    }<br>}</p>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><ul>
<li>有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。</li>
</ul>
<p>Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。</p>
<ul>
<li><p>@Target</p>
<ul>
<li><p>最常用的元注解是@Target。使用@Target可以定义注解能够被应用于源码的哪些位置：</p>
<ul>
<li>▲   类或接口：ElementType.TYPE；<br>▲   字段：         ElementType.FIELD；<br>▲   方法：         ElementType.METHOD；<br>▲   构造方法：ElementType.CONSTRUCTOR；<br>▲   方法参数：ElementType.PARAMETER。</li>
<li>例如，定义注解@Report可用在方法上，我们必须添加一个@Target(ElementType.METHOD)：</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>@Target(ElementType.METHOD)  //在此修饰Report注解<br>public @interface Report {<br>    int type() default 0;<br>    String level() default “info”;<br>    String value() default “”;<br>}</p>
<p>//定义注解@Report可用在方法或字段上，可以把@Target注解参数变为数组{ ElementType.METHOD, ElementType.FIELD }：</p>
<ul>
<li><p>@Retention</p>
<ul>
<li><p>另一个重要的元注解@Retention定义了Annotation的生命周期：</p>
<ul>
<li><p>▧    仅编译期：      RetentionPolicy.SOURCE；<br>▨    仅class文件：RetentionPolicy.CLASS；<br>▨    运行期：          RetentionPolicy.RUNTIME。</p>
<ul>
<li>如何使用注解完全由工具决定。SOURCE类型的注解主要由编译器使用，因此我们一般只使用，不编写。CLASS类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。只有RUNTIME类型的注解不但要使用，还经常需要编写。</li>
</ul>
</li>
<li><p>如果@Retention不存在，则该Annotation默认为CLASS。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>因为通常我们自定义的注解都是RUNTIME，所以，务必要加上@Retention(RetentionPolicy.RUNTIME)这个元注解</p>
<pre><code>- @Retention(RetentionPolicy.RUNTIME)</code></pre><p>public @interface Report {<br>    int type() default 0;<br>    String level() default “info”;<br>    String value() default “”;<br>}</p>
<ul>
<li><p>@Repeatable</p>
<ul>
<li>使用@Repeatable这个元注解可以定义Annotation是否可重复。</li>
</ul>
</li>
<li><p>@Inherited</p>
<ul>
<li><p>使用@Inherited定义子类是否可继承父类定义的Annotation。@Inherited仅针对@Target(ElementType.TYPE)类型的annotation有效，并且仅针对class的继承，对interface的继承无效：</p>
<ul>
<li><p>@Inherited<br>@Target(ElementType.TYPE)<br>public @interface Report {//定义注解Report<br>int type() default 0;<br>String level() default “info”;<br>String value() default “”;<br>}</p>
<ul>
<li>在使用的时候，如果一个类用到了@Report：</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>@Report(type=1)<br>public class Person {<br>}</p>
<p>则它的子类默认也定义了该注解：</p>
<p>public class Student extends Person {<br>}</p>
<h3 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h3><ul>
<li>注解如何使用，完全由程序自己决定。例如，JUnit是一个测试框架，它会自动运行所有标记为@Test的方法。<br>//什么意思?↑<br>我们来看一个@Range注解，我们希望用它来定义一个String字段的规则：字段长度满足@Range的参数定义：</li>
</ul>
<p>@Retention(RetentionPolicy.RUNTIME)<br>@Target(ElementType.FIELD)<br>public @interface Range {<br>    int min() default 0;<br>    int max() default 255;<br>}</p>
<p>在某个JavaBean中，我们可以使用该注解：</p>
<p>public class Person {<br>    @Range(min=1, max=20)<br>    public String name;</p>
<pre><code>@Range(max=10)
public String city;</code></pre><p>}</p>
<pre><code>- 但是，定义了注解，本身对程序逻辑没有任何影响。我们必须自己编写代码来使用注解。这里，我们编写一个Person实例的检查方法，它可以检查Person实例的String字段长度是否满足@Range的定义：</code></pre><p>void check(Person person) throws IllegalArgumentException, ReflectiveOperationException {<br>    // 遍历所有Field:<br>    for (Field field : person.getClass().getFields()) {<br>        // 获取Field定义的@Range:<br>        Range range = field.getAnnotation(Range.class);<br>        // 如果@Range存在:<br>        if (range != null) {<br>            // 获取Field的值:<br>            Object value = field.get(person);<br>            // 如果值是String:<br>            if (value instanceof String) {<br>                String s = (String) value;<br>                // 判断值是否满足@Range的min/max:<br>                if (s.length() &lt; range.min() || s.length() &gt; range.max()) {<br>                    throw new IllegalArgumentException(“Invalid field: “ + field.getName());<br>                }<br>            }<br>        }<br>    }<br>}</p>
<pre><code>- 这样一来，我们通过@Range注解，配合check()方法，就可以完成Person实例的检查。注意检查逻辑完全是我们自己编写的，JVM不会自动给注解添加任何额外的逻辑。</code></pre><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="泛型是一种“代码模板”，可以用一套代码套用各种类型。"><a href="#泛型是一种“代码模板”，可以用一套代码套用各种类型。" class="headerlink" title="泛型是一种“代码模板”，可以用一套代码套用各种类型。"></a>泛型是一种“代码模板”，可以用一套代码套用各种类型。</h3><ul>
<li>泛型就是定义一种模板，例如ArrayList<T>，然后在代码中为用到的类创建对应的ArrayList&lt;类型&gt;：<br>例如：<br>ArrayList<String> strList = new ArrayList<String>();<br>ArrayList<Float> floatList = new ArrayList<Float>();<br>ArrayList<Person> personList = new ArrayList<Person>();</li>
</ul>
<p>编译器看到泛型类型List<Number>就可以自动推断出后面的ArrayList<T>的泛型类型必须是ArrayList<Number>，因此，可以把代码简写为：</p>
<p>// 可以省略后面的Number，编译器可以自动推断泛型类型：<br>List<Number> list = new ArrayList&lt;&gt;();</p>
<pre><code>- 使用ArrayList时，如果不定义泛型类型时，泛型类型实际上就是Object：</code></pre><p>// 编译器警告:<br>List list = new ArrayList();<br>list.add(“Hello”);<br>list.add(“World”);<br>String first = (String) list.get(0);//必须强转为String，因为Object不能下转为String<br>String second = (String) list.get(1);<br>//此时，只能把<T>当作Object使用，没有发挥泛型的优势。<br>    - 当我们定义泛型类型<String>后，List<T>的泛型接口变为强类型List<String>：</p>
<p>// 无编译器警告:<br>List<String> list = new ArrayList<String>();<br>list.add(“Hello”);<br>list.add(“World”);<br>// 无强制转型:<br>String first = list.get(0);//这里就不用再强转了<br>String second = list.get(1);</p>
<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><ul>
<li>除了ArrayList<T>使用了泛型，还可以在接口中使用泛型。例如，Arrays.sort(Object[])可以对任意数组进行排序，但待排序的元素必须实现Comparable<T>这个泛型接口：</li>
</ul>
<p>public interface Comparable<T> {<br>    /**<br>     * 返回-1: 当前实例比参数o小<br>     * 返回0: 当前实例与参数o相等<br>     * 返回1: 当前实例比参数o大<br>     */<br>    int compareTo(T o);<br>}</p>
<pre><code>- 自定义类Person实现接口Comparable：</code></pre><p>import java.util.Arrays;</p>
<p>public class Main {<br>    public static void main(String[] args) {<br>        Person[] ps = new Person[] {<br>            new Person(“Bob”, 61),<br>            new Person(“Alice”, 88),<br>            new Person(“Lily”, 75),<br>        };<br>        Arrays.sort(ps); //注意这里是对Person类型的数组排序<br>        System.out.println(Arrays.toString(ps));<br>    }<br>}</p>
<p>class Person implements Comparable<Person> {//注意实现接口方式<br>    String name;<br>    int score;<br>    Person(String name, int score) {<br>        this.name = name;<br>        this.score = score;<br>    }<br>    public int compareTo(Person other) {//哪里会调用这个函数？<br>        return this.name.compareTo(other.name);<br>    }<br>    public String toString() {<br>        return this.name + “,” + this.score;<br>    }<br>}</p>
<pre><code>- 这里Person类实现了Comparable接口之后，可以为Person类型的数组排序</code></pre><h3 id="编写泛型"><a href="#编写泛型" class="headerlink" title="编写泛型"></a>编写泛型</h3><ul>
<li>首先，按照某种类型，例如：String，来编写类：</li>
</ul>
<p>public class Pair {<br>    private String first;<br>    private String last;<br>    public Pair(String first, String last) {<br>        this.first = first;<br>        this.last = last;<br>    }<br>    public String getFirst() {<br>        return first;<br>    }<br>    public String getLast() {<br>        return last;<br>    }<br>}</p>
<pre><code>- 把特定类型String替换为T，并申明&lt;T&gt;：</code></pre><p>▷public class Pair<T> {//注意这里声明了T<br>   ▷ private T first;<br>   ▷ private T last;<br>   ▷ public Pair(T first, T last) {<br>        this.first = first;<br>        this.last = last;<br>    }<br>    ▷public T getFirst() {<br>        return first;<br>    }<br>    ▷public T getLast() {<br>        return last;<br>    }<br>}<br>//都是将对应类型换成泛型T</p>
<ul>
<li><p>多个泛型类型</p>
<ul>
<li>泛型还可以定义多种类型。例如，我们希望Pair不总是存储两个类型一样的对象，就可以使用类型&lt;T, K&gt;：</li>
</ul>
</li>
</ul>
<p>public class Pair&lt;T, K&gt; {<br>    private T first;<br>    private K last;<br>    public Pair(T first, K last) {<br>        this.first = first;<br>        this.last = last;<br>    }<br>    public T getFirst() { … }<br>    public K getLast() { … }<br>}</p>
<pre><code>- 使用的时候，需要指出两种类型：</code></pre><p>//↓因为这个泛型类有两个类型，所以构造时也需要两个类型参数<br>Pair&lt;String, Integer&gt; p = new Pair&lt;&gt;(“test”, 123);<br>//注意这里使用的是Integer，不是int，因为int不是类，不能上转为Object<br>//Pair p=new Pair(“test”,123);可以使用<br>//也就是不用专门声明类型，好像可以自动匹配</p>
<pre><code>- Java标准库的Map&lt;K, V&gt;就是使用两种泛型类型的例子。它对Key使用一种类型，对Value使用另一种类型。</code></pre><h3 id="使用泛型声明注意："><a href="#使用泛型声明注意：" class="headerlink" title="使用泛型声明注意："></a>使用泛型声明注意：</h3><ul>
<li><p>//注意这个泛型类的参数个数<br>public class Pair&lt;T, K&gt; {<br>  private T first;<br>  private K last;<br>  public Pair(T first, K last) {</p>
<pre><code>this.first = first;
this.last = last;</code></pre><p>  }<br>  public T getFirst() { … }<br>  public K getLast() { … }<br>}</p>
<ul>
<li>两种种声明方式：</li>
</ul>
</li>
</ul>
<p>①Pair a=new Pair(23,34.34);<br> //可以通过编译，直接使用构造函数生成对象，这种方式书写简单些，会有局限吗？</p>
<p>②Pair&lt;Integer,String&gt; a=new Pair&lt;&gt;(23,”CLi”);<br>//构造参数类型必须与前面泛型声明类型一致，否则无法通过编译</p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><ul>
<li><p>静态方法的泛型类型和实例类型的泛型类型需要区分开。</p>
</li>
<li><p>public class Pair<T> {<br>  private T first;<br>  private T last;<br>  public Pair(T first, T last) {</p>
<pre><code>this.first = first;
this.last = last;</code></pre><p>  }<br>  public T getFirst() { … }<br>  public T getLast() { … }</p>
<p>  // 注意在static后面加了<T><br>  public static <T> Pair<T> create(T first, T last) {</p>
<pre><code>return new Pair&lt;T&gt;(first, last);</code></pre><p>  }//实际上，这个<T>和Pair<T>类型的<T>已经没有任何关系了。<br>}</p>
<ul>
<li>所以需要将<T>改为其他泛型名，以防理解混淆。对于静态方法，我们可以单独改写为“泛型”方法，只需要使用另一个类型即可。例如，<K>：</li>
</ul>
</li>
</ul>
<p>public class Pair<T> {<br>    private T first;<br>    private T last;<br>    public Pair(T first, T last) {<br>        this.first = first;<br>        this.last = last;<br>    }<br>    public T getFirst() { … }<br>    public T getLast() { … }</p>
<pre><code>// 静态泛型方法应该使用其他类型区分:
public static &lt;K&gt; Pair&lt;K&gt; create(K first, K last) {//使用这个静态方法创建对象不会报错
    return new Pair&lt;K&gt;(first, last);
}</code></pre><p>}</p>
<h3 id="Java语言的泛型实现方式是擦拭法（Type-Erasure）。"><a href="#Java语言的泛型实现方式是擦拭法（Type-Erasure）。" class="headerlink" title="Java语言的泛型实现方式是擦拭法（Type Erasure）。"></a>Java语言的泛型实现方式是擦拭法（Type Erasure）。</h3><p>所谓擦拭法是指，虚拟机对泛型其实一无所知，所有的工作都是编译器做的。</p>
<ul>
<li>例如，我们编写了一个泛型类Pair<T>，这是编译器看到的代码：</li>
</ul>
<p>public class Pair<T> {<br>    private T first;<br>    private T last;<br>    public Pair(T first, T last) {<br>        this.first = first;<br>        this.last = last;<br>    }<br>    public T getFirst() {<br>        return first;<br>    }<br>    public T getLast() {<br>        return last;<br>    }<br>}</p>
<pre><code>- 而虚拟机根本不知道泛型。这是虚拟机执行的代码：</code></pre><p>public class Pair {<br>    private Object first;<br>    private Object last;<br>    public Pair(Object first, Object last) {<br>        this.first = first;<br>        this.last = last;<br>    }<br>    public Object getFirst() {<br>        return first;<br>    }<br>    public Object getLast() {<br>        return last;<br>    }<br>}</p>
<ul>
<li>使用泛型的时候，我们编写的代码也是编译器看到的代码：</li>
</ul>
<p>Pair<String> p = new Pair&lt;&gt;(“Hello”, “world”);<br>String first = p.getFirst();<br>String last = p.getLast();</p>
<p>而虚拟机执行的代码并没有泛型：<br>//虚拟机执行的是编译器强制转型之后的代码？<br>Pair p = new Pair(“Hello”, “world”);<br>String first = (String) p.getFirst();<br>String last = (String) p.getLast();</p>
<pre><code>- 所以，Java的泛型是由编译器在编译时实行的，编译器内部永远把所有类型T视为Object处理，但是，在需要转型的时候，编译器会根据T的类型自动为我们实行安全地强制转型。
- 所以这一系列步骤是编译器所完成的</code></pre><ul>
<li><p>了解了Java泛型的实现方式——擦拭法，我们就知道了Java泛型的局限：</p>
<ul>
<li>①局限一：<T>不能是基本类型，例如int，因为实际类型是Object，Object类型无法持有基本类型：</li>
</ul>
</li>
</ul>
<p>Pair<int>  p = new Pair&lt;&gt;(1, 2); // compile error!<br>Pair<Integer> p=new Pair&lt;&gt;(1,2);//ok!<br>    - ②局限二：无法取得带泛型的Class。</p>
<pre><code>- //Pair是一个泛型类</code></pre><p>因为T是Object，我们对Pair<String>和Pair<Integer>类型获取Class时，获取到的是同一个Class，也就是Pair类的Class。</p>
<p>换句话说，所有泛型实例，无论T的类型是什么，getClass()返回同一个Class实例，因为编译后它们全部都是Pair<Object>。</p>
<pre><code>- ③局限三：无法判断带泛型的类型。

    - Pair&lt;Integer&gt; p = new Pair&lt;&gt;(123, 456);</code></pre><p>// Compile error:<br>if (p instanceof Pair<String>) {<br>}<br>//原因和前面一样，并不存在Pair<String>.class，而是只有唯一的Pair.class</p>
<pre><code>- ④局限四：不能实例化T类型。

    - public class Pair&lt;T&gt; {
private T first;
private T last;
public Pair() {
    // Compile error:
    first = new T();
    last = new T();
}</code></pre><p>}<br>上述代码无法通过编译，因为构造方法的两行语句：</p>
<p>first = new T();<br>last = new T();<br>擦拭后实际上变成了：</p>
<p>first = new Object();<br>last = new Object();<br>这样一来，创建new Pair<String>()和创建new Pair<Integer>()就全部成了Object，显然编译器要阻止这种类型不对的代码。</p>
<h3 id="不恰当的覆写方法"><a href="#不恰当的覆写方法" class="headerlink" title="不恰当的覆写方法"></a>不恰当的覆写方法</h3><ul>
<li>有些时候，一个看似正确定义的方法会无法通过编译。例如：</li>
</ul>
<p>public class Pair<T> {<br>    public boolean equals(T t) {<br>        return this == t;<br>    }<br>}</p>
<pre><code>- 这是因为，定义的equals(T t)方法实际上会被擦拭成equals(Object t)，而这个方法是继承自Object的，编译器会阻止一个实际上会变成覆写的泛型方法定义。</code></pre><p>换个方法名，避开与Object.equals(Object)的冲突就可以成功编译：</p>
<p>public class Pair<T> {<br>    public boolean same(T t) {<br>        return this == t;<br>    }<br>}</p>
<h3 id="泛型继承"><a href="#泛型继承" class="headerlink" title="泛型继承"></a>泛型继承</h3><ul>
<li>一个类可以继承自一个泛型类。例如：父类的类型是Pair<Integer>，子类的类型是IntPair，可以这么继承：</li>
</ul>
<p>public class IntPair extends Pair<Integer> {<br>}</p>
<p>使用的时候，因为子类IntPair并没有泛型类型，所以，正常使用即可：</p>
<p>IntPair ip = new IntPair(1, 2);//但是只能使用Integer类型的参数，因为父类的泛型为Integer</p>
<ul>
<li>我们无法获取Pair<T>的T类型，即给定一个变量Pair<Integer> p，无法从p中获取到Integer类型。</li>
</ul>
<p>但是，在父类是泛型类型的情况下，编译器就必须把类型T（对IntPair来说，也就是Integer类型）保存到子类的class文件中，不然编译器就不知道IntPair只能存取Integer这种类型。</p>
<p>在继承了泛型类型的情况下，子类可以利用反射获取父类的泛型类型，也就是Integer。</p>
<h3 id="Pair不是Pair的子类，因此，add-Pair-不接受参数类型Pair。"><a href="#Pair不是Pair的子类，因此，add-Pair-不接受参数类型Pair。" class="headerlink" title="Pair不是Pair的子类，因此，add(Pair)不接受参数类型Pair。"></a>Pair<Integer>不是Pair<Number>的子类，因此，add(Pair<Number>)不接受参数类型Pair<Integer>。</h3><h3 id="extends通配符"><a href="#extends通配符" class="headerlink" title="extends通配符"></a>extends通配符</h3><ul>
<li>假设我们定义了Pair<T>:</li>
</ul>
<p>public class Pair<T> { … }<br>然后，我们又针对Pair<Number>类型写了一个静态方法，它接收的参数类型是Pair<Number>：</p>
<p>public class PairHelper {<br>    static int add(Pair<Number> p) {<br>        Number first = p.getFirst();//不能将其换成 Integer first = p.getFirst();<br>        Number last = p.getLast(); //因为有可能是其他的Number子类，不能直接赋值给Integer<br>        p.setFirst(new Integer(first.intValue() + 100));//会报错，这样写的话只能传入Integer类型参 数，其他Number子类<br>        p.setLast(new Integer(last.intValue() + 100));//无法传入。但改为Number参数的话，又与所实例化的Pair&lt;类型&gt;的public void setFirst(T first) {}有所冲突，因为setFirst的参数只能为Pair&lt;类型&gt;实例化的类型<br>        return first.intValue() + last.intValue();<br>    }<br>}</p>
<pre><code>- Pair&lt;Integer&gt; p = new Pair&lt;&gt;(123, 456);</code></pre><p>int n = add(p);<br>System.out.println(n);</p>
<p>//将会得到编译错误，因为Pair<Integer>不是Pair<Number>的子类<br>因此，add(Pair<Number>)不接受参数类型Pair<Integer>。<br>    - 将add参数改为：Pair&lt;? extends Number&gt; p 使得方法接收所有泛型类型为Number或Number子类的Pair类型。可以使得编译通过</p>
<p>这种使用&lt;? extends Number&gt;的泛型定义称之为上界通配符（Upper Bounds Wildcards），即把泛型类型T的上界限定在Number了。</p>
<ul>
<li><p>&lt;? extends Number&gt;通配符的一个重要限制：方法参数签名setFirst(? extends Number)无法传递任何Number类型给setFirst(? extends Number)。</p>
<ul>
<li>通过这个限制可以实现只读方法（恶意调用set(null)除外）。</li>
</ul>
</li>
</ul>
<p>所以使用List&lt;? extends Integer&gt;或List<Integer>是有不同的</p>
<pre><code>- 定义一个方法来处理列表的每个元素：</code></pre><p>int sumOfList(List&lt;? extends Integer&gt; list) {<br>    int sum = 0;<br>    for (int i=0; i&lt;list.size(); i++) {<br>        Integer n = list.get(i);<br>        sum = sum + n;<br>    }<br>    return sum;<br>}//使用List&lt;? extends Integer&gt;实现只读而不修改数据</p>
<h3 id="super通配符"><a href="#super通配符" class="headerlink" title="super通配符"></a>super通配符</h3><ul>
<li><p>与extends通配符相反，super通配符是接收所定义泛型类型的父类</p>
</li>
<li><p>例如：<br>void set(Pair&lt;? super Integer&gt; p, Integer first, Integer last) {//注意这里first和last都是固定的Integer<br>  p.setFirst(first);<br>  p.setLast(last);<br>}<br>注意到Pair&lt;? super Integer&gt;表示，方法参数接受所有泛型类型为Integer或Integer父类的Pair类型。</p>
<ul>
<li>使用&lt;? super Integer&gt;通配符表示：<br>✓   允许调用set(? super Integer)方法传入Integer的引用；<br>//setFirst()方法，它的方法签名实际上是：void setFirst(? super Integer);<br>✗   不允许调用get()方法获得Integer的引用。</li>
</ul>
</li>
</ul>
<p>唯一例外是可以获取Object的引用：Object o = p.getFirst()。</p>
<p>换句话说，使用&lt;? super Integer&gt;通配符作为方法参数，表示方法内部代码对于参数只能写，不能读。</p>
<h3 id="使用extends限定泛型类型"><a href="#使用extends限定泛型类型" class="headerlink" title="使用extends限定泛型类型"></a>使用extends限定泛型类型</h3><ul>
<li>在定义泛型类型Pair<T>的时候，也可以使用extends通配符来限定T的类型：</li>
</ul>
<p>public class Pair<T extends Number> { … }</p>
<pre><code>- 这里只能将其定义为Number或其子类类型</code></pre><p>非Number类型将无法通过编译：<br>Pair<String> p1 = null; // compile error!<br>Pair<Object> p2 = null; // compile error!</p>
<h3 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h3><ul>
<li>无限定通配符（Unbounded Wildcard Type），即只定义一个?：</li>
</ul>
<p>void sample(Pair&lt;?&gt; p) {<br>}</p>
<pre><code>- 因为&lt;?&gt;通配符既没有extends，也没有super，因此：</code></pre><p>✘不允许调用set(T)方法并传入引用（null除外）；<br>✘不允许调用T get()方法并获取T引用（只能获取Object引用）。<br>    - 换句话说，既不能读，也不能写，那只能做一些null判断：<br>static boolean isNull(Pair<?> p) {
    return p.getFirst() == null || p.getLast() == null;
}
大多数情况下，可以引入泛型参数<T>消除<?>通配符：</p>
<p>static <T> boolean isNull(Pair<T> p) {<br>    return p.getFirst() == null || p.getLast() == null;<br>}</p>
<pre><code>- &lt;?&gt;通配符有一个独特的特点，就是：Pair&lt;?&gt;是所有Pair&lt;T&gt;的超类：</code></pre><p> Pair<Integer> p = new Pair&lt;&gt;(123, 456);<br> Pair<?> p2 = p; // 安全地向上转型
//Pair<Integer>是Pair<?>的子类，可以安全地向上转型。</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合。"><a href="#在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合。" class="headerlink" title="在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合。"></a>在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合。</h3><ul>
<li>Java标准库自带的  “java.util”  包提供了集合类：Collection，它是除Map外所有其他集合类的根接口。<br>Java的java.util包主要提供了以下三种类型的集合：</li>
</ul>
<p>⚀ List：一种有序列表的集合，例如，按索引排列的Student的List；<br>⚁ Set：一种保证没有重复元素的集合，例如，所有无重复名称的Student的Set；<br>⚂ Map：一种通过键值（key-value）查找的映射表集合，例如，根据Student的name查找对应Student的Map。</p>
<h3 id="Java集合的设计有几个特点："><a href="#Java集合的设计有几个特点：" class="headerlink" title="Java集合的设计有几个特点："></a>Java集合的设计有几个特点：</h3><p>①一是实现了接口和实现类相分离，例如，有序表的接口是List，具体的实现类有ArrayList，LinkedList等。</p>
<p>②二是支持泛型，我们可以限制在一个集合中只能放入同一种数据类型的元素，例如：<br>List<String> list = new ArrayList&lt;&gt;(); // 只能放入String类型</p>
<p>③最后，Java访问集合总是通过统一的方式——迭代器（Iterator）来实现，它最明显的好处在于无需知道集合内部元素是按什么方式存储的。</p>
<h3 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator(迭代器)"></a>Iterator(迭代器)</h3><ul>
<li>Java的集合类都可以使用for each循环，List、Set和Queue会迭代每个元素，Map会迭代每个key。</li>
</ul>
<p>Java编译器并不知道如何遍历List。上述代码能够编译通过，只是因为编译器把for each循环通过Iterator改写为了普通的for循环：</p>
<pre><code>- List&lt;String&gt; list = List.of(&quot;Apple&quot;, &quot;Orange&quot;, &quot;Pear&quot;);</code></pre><p>for (String s : list) {<br>    System.out.println(s);<br>}<br>    - for (Iterator<String> it = list.iterator(); it.hasNext(); ) {<br>     String s = it.next();<br>     System.out.println(s);<br>}</p>
<ul>
<li>使用迭代器的好处在于，调用方总是以统一的方式遍历各种集合类型，而不必关系它们内部的存储结构。//有点像多态，同样的代码，在不同对象时实现同样的功能，不必随对象改变而改变使用方式</li>
<li>Iterator对象是集合对象自己在内部创建的，它自己知道如何高效遍历内部的数据集合，调用方获得了统一的代码，编译器才能把标准的for each循环自动转换为Iterator遍历。</li>
<li>如果我们自己编写了一个集合类，想要使用for each循环，只需满足以下条件：</li>
</ul>
<p>①集合类实现Iterable接口，该接口要求返回一个Iterator对象；<br>②用Iterator对象迭代集合内部数据。</p>
<p>//java.util.Iterable<br>//java.util.Iterator</p>
<pre><code>- 关键在于，集合类通过调用iterator()方法，返回一个Iterator对象，这个对象必须自己知道如何遍历该集合。
- 个简单的Iterator示例如下，它总是以倒序遍历集合：</code></pre><p>import java.util.*;</p>
<p>public class Main {<br>    public static void main(String[] args) {<br>        ReverseList<String> rlist = new ReverseList&lt;&gt;();<br>        rlist.add(“Apple”);<br>        rlist.add(“Orange”);<br>        rlist.add(“Pear”);<br>        for (String s : rlist) {<br>            System.out.println(s);<br>        }<br>    }<br>}</p>
<pre><code>    - class ReverseList&lt;T&gt; implements Iterable&lt;T&gt; {//实现Iterable接口用来返回一个构造器实例

private List&lt;T&gt; list = new ArrayList&lt;&gt;();//内部使用ArrayList存储

public void add(T t) {//添加元素
    list.add(t);
}

@Override
public Iterator&lt;T&gt; iterator() {
    return new ReverseIterator(list.size());
}//覆写iterator方法返回一个ReverseIterator实例

class ReverseIterator implements Iterator&lt;T&gt; {//该类的构造器内部类实现Iterator接口
    int index;//存储集合长度

    ReverseIterator(int index) {//设置index
        this.index = index;
    }

    @Override
    public boolean hasNext() {//如果index&gt;0返回真
        return index &gt; 0;
    }

    @Override
    public T next() {//根据index确定元素位置从而得到元素
        index--;
        return ReverseList.this.list.get(index);//注意这里的调用用法，涉及内部类知识，通过ReverseList.this返回外部类的this引用
    }
}</code></pre><p>}</p>
<pre><code>- 虽然ReverseList和ReverseIterator的实现类稍微比较复杂，但是，注意到这是底层集合库，只需编写一次。而调用方则完全按for each循环编写代码，根本不需要知道集合内部的存储逻辑和遍历逻辑。</code></pre><p>在编写Iterator的时候，我们通常可以用一个内部类来实现Iterator接口，这个内部类可以直接访问对应的外部类的所有字段和方法。例如，上述代码中，内部类ReverseIterator可以用ReverseList.this获得当前外部类的this引用，然后，通过这个this引用就可以访问ReverseList的所有字段和方法。</p>
<h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><ul>
<li><p>Collections是JDK提供的工具类，同样位于java.util包中。它提供了一系列静态方法，能更方便地操作各种集合。</p>
</li>
<li><p>不可变集合</p>
<ul>
<li><p>创建不可变的空集合</p>
<ul>
<li>⚐  创建空List：List<T> emptyList()<br>⚐  创建空Map：Map&lt;K, V&gt; emptyMap()<br>⚐  创建空Set：Set<T> emptySet()</li>
<li>使用各个集合接口提供的of(T…)方法创建空集合。</li>
</ul>
</li>
<li><p>创建不可变的单元素集合</p>
<ul>
<li>⚑  创建一个元素的List：List<T> singletonList(T o)<br>⚑  创建一个元素的Map：Map&lt;K, V&gt; singletonMap(K key, V value)<br>⚑  创建一个元素的Set：Set<T> singleton(T o)</li>
<li>使用各个集合接口提供的of(T…)方法创建单元素集合。</li>
</ul>
</li>
<li><p>将可变集合封装为不可变集合</p>
<ul>
<li><p>☞  封装成不可变List：List<T> unmodifiableList(List&lt;? extends T&gt; list)<br>☞  封装成不可变Set：Set<T> unmodifiableSet(Set&lt;? extends T&gt; set)<br>☞  封装成不可变Map：Map&lt;K, V&gt; unmodifiableMap(Map&lt;? extends K, ? extends V&gt; m)</p>
<ul>
<li>这种封装实际上是通过创建一个代理对象，拦截掉所有修改方法实现的。继续对原始的可变List进行增删是可以的，并且，会直接影响到封装后的“不可变”List，相当于是同一个引用。</li>
<li>封装成不可变的对象之后，应该将原对象赋值为null，即扔掉</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>所以，使用List.of(T…)更方便，因为它既可以创建空集合，也可以创建单元素集合，还可以创建任意个元素的集合</p>
</li>
<li><p>修改集合方法</p>
<ul>
<li>Collections.sort(l可变集合)：对集合进行排序</li>
<li>Collections.shuffle(可变集合)：将集合洗牌打乱</li>
</ul>
</li>
</ul>
<h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul>
<li><p>在集合类中，List是最基础的一种集合：它是一种有序列表。</p>
</li>
<li><p>List有ArrayList(顺序表)和LinkedList(链表):</p>
<ul>
<li><ul>
<li><p>LinkedList即实现了List接口，又实现了Queue接口，但是，在使用的时候，如果我们把它当作List，就获取List的引用，如果我们把它当作Queue，就获取Queue的引用，还是Deque。</p>
<ul>
<li>// 这是一个List:<br>List<String> list = new LinkedList&lt;&gt;();<br>// 这是一个Queue:<br>Queue<String> queue = new LinkedList&lt;&gt;();</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>List常用方法</p>
<ul>
<li><p>在末尾添加一个元素：boolean add(E e)</p>
</li>
<li><p>在指定索引添加一个元素：boolean add(int index, E e)</p>
</li>
<li><p>删除指定索引的元素：int remove(int index)</p>
</li>
<li><p>删除某个元素：int remove(Object e)</p>
</li>
<li><p>获取指定索引的元素：E get(int index)</p>
</li>
<li><p>获取链表大小（包含元素的个数）：int size()</p>
</li>
<li><p>判断List是否包含某个指定元素：boolean contains(Object o)</p>
<ul>
<li><p>该方法内部需要用到equals来判断是否等于某个元素，所以如果是自定义类的话也需要自定义equals的条件。</p>
</li>
<li><p>编写equals(  )方法</p>
<ul>
<li>以Person类为例：</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>public class Person {<br>    public String name;<br>    public int age;<br>}</p>
<pre><code>- 首先，我们要定义“相等”的逻辑含义。对于Person类，如果name相等，并且age相等，我们就认为两个Person实例相等。</code></pre><p>因此，编写equals()方法如下：</p>
<p>public boolean equals(Object o) {<br>    if (o instanceof Person) {                                          //先看传入的实例是否是这个实例的子类或者同类<br>        Person p = (Person) o;                                           //强转一下好使用<br>        boolean nameEquals = false;                            //整个标志符<br>        if (this.name == null &amp;&amp; p.name == null) {   //两个都是空的情况，使标识符为真，表示相等<br>            nameEquals = true;<br>        }<br>        if (this.name != null) {<br>            nameEquals = this.name.equals(p.name);//对于引用字段比较，我们使用equals()，然后赋值给标志符<br>        }<br>        return nameEquals &amp;&amp; this.age == p.age;//对于基本类型字段的比较，我们使用==。<br>    }<br>    return false;<br>}</p>
<pre><code>- 如果Person有好几个引用类型的字段，上面的写法就太复杂了。要简化引用类型的比较，我们使用Objects.equals()静态方法：</code></pre><p>public boolean equals(Object o) {<br>    if (o instanceof Person) {<br>        Person p = (Person) o;<br>        return Objects.equals(this.name, p.name) &amp;&amp; this.age == p.age;//注意这里是java.util.Objects类，不是Object<br>    }<br>    return false;<br>}</p>
<pre><code>- 总结一下equals()方法的正确编写方法：</code></pre><p>①先确定实例“相等”的逻辑，即哪些字段相等，就认为实例相等；<br>②用instanceof判断传入的待比较的Object是不是当前类型，如果是，继续比较，否则，返回false；<br>③对引用类型用Objects.equals()比较，对基本类型直接用==比较。</p>
<p>使用Objects.equals()比较两个引用类型是否相等的目的是省去了判断null的麻烦。两个引用类型都是null时它们也是相等的。<br>如果不调用List的contains()、indexOf()这些方法，那么放入的元素就不需要实现equals()方法。</p>
<pre><code>- 返回某个元素的索引，如果元素不存在，就返回-1：int indexOf(Object o)

    - List内部并不是通过==判断两个元素是否相等，而是使用equals()方法判断两个元素是否相等，即只比较值，不比较对象，想要比较对象需要覆写方法
    -    List&lt;String&gt; list = List.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;);</code></pre><p>   System.out.println(list.contains(new String(“C”))); // true<br>   System.out.println(list.indexOf(new String(“C”))); // 2 </p>
<pre><code>- 根据给定元素快速创建List：static &lt;E&gt; List&lt;E&gt; of( 元素 ) 

    - 除了使用ArrayList和LinkedList，我们还可以通过List接口提供的of()方法，根据给定元素快速创建List：</code></pre><p>List<Integer> list = List.of(1, 2, 5);<br>☛ List允许添加null，如：list.add(null);<br>但是List.of()方法不接受null值，如果传入null，会抛出NullPointerException异常。<br>        - List.of() 创建的ArrayList 实例是不可变的！</p>
<ul>
<li><p>使用迭代器Iterator来访问List。</p>
<ul>
<li><p>Iterator本身也是一个对象，但它是由List的实例调用iterator()方法的时候创建的。</p>
<ul>
<li>Iterator对象有两个方法：</li>
<li>boolean hasNext( )判断是否有下一个元素</li>
<li>E next( )返回下一个元素。</li>
</ul>
</li>
<li><p>使用Iterator遍历List代码如下：<br>import java.util.Iterator;//需要加一下<br>import java.util.List;<br>public class Main {<br>public static void main(String[] args) {<br>  List<String> list = List.of(“apple”, “pear”, “banana”);<br>  //注意创建迭代器的时候需要指定泛型类型<br>  for (Iterator<String> it = list.iterator(); it.hasNext(); ) {</p>
<pre><code>String s = it.next();
System.out.println(s);</code></pre><p>  }<br>}<br>}</p>
</li>
</ul>
</li>
</ul>
<pre><code>- Java的for each循环本身就可以帮我们使用Iterator遍历：</code></pre><p>甚至不用显式创建构造器</p>
<p>List<String> list = List.of(“apple”, “pear”, “banana”);<br>        for (String s : list) {<br>            System.out.println(s);</p>
<pre><code>- 实际上，只要实现了Iterable接口的集合类都可以直接用for each循环来遍历，Java编译器本身并不知道如何遍历集合对象，但它会自动把for each循环变成Iterator的调用，原因就在于Iterable接口定义了一个Iterator&lt;E&gt; iterator()方法，强迫集合类必须返回一个Iterator实例。</code></pre><ul>
<li><p>List和Array转换</p>
<ul>
<li>第一种是调用toArray( )方法直接返回一个Object[]数组：</li>
</ul>
</li>
</ul>
<p>Object[] array = list.toArray();//list是一个List实例</p>
<pre><code>    - 因为List是有类型的，这种转换方式会丢失类型信息，所以不常使用

- 第二种方式是给toArray(T[])传入一个类型相同的Array，List内部自动把元素复制到传入的Array中：</code></pre><p>Integer[] array = list.toArray(new Integer[3]);//传入Integer类型数组，List元素自动传入该数组<br>//这里还可以传入Number类型的数组，返回也会是Number类型，但不能传入String类型之类的</p>
<pre><code>    - 如果传入的数组不够大，那么List内部会创建一个新的刚好够大的数组，填充后返回；如果传入的数组比List元素还要多，那么填充完元素后，剩下的数组元素一律填充null。
    - Integer[] array = list.toArray(new Integer[list.size()]);//这种方法保证传入刚好的大小

- 最后一种更简洁的写法是通过List接口定义的T[] toArray(IntFunction&lt;T[]&gt; generator)方法：</code></pre><p>Integer[] array = list.toArray(Integer[]::new);<br>    - Array转换为List</p>
<pre><code>- 通过List.of(T...)方法：</code></pre><p>Integer[] array = { 1, 2, 3 };<br>List<Integer> list = List.of(array);</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul>
<li><p>Map这种键值（key-value）映射表的数据结构，作用就是能高效通过key快速查找value（元素）。</p>
</li>
<li><p>创建Map</p>
<ul>
<li>Map&lt;String,Student&gt; map = new HashMap&lt;&gt;(  );<br>//查询“键”为String类型，返回“值”为Student类型</li>
</ul>
</li>
</ul>
<p>Map&lt;String,Integer&gt; map=new HashMap&lt;&gt;(  );<br>//直接返回Integer类型“值”</p>
<ul>
<li><p>Map常用方法</p>
<ul>
<li><p>V put(K key, V value)  把key和value做了映射并放入Map。</p>
<ul>
<li>如果放入的key已经存在，put(  )方法会返回被替换的旧的value，否则，返回null。</li>
</ul>
</li>
<li><p>V get(K key)  通过key获取到对应的value。如果key不存在，则返回null。</p>
</li>
<li><p>boolean containsKey(K key)  查询一个key是否存在</p>
</li>
<li><p>keySet(  )返回的Set集合它，包含不重复的key的集合</p>
</li>
<li><p>entrySet(  )返回包含每一个key-value映射的集合</p>
</li>
</ul>
</li>
<li><p>遍历Map</p>
<ul>
<li>public class Main {<br>public static void main(String[] args) {<br>  Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();<br>  map.put(“apple”, 123);<br>  map.put(“pear”, 456);<br>  map.put(“banana”, 789);<br>  for (String key : map.keySet()) {//使用keySet(  )方法<pre><code>Integer value = map.get(key);
System.out.println(key + &quot; = &quot; + value);</code></pre>  }<br>}<br>}</li>
</ul>
</li>
</ul>
<pre><code>    - public class Main {
public static void main(String[] args) {
    Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
    map.put(&quot;apple&quot;, 123);
    map.put(&quot;pear&quot;, 456);
    map.put(&quot;banana&quot;, 789);
    for (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) {
    //使用entrySet(  )方法，Entry是Map里面声明的接口，所以用 . 来使用
    //这里的话就是声明一个Entry对象entry
        String key = entry.getKey();
        Integer value = entry.getValue();
        System.out.println(key + &quot; = &quot; + value);
    }
}</code></pre><p>}</p>
<ul>
<li><p>Map和List不同的是，Map存储的是key-value的映射关系，并且，它不保证顺序。在遍历的时候，遍历的顺序既不一定是put()时放入的key的顺序，也不一定是key的排序顺序。</p>
</li>
<li><p>HashMap</p>
<ul>
<li><p>HashMap之所以能根据key直接拿到value，原因是它内部通过空间换时间的方法，用一个大数组存储所有value，并根据key直接计算出value应该存储在哪个索引。</p>
</li>
<li><p>hashCode(  )通过key计算索引，它返回一个int整数。</p>
<ul>
<li><p>HashMap正是通过这个方法直接定位key对应的value的索引，继而直接返回value。</p>
</li>
<li><p>不同的对象，如果返回相同的hashCode()，会造成Map内部存储冲突，使存取的效率下降。</p>
<ul>
<li>假设”a”和”b”这两个key最终计算出的索引都是5，那么，在HashMap的数组中，实际存储的不是一个Person实例，而是一个List，它包含两个Entry，一个是”a”的映射，一个是”b”的映射</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>在查找的时候，例如：<br>Person p = map.get(“a”);<br>HashMap内部通过”a”找到的实际上是List&lt;Entry&lt;String, Person&gt;&gt;，它还需要遍历这个List，并找到一个Entry，它的key字段是”a”，才能返回对应的Person实例。<br>            - 我们把不同的key具有相同的hashCode()的情况称之为哈希冲突。在冲突的时候，一种最简单的解决办法是用List存储hashCode()相同的key-value。显然，如果冲突的概率越大，这个List就越长，Map的get()方法效率就越低，这就是为什么要尽量满足条件二：</p>
<p> ☞  如果两个对象不相等，则两个对象的hashCode()尽量不要相等。</p>
<p>hashCode()方法编写得越好，HashMap工作的效率就越高。</p>
<pre><code>- //以Person类为例编写hashCode(  )</code></pre><p>public class Person {<br>    String firstName;<br>    String lastName;<br>    int age;</p>
<pre><code>@Override
int hashCode() {
    int h = 0;
    h = 31 * h + firstName.hashCode();
    h = 31 * h + lastName.hashCode();
    h = 31 * h + age;
    return h;
}//反复使用31*h，这样做的目的是为了尽量把不同的 
    Person实例的hashCode()均匀分布到整个int范围。</code></pre><p>}</p>
<pre><code>- 和实现equals()方法遇到的问题类似，如果firstName或lastName为null，上述代码工作起来就会抛NullPointerException。为了解决这个问题，我们在计算hashCode()的时候，经常借助Objects.hash()来计算：</code></pre><p>int hashCode() {<br>    return Objects.hash(firstName, lastName, age);<br>}//直接使用这个就可以了，前面的只是为了了解hashCode的大概意义<br>            - 编写equals()和hashCode()遵循的原则是：</p>
<p>equals()用到的用于比较的每一个字段，都必须在hashCode()中用于计算；equals()中没有使用到的字段，绝不可放在hashCode()中计算。–这个对象的关键数据项？</p>
<p>另外注意，对于放入HashMap的value对象，没有任何要求。</p>
<pre><code>- HashMap初始化时默认的数组大小只有16，而hashCode()返回的int范围高达±21亿，但可以通过：</code></pre><p>int index = key.hashCode() &amp; 0xf; // 0xf = 15把索引确定在0～15，即永远不会超出数组范围<br>    - HashMap会在内部自动扩容，每次扩容一倍，扩容会导致重新分布已有的key-value，所以，频繁扩容对HashMap的性能影响很大。但可以创建HashMap时就指定容量，防止重新分配key-value。当然前提是有需求。</p>
<ul>
<li><p>EnumMap</p>
<ul>
<li><p>如果作为key的对象是enum类型，可以使用Java集合库提供的一种EnumMap，它在内部以一个非常紧凑的数组存储value，并且根据enum类型的key直接定位到内部数组的索引，并不需要计算hashCode()（ps：大概因为enum类型的key是有序的），不但效率最高，而且没有额外的空间浪费。</p>
</li>
<li><p>使用EnumMap的时候，根据面向抽象编程的原则，应持有Map接口。</p>
<ul>
<li>如：   Map&lt;DayOfWeek, String&gt; map = new EnumMap&lt;&gt;(DayOfWeek.class);</li>
</ul>
</li>
</ul>
</li>
<li><p>TreeMap</p>
<ul>
<li>SortedMap，它在内部会对Key进行排序。<br>所以SortedMap保证遍历时以Key的顺序来进行排序。</li>
</ul>
</li>
</ul>
<p>☆  注意到SortedMap是接口，它的实现类是TreeMap。</p>
<pre><code>- 使用TreeMap时，放入的Key必须实现Comparable接口，否则无法对key进行排序
- //如果作为Key的class没有实现Comparable接口，那么，必须在创建TreeMap时同时指定一个自定义排序算法：</code></pre><p>public class Main {<br>    public static void main(String[] args) {<br>        Map&lt;Student, Integer&gt; map = new TreeMap&lt;&gt;(new Comparator<Student>() {<br>          public int compare(Student p1, Student p2) {//用这个算法得到对p1和p2的排序规则，即返回的数字<br>                   if (p1.score == p2.score) {              //也可以将函数体换成return Integer.compare(p1.score,p2.score);<br>                           return 0;<br>                   }<br>                   return p1.score &gt; p2.score ? 1: -1;<br>                   }<br>        });<br>        map.put(new Student(“Tom”, 77), 1);   //使用Student对象做key<br>        map.put(new Student(“Bob”, 66), 2);<br>        map.put(new Student(“Lily”, 99), 3);<br>        for (Student key : map.keySet()) {<br>            System.out.println(key);<br>        }         //{Lily: score=99}{Tom: score=77}{Bob: score=66}<br>        System.out.println(map.get(new Student(“Bob”, 66))); // 2<br>    }//注意：这里查找key时只以socre为线索，与name无关，也就是说将Bob换成chenli也是可以查到的<br>}//因为该compare算法只对score作比较，没有管name</p>
<ul>
<li>应改为:</li>
</ul>
<p>public int compare(Student p1.Student p2) {<br>        if (p1.score == p2.score) {<br>            return p1.name.compareTo(p2.name);<br>        }<br>        return p1.score &gt; p2.score ? 1 : -1;<br>    }</p>
<p>//这样做相当于增加了第二比较关键字name，如果需要加第三个同理。</p>
<ul>
<li><p>使用Properties</p>
<ul>
<li>Java集合库提供了一个Properties来表示一组“配置”。由于历史遗留原因，Properties内部本质上是一个Hashtable，但我们只需要用到Properties自身关于读写配置的接口。</li>
<li>配置文件的特点是，它的Key-Value一般是String-String类型的，因此我们可以用Map&lt;String, String&gt;来表示它。</li>
</ul>
</li>
</ul>
<p>Java默认配置文件以.properties为扩展名，每行以key=value表示，以#课开头的是注释。</p>
<pre><code>- 配置文件例如：</code></pre><h1 id="setting-properties"><a href="#setting-properties" class="headerlink" title="setting.properties"></a>setting.properties</h1><p>//key=value<br>last_open_file=/data/hello.txt<br>auto_save_interval=60<br>        - 可以从文件系统读取这个.properties文件：</p>
<p>String f = “setting.properties”;//f为文件名<br>Properties props = new Properties();//创建实例<br>props.load(new java.io.FileInputStream(f));//读取文件</p>
<p>String filepath = props.getProperty(“last_open_file”);//获取配置<br>String interval = props.getProperty(“auto_save_interval”, “120”);</p>
<pre><code>- 可见，用Properties读取配置文件，一共有三步：</code></pre><p>①创建Properties实例；<br>②调用load(  )读取文件；<br>③调用getProperty(  )获取配置。<br>            - ②：load(InputStream)方法接收一个InputStream实例，表示一个字节流，它不一定是文件流。<br>            - ③：调用getProperty()获取配置时，如果key不存在，将返回null。我们还可以提供一个默认值，这样，当key不存在的时候，就返回默认值。</p>
<pre><code>- Properties设计的目的是存储String类型的key－value，但Properties实际上是从Hashtable派生的，它的设计实际上是有问题的，但是为了保持兼容性，现在已经没法修改了。除了getProperty()和setProperty()方法外，还有从Hashtable继承下来的get()和put()方法，这些方法的参数签名是Object，我们在使用Properties的时候，不要去调用这些从Hashtable继承下来的方法。
- 写入配置文件

    - 如果通过setProperty()修改了Properties实例，可以把配置写入文件，以便下次启动时获得最新配置。写入配置文件使用store()方法：</code></pre><p>Properties props = new Properties();<br>props.setProperty(“url”, “<a href="http://www.liaoxuefeng.com&quot;" target="_blank" rel="noopener">http://www.liaoxuefeng.com&quot;</a>);<br>props.setProperty(“language”, “Java”);<br>props.store(new FileOutputStream(“C:\conf\setting.properties”), “这是写入的properties注释”);</p>
<pre><code>- 编码

    - 由于load(InputStream)默认总是以ASCII编码读取字节流，所以会导致中文读到乱码。我们需要用另一个重载方法load(Reader)读取：</code></pre><p>Properties props = new Properties();<br>props.load(new FileReader(“settings.properties”, StandardCharsets.UTF_8));<br>        - InputStream和Reader的区别是一个是字节流，一个是字符流。字符流在内存中已经以char类型表示了，不涉及编码问题。</p>
<pre><code>- 可以从文件系统、classpath或其他任何地方读取.properties文件。</code></pre><ul>
<li><p>Set</p>
<ul>
<li><p>如果我们只需要存储不重复的key，并不需要存储映射的value，那么就可以使用Set。</p>
</li>
<li><p>创建Set</p>
<ul>
<li>Set<String> set = new HashSet&lt;&gt;();//存储String类型的key</li>
</ul>
</li>
<li><p>Set用于存储不重复的元素集合，它主要提供方法：</p>
<ul>
<li>将元素添加进Set<E>：boolean add(E e)</li>
<li>将元素从Set<E>删除：boolean remove(Object e)</li>
<li>判断是否包含元素：boolean contains(Object e)</li>
</ul>
</li>
<li><p>我们经常用Set用于去除重复元素。</p>
</li>
</ul>
</li>
</ul>
<p>因为放入Set的元素和Map的key类似，都要正确实现equals()和hashCode()方法，否则该元素无法正确地放入Set。<br>    - Set接口并不保证有序，而SortedSet接口则保证元素是有序的：</p>
<p>♢  HashSet是无序的，因为它实现了Set接口，并没有实现SortedSet接口；<br>♢  TreeSet是有序的，因为它实现了SortedSet接口。</p>
<pre><code>- 
- 使用TreeSet和使用TreeMap的要求一样，添加的元素必须正确实现Comparable接口，如果没有实现Comparable接口，那么创建TreeSet时必须传入一个Comparator对象。</code></pre><h3 id="Queue-队列"><a href="#Queue-队列" class="headerlink" title="Queue(队列)"></a>Queue(队列)</h3><ul>
<li>Queue实际上是实现了一个先进先出（FIFO：First In First Out）的有序表。它和List的区别在于，List可以在任意位置添加和删除元素，而Queue只有两个操作：</li>
</ul>
<p>①把元素添加到队列末尾<br>②从队列头部取出元素。</p>
<ul>
<li><p>创建一个队列</p>
<ul>
<li>Queue<String> q = new LinkedList&lt;&gt;();</li>
</ul>
</li>
<li><p>int size()：获取队列长度；</p>
</li>
<li><p>boolean add(E)/boolean offer(E)：添加元素到队尾；</p>
</li>
<li><p>E remove()/E poll()：获取队首元素并从队列中删除；</p>
<ul>
<li>注意：不要把null添加到队列中，否则poll()方法返回null时，很难确定是取到了null元素还是队列为空。</li>
</ul>
</li>
<li><p>E element()/E peek()：获取队首元素但并不从队列中删除。</p>
</li>
</ul>
<h3 id="PriorityQueue-优先队列、有序队列"><a href="#PriorityQueue-优先队列、有序队列" class="headerlink" title="PriorityQueue(优先队列、有序队列)"></a>PriorityQueue(优先队列、有序队列)</h3><ul>
<li><p>PriorityQueue和Queue的区别在于，它的出队顺序与元素的优先级有关，对PriorityQueue调用remove()或poll()方法，返回的总是优先级最高的元素。</p>
<ul>
<li>而所谓优先级就是给队列元素按照某种规则排序：<br>即为需要加入的元素的类实现Comparable接口或者提供一个Comparator对象</li>
</ul>
</li>
<li><p>创建PriorityQueue</p>
<ul>
<li>Queue<String> q = new PriorityQueue&lt;&gt;();</li>
</ul>
</li>
</ul>
<h3 id="Deque-双端队列"><a href="#Deque-双端队列" class="headerlink" title="Deque(双端队列)"></a>Deque(双端队列)</h3><ul>
<li><p>它的功能是：<br>①既可以添加到队尾，也可以添加到队首；<br>②既可以从队首获取，又可以从队尾获取。</p>
<ul>
<li>添加元素到队尾：addLast(E e) / offerLast(E e)</li>
<li>取队尾元素并删除：E removeLast() / E pollLast()</li>
<li>取队尾元素但不删除    ：E getLast() / E peekLast()</li>
<li>添加元素到队首：addFirst(E e) / offerFirst(E e)</li>
<li>取队首元素并删除：E removeFirst() / E pollFirst()</li>
<li>取队首元素但不删除：E getFirst() / E peekFirst()</li>
</ul>
</li>
<li><p>创建Deque</p>
<ul>
<li>Deque<String> deque = new LinkedList&lt;&gt;();</li>
</ul>
</li>
<li><p>Stack(Deque的栈实现)</p>
<ul>
<li>把元素压栈：push(E)；</li>
<li>把栈顶的元素“弹出”：pop(E)；</li>
<li>取栈顶元素但不弹出：peek(E)。</li>
</ul>
</li>
</ul>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><h3 id="IO是指Input-Output，即输入和输出。以内存为中心："><a href="#IO是指Input-Output，即输入和输出。以内存为中心：" class="headerlink" title="IO是指Input/Output，即输入和输出。以内存为中心："></a>IO是指Input/Output，即输入和输出。以内存为中心：</h3><p>Input指从外部读入数据到内存，例如，把文件从磁盘读取到内存，从网络读取数据到内存等等。</p>
<p>Output指把数据从内存输出到外部，例如，把数据从内存写入到文件，把数据从内存输出到网络等等。</p>
<p>IO流是一种顺序读写数据的模式，它的特点是单向流动。数据类似自来水一样在水管中流动，所以我们把它称为IO流。</p>
<ul>
<li>代码是在内存中运行的，数据也必须读到内存，最终的表示方式无非是byte数组，字符串等，都必须存放在内存里。</li>
<li>因为内存有“易失性”的特点，所以必须把处理后的数据以某种方式输出，例如，写入到文件。Output实际上就是把Java表示的数据格式，例如，byte[]，String等输出到某个地方。</li>
</ul>
<h3 id="InputStream-OutputStream"><a href="#InputStream-OutputStream" class="headerlink" title="InputStream / OutputStream"></a>InputStream / OutputStream</h3><ul>
<li><p>InputStream/OuputStream是Java标准库提供的最基本的输入输出流。</p>
<ul>
<li>使用InputStream，读入的数据和原始二进制数据一模一样，是byte[]数组，但是我们可以自己把二进制byte[]数组按照某种编码转换为字符串。</li>
</ul>
</li>
<li><p>IO流以byte（字节）为最小单位，因此也称为字节流。</p>
</li>
<li><p>InputStream和OutputStream都是通过close(  )方法来关闭流。</p>
<ul>
<li>应用程序在运行的过程中，如果打开了一个文件进行读写，完成后要及时地关闭，以便让操作系统把资源释放掉，否则，应用程序占用的资源会越来越多，不但白白占用内存，还会影响其他应用程序的运行。</li>
<li>使用try(resource = …)来保证无论是否发生错误都能够 正确的调用close()方法来关闭流，在try(resource) { … }语句中可以同时写出多个资源，用;隔开。</li>
</ul>
</li>
<li><p>阻塞</p>
<ul>
<li>在调用InputStream的read()方法读取数据时，我们说read()方法是阻塞（Blocking）的，和InputStream一样，OutputStream的write()方法也是阻塞的。</li>
<li>int n;<br>n = input.read(); // 必须等待read()方法返回才能执行下一行代码<br>int m = n;<br>执行到第二行代码时，必须等read()方法返回后才能继续。因为读取IO流相比执行普通代码，速度会慢很多，因此，无法确定read()方法调用到底要花费多长时间。</li>
</ul>
</li>
<li><p>InputStream</p>
<ul>
<li><p>它是所有输入流的超类。</p>
</li>
<li><p>这个抽象类定义的一个最重要的方法</p>
<ul>
<li><p>int read(  )读取输入流的下一个字节，并返回字节表示的int值（0~255）。如果已读到末尾，返回-1表示不能继续读取了。</p>
<ul>
<li>方法签名为：public abstract int read() throws IOException;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>文件不存在导致无法读取，没有写权限导致写入失败，等等，这些底层错误由Java虚拟机自动封装成IOException异常并抛出。因此，所有与IO操作相关的代码都必须正确处理IOException。</p>
<pre><code>- InputStream实现类

    - FileInputStream(数据来源于文件)

        - FileInputStream就是从文件流中读取数据。从FileInputStream的所有字节：</code></pre><p>public void readFile() throws IOException {<br>    // 创建一个FileInputStream对象:<br>    InputStream input = new FileInputStream(“src/readme.txt”);<br>    for (;;) {<br>        int n = input.read(); // 反复调用read()方法，直到返回-1<br>        if (n == -1) {<br>            break;<br>        }<br>        System.out.println(n); // 打印byte的值<br>    }<br>    input.close(); // 关闭流，但如果读取发生错误将会无法关闭流导致资源占用<br>}//这里如果input为空的话可能会报错</p>
<pre><code>- 需要用try ... finally来保证InputStream在无论是否发生IO错误的时候都能够正确地关闭：</code></pre><p>public void readFile() throws IOException {<br>    InputStream input = null;<br>    try {<br>        input = new FileInputStream(“src/readme.txt”);<br>        int n;<br>        while ((n = input.read()) != -1) { // 利用while同时读取并判断<br>            System.out.println(n);<br>        }<br>    } finally {<br>        if (input != null) { input.close(); }//最好这样写，保证input不为空再关闭<br>    }<br>}</p>
<pre><code>- 更好的使用try(resource)让编译器自动为我们关闭资源。推荐的写法如下：</code></pre><p>public void readFile() throws IOException {<br>    try (InputStream input = new FileInputStream(“src/readme.txt”)) {<br>        int n;<br>        while ((n = input.read()) != -1) {<br>            System.out.println(n);<br>        }<br>    } // 编译器在此自动为我们写入finally并调用close()<br>}</p>
<pre><code>                - 如果try(resource = ...)中的对象实现了java.lang.AutoCloseable接口就自动加上finally语句并调用close()方法。

- ByteArrayInputStream(数据来源于字节数组)

    - ByteArrayInputStream可以用byte[]数组在内存中模拟一个InputStream

        -  byte[] data = { 72, 101, 108, 108, 111, 33 };</code></pre><p> InputStream input = new ByteArrayInputStream(data);<br>                - 使用这种方法不需要一个实际文件也可以使用InputStream读入，并查看。方便一些，一般用于测试一些方法的功能。</p>
<pre><code>- 缓冲

    - 在读取流的时候，一次读取一个字节并不是最高效的方法。很多流支持一次性读取多个字节到缓冲区，对于文件和网络流来说，利用缓冲区一次性读取多个字节效率往往要高很多。
    - 从FileInputStream读取一个字节时，操作系统往往会一次性读取若干字节到缓冲区，并维护一个指针指向未读的缓冲区。然后，每次我们调用int read()读取下一个字节时，可以直接返回缓冲区的下一个字节，避免每次读一个字节都导致IO操作。当缓冲区全部读完后继续调用read()，则会触发操作系统的下一次读取并再次填满缓冲区。
    - InputStream提供了两个重载方法来支持读取多个字节

        - int read(byte[] b)：读取若干字节并填充到byte[]数组，返回读取的字节数

            - 利用缓冲区一次读取多个字节的代码如下：</code></pre><p>public void readFile() throws IOException {<br>    try (InputStream input = new FileInputStream(“src/readme.txt”)) {<br>        // 定义1000个字节大小的缓冲区:<br>        byte[] buffer = new byte[1000];<br>        int n;<br>        while ((n = input.read(buffer)) != -1) { // 读取到缓冲区，每次都会读取1000个字节<br>            System.out.println(“read “ + n + “ bytes.”);<br>        }<br>    }<br>}</p>
<pre><code>        - int read(byte[] b, int off, int len)：指定byte[]数组的偏移量和最大填充数
        - byte[]数组作为缓冲区，read()方法会尽可能多地读取字节到缓冲区， 但不会超过缓冲区的大小。read()方法的返回值不再是字节的int值，而是返回实际读取了多少个字节。如果返回-1，表示没有更多的数据了。

- FilterInputStream

    - 通过一个“基础”组件再叠加各种“附加”功能组件的模式，称之为Filter模式（或者装饰器模式：Decorator）。
    - JDK将InputStream分为两大类：

        - 一类是直接提供数据的基础InputStream，例如：</code></pre><p>☾   FileInputStream//从文件读取数据，是最终数据源；<br>☾   ByteArrayInputStream//从字节数组读取数据，是最终数据源;<br>☾   ServletInputStream//从HTTP请求读取数据，是最终数据源；<br>…<br>            - 一类是提供额外附加功能的InputStream，例如：</p>
<p>☽   BufferedInputStream//缓冲<br>☽   DigestInputStream//签名<br>☽   CipherInputStream//加密<br>…<br>            - 若直接使用继承，为各种InputStream附加更多的功能，根本无法控制代码的复杂度，很快就会失控。</p>
<pre><code>- 通过少量的类来实现各种功能的组合：

    - //数据来源于文件</code></pre><p>①InputStream file = new FileInputStream(“test.gz”);<br>//用BufferedInputStream包装这个InputStream<br>②InputStream buffered = new BufferedInputStream(file);<br>//再包装一个GZIPInputStream<br>③InputStream gzip = new GZIPInputStream(buffered);<br>//无论我们包装多少次，得到的对象始终是InputStream，我们直接用InputStream来引用它，就可以正常读取<br>//所以可以通过包装来实现多种功能的组合，比继承优雅的多</p>
<pre><code>- 编写FilterInputStream

    - 下面的例子演示了如何编写一个CountInputStream，它的作用是对输入的字节进行计数：</code></pre><p>import java.io.*;<br>public class Main {<br>    public static void main(String[] args) throws IOException {<br>        byte[] data = “hello, world!”.getBytes(“UTF-8”);<br>        //传入一个InputStream，使用CountInputStream对它进行包装实现字节计数功能<br>        try (CountInputStream input = new CountInputStream(new ByteArrayInputStream(data))) {<br>            int n;<br>            while ((n = input.read()) != -1) {<br>                System.out.println((char)n);<br>            }<br>            System.out.println(“Total read “ + input.getBytesRead() + “ bytes”);<br>        }<br>    }<br>}<br>//要想实现包装InputStream就需要继承FilterInputSream类<br>class CountInputStream extends FilterInputStream {<br>    private int count = 0;</p>
<pre><code>CountInputStream(InputStream in) {
    super(in);
}

public int getBytesRead() {
    return this.count;
}

public int read() throws IOException {//需要计数功能就需要重写一下read改变count
    int n = in.read();
    if (n != -1) {
        this.count ++;
    }
    return n;
}

public int read(byte[] b, int off, int len) throws IOException {
    int n = in.read(b, off, len);
    this.count += n;
    return n;
}</code></pre><p>}</p>
<pre><code>        - 注意到在叠加多个FilterInputStream，我们只需要持有最外层的InputStream，并且，当最外层的InputStream关闭时（在try(resource)块的结束处自动关闭），内层的InputStream的close()方法也会被自动调用，并最终调用到最核心的“基础”InputStream，因此不存在资源泄露。

- 操作Zip

    - ZipInputStream是一种FilterInputStream，它可以直接读取zip包的内容

        - ┌───────────────────┐</code></pre><p>│                 InputStream                 │<br>└───────────────────┘<br>          ▲<br>          │<br>┌───────────────────┐<br>│              FilterInputStream          │<br>└───────────────────┘<br>          ▲<br>          │<br>┌───────────────────┐<br>│           InflaterInputStream        │<br>└───────────────────┘<br>          ▲<br>          │<br>┌───────────────────┐<br>│              ZipInputStream             │<br>└───────────────────┘<br>          ▲<br>          │<br>┌───────────────────┐<br>│              JarInputStream              │<br>└───────────────────┘</p>
<pre><code>- 读取zip包
- 写入zip包</code></pre><ul>
<li><p>OutputStream</p>
<ul>
<li><p>它是所有输出流的超类。</p>
</li>
<li><p>这个抽象类定义的一个最重要的方法</p>
<ul>
<li><p>void write(int b)写入一个字节到输出流。要注意的是，虽然传入的是int参数，但只会写入一个字节，即只写入int最低8位表示字节的部分（相当于b &amp; 0xff）。</p>
<ul>
<li>方法签名如下为：public abstract void write(int b) throws IOException;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>同样写入过程也会经常发生IO错误，例如，磁盘已满，无权限写入等等。所以也需要处理IOException错误</p>
<pre><code>    - 每次写入一个字节非常麻烦，更常见的方法是一次性写入若干字节。

        - 重载方法void write(byte[])

- flush(  )将缓冲区的内容真正输出到目的地。

    - 通常情况下，我们不需要调用这个flush()方法，因为缓冲区写满了OutputStream会自动调用它，并且，在调用close()方法关闭OutputStream之前，也会自动调用flush()方法。
    - 想在缓冲区满后才自动调用flush()方法清空缓冲区之前，提前将缓冲区内容输出的话需要手动调用方法。

        - 如在聊天时通过OutputStream的write()方法写入网络流，若缓冲区过大，将会在前期收不到消息，因为都在缓冲区里，而在缓冲区满后自动调用flush()释放缓冲将收到大量信息。对此，需要手动调用flush()方法将每次消息提前从缓冲区输出。

- OutputStream实现类

    - FileOutputStream(向文件写入)

        - OutputStream output = new FileOutputStream(&quot;文件位置&quot;);
        - 用来写入文件流

    - ByteArrayOutputStream(向内存写入)

        - ByteArrayOutputStream可以在内存中模拟一个OutputStream

            - ByteArrayOutputStream实际上是把一个byte[]数组在内存中变成一个OutputStream，不需要一个实际的文件也可以写入并使用ByteArrayOutputStream的对象调用toByteArray(  )查看

        - byte[] toByteArray(  )将内存中用输出流表示的数组转化回数组

            - import java.io.*;</code></pre><p>public class Main {<br>    public static void main(String[] args) throws IOException {<br>        byte[] data;<br>        try (ByteArrayOutputStream output = new ByteArrayOutputStream()) {<br>            output.write(“Hello “.getBytes(“UTF-8”));<br>            output.write(“world!”.getBytes(“UTF-8”));<br>            data = output.toByteArray();//传话为byte[]<br>        }<br>        System.out.println(new String(data, “UTF-8”));//然后输出<br>    }<br>}</p>
<pre><code>- FilterOutputStream

    - PrintStream和PrintWriter

        - PrintStream(输出字节数据)

            - PrintStream是一种FilterOutputStream，它在OutputStream的接口上，额外提供了一些写入各种数据类型的方法

                - 写入int：print(int)</code></pre><p>写入boolean：print(boolean)<br>写入String：print(String)<br>写入Object：print(Object)，实际上相当于print(object.toString())<br>…<br>以及对应的一组println()方法，它会自动加上换行符。<br>                    - 我们经常使用的System.out.println()实际上就是使用PrintStream打印各种数据。其中，System.out是系统默认提供的PrintStream，表示标准输出<br>☏   System.err是系统默认提供的标准错误输出。</p>
<pre><code>    - PrintStream和OutputStream相比，除了添加了一组print()/println()方法，可以打印各种数据类型，比较方便外，它还有一个额外的优点，就是不会抛出IOException，这样我们在编写代码的时候，就不必捕获IOException。

- PrintWrite(输出字符数据)

    - 它的print()/println()方法最终输出的是char数据。</code></pre><h3 id="如果数据源不是文本，就只能使用InputStream，如果数据源是文本，使用Reader更方便一些。Writer和OutputStream是类似的。"><a href="#如果数据源不是文本，就只能使用InputStream，如果数据源是文本，使用Reader更方便一些。Writer和OutputStream是类似的。" class="headerlink" title="如果数据源不是文本，就只能使用InputStream，如果数据源是文本，使用Reader更方便一些。Writer和OutputStream是类似的。"></a>如果数据源不是文本，就只能使用InputStream，如果数据源是文本，使用Reader更方便一些。Writer和OutputStream是类似的。</h3><h3 id="Reader-Writer"><a href="#Reader-Writer" class="headerlink" title="Reader / Writer"></a>Reader / Writer</h3><ul>
<li><p>如果我们需要读写的是字符，并且字符不全是单字节表示的ASCII字符，那么，按照char来读写显然更方便，这种流称为字符流。</p>
<ul>
<li>Reader和Writer表示字符流，字符流传输的最小数据单位是char。</li>
</ul>
</li>
<li><p>Reader和Writer本质上是一个能自动编解码的InputStream和OutputStream。</p>
<ul>
<li>使用Writer字符流写入文件最终内容会是字节表示，同样使用Reader读取字节会得到字符</li>
<li>Reader内部把读入的byte做了解码，转换成了char。</li>
</ul>
</li>
<li><p>Reader</p>
<ul>
<li><p>java.io.Reader是所有字符输入流的超类</p>
</li>
<li><p>读取(最重要的方法)</p>
<ul>
<li><p>int read(  )    读取字符流的下一个字符（末尾返回-1，返回字符表示的int：0~65535）</p>
</li>
<li><p>int read(char[] c)    读到字符数组</p>
<ul>
<li>设置缓冲区</li>
</ul>
</li>
</ul>
</li>
<li><p>Radder的实现类</p>
<ul>
<li><p>FileReader(从文件获取)</p>
<ul>
<li><p>Reader reader = new FileReader(“src/readme.txt”);</p>
<ul>
<li><p>如果我们读取一个纯ASCII编码的文本文件是没有问题的。但如果文件中包含中文，就会出现乱码，因为FileReader默认的编码与系统相关，例如，Windows系统的默认编码可能是GBK，打开一个UTF-8编码的文本文件就会出现乱码。</p>
</li>
<li><p>要避免乱码问题，我们需要在创建FileReader时指定编码</p>
<ul>
<li>Reader reader = new FileReader(“src/readme.txt”, StandardCharsets.UTF_8);</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>CharArrayReader(char[]模拟一个Reader)</p>
<ul>
<li>Reader reader = new CharArrayReader(“Hello”.toCharArray())</li>
</ul>
</li>
<li><p>StringReader(String模拟一个Reader)</p>
<ul>
<li>Reader reader = new StringReader(“Hello”)</li>
</ul>
</li>
<li><p>InputStreamReader(转换器)</p>
<ul>
<li><p>可以将任何InputStream转换为Reader</p>
<ul>
<li>// 持有InputStream:<br>InputStream input = new FileInputStream(“src/readme.txt”);<br>// 指定编码并变换为Reader:<br>Reader reader = new InputStreamReader(input, “UTF-8”);</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Writer</p>
<ul>
<li><p>Writer是所有字符输出流的超类</p>
</li>
<li><p>写入(最重要的方法)</p>
<ul>
<li>void write(int c)  写入字符（0~65535）</li>
<li>void write(char[] c)  写入字符数组</li>
<li>void write(String s)  写入String</li>
</ul>
</li>
<li><p>Writer实现类</p>
<ul>
<li><p>FileWriter(向文件写入)</p>
<ul>
<li><p>Writer writer = new FileWriter(“readme.txt”, StandardCharsets.UTF_8）</p>
<ul>
<li>import java.nio.charset.StandardCharsets;</li>
</ul>
</li>
</ul>
</li>
<li><p>CharArrayWriter(向内存写入）</p>
<ul>
<li><p>CharArrayWriter可以在内存中创建一个Writer，它的作用实际上是构造一个缓冲区，可以写入char，最后得到写入的char[]数组</p>
<ul>
<li>toCharArray(  )得到写入缓冲区的字符数组</li>
</ul>
</li>
</ul>
</li>
<li><p>StringWriter</p>
<ul>
<li>StringWriter也是一个基于内存的Writer，它和CharArrayWriter类似。实际上，StringWriter在内部维护了一个StringBuffer，并对外提供了Writer接口。</li>
</ul>
</li>
<li><p>OutputStreamWriter(转换器)</p>
<ul>
<li>Writer writer = new OutputStreamWriter(new FileOutputStream(“readme.txt”), “UTF-8”)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><ul>
<li><p>java.io提供了同步IO</p>
<ul>
<li>同步IO是指读写IO时代码必须等待数据返回后才继续执行后续代码，它的优点是代码编写简单，缺点是CPU执行效率低。</li>
</ul>
</li>
<li><p>java.nio则是异步IO</p>
<ul>
<li>而异步IO是指，读写IO时仅发出请求，然后立刻执行后续代码，它的优点是CPU执行效率高，缺点是代码编写复杂。</li>
</ul>
</li>
</ul>
<h3 id="File对象"><a href="#File对象" class="headerlink" title="File对象"></a>File对象</h3><ul>
<li><p>Java的标准库java.io提供了File对象来操作文件和目录。</p>
</li>
<li><p>构造File对象时，既可以传入绝对路径，也可以传入相对路径。</p>
<ul>
<li><p>注意Windows平台使用\作为路径分隔符，在Java字符串中需要用\表示一个\。Linux平台使用/作为路径分隔符</p>
<ul>
<li>File对象有一个静态变量用于表示当前平台的系统分隔符：</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>System.out.println(File.separator); // 根据当前平台打印”&quot;或”/“</p>
<pre><code>- File f = new File(&quot;C:\\Windows\\notepad.exe&quot;);//使用绝对路径构造
- // 传入相对路径时，相对路径前面加上当前目录就是绝对路径：假设当前目录是C:\Docs</code></pre><p>File f1 = new File(“sub\javac”); // 绝对路径是C:\Docs\sub\javac<br>File f3 = new File(“.\sub\javac”); // 绝对路径是C:\Docs\sub\javac<br>File f3 = new File(“..\sub\javac”); // 绝对路径是C:\sub\javac</p>
<pre><code>- 可以用.表示当前目录，..表示上级目录。</code></pre><ul>
<li><p>返回FIle对象构造的路径</p>
<ul>
<li><p>getPath(  )，返回构造方法传入的路径</p>
</li>
<li><p>getAbsolutePath(  )，返回绝对路径</p>
</li>
<li><p>getCanonicalPath(  )，它和绝对路径类似，但是返回的是规范路径。</p>
<ul>
<li>绝对路径可以表示成C:\Windows\System32..\notepad.exe，而规范路径就是把.和..转换成标准的绝对路径后的路径：C:\Windows\notepad.exe</li>
</ul>
</li>
</ul>
</li>
<li><p>File对象既可以表示文件，也可以表示目录。</p>
<ul>
<li><p>特别要注意的是，构造一个File对象，即使传入的文件或目录不存在，代码也不会出错，因为构造一个File对象，并不会导致任何磁盘操作。只有当我们调用File对象的某些方法的时候，才真正进行磁盘操作。</p>
</li>
<li><p>查看File对象是否是存在的文件或目录</p>
<ul>
<li>文件：isFile(  )</li>
<li>目录：isDirectory()</li>
</ul>
</li>
</ul>
</li>
<li><p>File对象获取到一个文件时</p>
<ul>
<li>boolean canRead(  )：是否可读；</li>
<li>boolean canWrite(  )：是否可写；</li>
<li>boolean canExecute(  )：是否可执行或能否列出它包含的文件和子目录；</li>
<li>long length(  )：文件字节大小。</li>
</ul>
</li>
<li><p>当File对象表示一个文件时</p>
<ul>
<li><p>createNewFile(  )创建一个新文件</p>
<ul>
<li>如：File f1 = new File(“D:\巨人\holo”);<br>//holo是一个不存在的文件时，才能创建</li>
</ul>
</li>
<li><p>delete(  )删除文件</p>
</li>
</ul>
</li>
<li><p>当File对象表示一个目录时</p>
<ul>
<li><p>String[] list(  )返回目录下文件和子目录</p>
</li>
<li><p>File[] listFiles(  )返回文件和子目录</p>
<ul>
<li>listFiles()提供了一系列重载方法，可以过滤不想要的文件和目录：</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>File[] fs2 = f.listFiles(new FilenameFilter() { // 仅列出.exe文件<br>            public boolean accept(File dir, String name) {<br>                return name.endsWith(“.exe”); // 返回true表示接受该文件<br>            }<br>        });//FilenameFilter是一个接口，即传入一个实现该接口的对象，就可以过滤文件</p>
<pre><code>- boolean mkdir()：创建当前File对象表示的目录；

    - 只能创建一级目录

- boolean mkdirs()：创建当前File对象表示的目录，并在必要时将不存在的父目录也创建出来；

    - 可创建多级目录

- boolean delete()：删除当前File对象表示的目录，当前目录必须为空才能删除成功。</code></pre><ul>
<li><p>程序需要读写一些临时文件时</p>
<ul>
<li>createTempFile(  )创建一个临时文件</li>
<li>deleteOnExit(  )在JVM退出时自动删除该文件。</li>
</ul>
</li>
<li><p>Path</p>
<ul>
<li>Java标准库还提供了一个Path对象，它位于java.nio.file包。Path对象和File对象类似，但操作更加简单</li>
</ul>
</li>
</ul>
<h3 id="读取classpath资源"><a href="#读取classpath资源" class="headerlink" title="读取classpath资源"></a>读取classpath资源</h3><ul>
<li><p>从classpath读取文件就可以避免不同环境下文件路径不一致的问题</p>
<ul>
<li><p>try (InputStream input = getClass().getResourceAsStream(“/default.properties”)) {<br>if (input != null) {//可能返回null，需要检查一下<br>  // TODO:<br>}<br>}//不必关心实际路径，只需要给出文件名。<br>//在classpath中的资源文件，路径总是以／开头我们先获取当前的Class然后调用getResourceAsStream()就可以直接从classpath读取任意的资源文件</p>
<ul>
<li>getResourceAsStream(  )读取任意的资源文件,如果资源文件不存在，它将返回null</li>
</ul>
</li>
</ul>
</li>
<li><p>如果我们把默认的配置放到jar包中，再从外部文件系统读取一个可选的配置文件，就可以做到既有默认的配置文件，又可以让用户自己修改配置：</p>
</li>
</ul>
<p>Properties props = new Properties();<br>props.load(inputStreamFromClassPath(“/default.properties”));<br>props.load(inputStreamFromFile(“./conf.properties”));<br>这样读取配置文件，应用程序启动就更加灵活。</p>
<h3 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h3><ul>
<li>序列化是指把一个Java对象变成二进制内容，本质上就是一个byte[]数组。</li>
</ul>
<p>反序列化就把一个二进制内容（也就是byte[]数组）变回Java对象。</p>
<pre><code>- 一个Java对象要能序列化，必须实现一个特殊的java.io.Serializable接口

    - Serializable接口没有定义任何方法，它是一个空接口。把这样的空接口称为“标记接口”（Marker Interface），实现了标记接口的类仅仅是给自身贴了个“标记”，并没有增加任何方法。

- 反序列化时，由JVM直接构造出Java对象，不调用构造方法，构造方法内部的代码，在反序列化时根本不可能执行。</code></pre><ul>
<li><p>序列化的作用</p>
<ul>
<li>序列化后可以把byte[]保存到文件中，或者把byte[]通过网络传输到远程，这样，就相当于把Java对象存储到文件或者通过网络传输出去了。</li>
</ul>
</li>
<li><p>ObjectOutputStream</p>
<ul>
<li>使用ObjectOutputStream把一个Java对象写入一个字节流：</li>
</ul>
</li>
</ul>
<p>import java.io.*;<br>import java.util.Arrays;<br>public class Main {<br>    public static void main(String[] args) throws IOException {<br>        ByteArrayOutputStream buffer = new ByteArrayOutputStream();<br>        try (ObjectOutputStream output = new ObjectOutputStream(buffer)) {<br>            // 写入int:<br>            output.writeInt(12345);//其他一般的只能写入byte[]<br>            // 写入String:<br>            output.writeUTF(“Hello”);<br>            // 写入Object(只能写入实现了Serializable接口的类对象)<br>            output.writeObject(Double.valueOf(123.456));//Number实现了标记接口<br>        }<br>        //因为写入Object时需要大量的类型信息，所以写入的内容很大。<br>        System.out.println(Arrays.toString(buffer.toByteArray()));<br>    }<br>}</p>
<pre><code>- readObject()可能抛出的异常有：</code></pre><p>☣   ClassNotFoundException：没有找到对应的Class；<br>☣   InvalidClassException：Class不匹配。</p>
<pre><code>- 对于ClassNotFoundException，这种情况常见于一台电脑上的Java程序把一个Java对象，例如，Person对象序列化以后，通过网络传给另一台电脑上的另一个Java程序，但是这台电脑的Java程序并没有定义Person类，所以无法反序列化。</code></pre><p>对于InvalidClassException，这种情况常见于序列化的Person对象定义了一个int类型的age字段，但是反序列化时，Person类定义的age字段被改成了long类型，所以导致class不兼容。</p>
<p>为了避免这种class定义变动导致的不兼容，Java的序列化允许class定义一个特殊的serialVersionUID静态变量，用于标识Java类的序列化“版本”，通常可以由IDE自动生成。如果增加或修改了字段，可以改变serialVersionUID的值，这样就能自动阻止不匹配的class版本：</p>
<p>public class Person implements Serializable {<br>    private static final long serialVersionUID = 2709425275741743919L;<br>}</p>
<ul>
<li><p>ObjectInputStream</p>
<ul>
<li>ObjectInputStream负责从一个字节流读取Java对象：</li>
</ul>
</li>
</ul>
<p>try (ByteArrayInputStream in=new ByteArrayInputStream(buffer.toByteArray());<br>               ObjectInputStream input = new ObjectInputStream(in)) {<br>            int n = input.readInt();<br>            String s = input.readUTF();<br>            Double d = (Double) input.readObject();<br>            System.out.println(n);//12345<br>            System.out.println(s);//Hello<br>            System.out.println(d);//123.456<br>        }</p>
<ul>
<li><p>安全性</p>
<ul>
<li>因为Java的序列化机制可以导致一个实例能直接从byte[]数组创建，而不经过构造方法，因此，它存在一定的安全隐患。一个精心构造的byte[]数组被反序列化后可以执行特定的Java代码，从而导致严重的安全漏洞。</li>
<li>实际上，Java本身提供的基于对象的序列化和反序列化机制既存在安全性问题，也存在兼容性问题。更好的序列化方法是通过JSON这样的通用数据结构来实现，只输出基本类型（包括String）的内容，而不存储任何与代码相关的信息。</li>
</ul>
</li>
</ul>
<h2 id="日期与时间"><a href="#日期与时间" class="headerlink" title="日期与时间"></a>日期与时间</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><p>日期是指某一天，它不是连续变化的，而是应该被看成离散的。</p>
<ul>
<li>如：2019-11-20</li>
</ul>
</li>
<li><p>时间有两种概念</p>
<ul>
<li><p>不带日期的时间</p>
<ul>
<li>例如：12:30:59</li>
</ul>
</li>
<li><p>带日期的时间</p>
<ul>
<li><p>例如：2020-1-1 20:21:59</p>
<ul>
<li>只有带日期的时间能唯一确定某个时刻，不带日期的时间是无法确定一个唯一时刻的。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>本地时间</p>
<ul>
<li>不同的时区，在同一时刻，本地时间是不同的</li>
</ul>
</li>
<li><p>时区</p>
<ul>
<li><p>因为光靠本地时间还无法唯一确定一个准确的时刻，所以我们还需要给本地时间加上一个时区。</p>
</li>
<li><p>全球一共分为24个时区，伦敦所在的时区称为标准时区，其他时区按东／西偏移的小时区分，北京所在的时区是东八区。</p>
</li>
<li><p>时区的不同表示方式</p>
<ul>
<li><p>一种是以GMT或者UTC加时区偏移表示，例如：GMT+08:00或者UTC+08:00表示东八区。</p>
</li>
<li><p>一种是缩写，例如，CST表示China Standard Time，也就是中国标准时间。</p>
<ul>
<li>缩写容易产生混淆，尽量不要使用缩写。</li>
</ul>
</li>
<li><p>一种是以洲／城市表示，例如，Asia/Shanghai，表示上海所在地的时区。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>夏令时</p>
<ul>
<li><p>所谓夏令时，就是夏天开始的时候，把时间往后拨1小时，夏天结束的时候，再把时间往前拨1小时。</p>
</li>
<li><p>涉及到夏令时，相同的时区，如果表示的方式不同，转换出的时间是不同的。</p>
<ul>
<li>时区                                  2019-11-20                            2019-6-20<br>GMT-05:00                                 19:00                                       19:00<br>UTC-05:00                                  19:00                                       19:00<br>America/New_York                  19:00                                      20:00</li>
</ul>
</li>
<li><p>实行夏令时的不同地区，进入和退出夏令时的时间很可能是不同的。同一个地区，根据历史上是否实行过夏令时，标准时间在不同年份换算成当地时间也是不同的。因此，计算夏令时，没有统一的公式，必须按照一组给定的规则来算，并且，该规则要定期更新。</p>
</li>
</ul>
</li>
<li><p>本地化</p>
<ul>
<li><p>在计算机中，通常使用Locale表示一个国家或地区的日期、时间、数字、货币等格式。</p>
<ul>
<li><p>Locale由语言_国家的字母缩写构成</p>
<ul>
<li>例如：<br>zh_CN表示中文+中国<br>en_US表示英文+美国<br>语言使用小写，国家使用大写。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><ul>
<li><p>基本用法</p>
<ul>
<li><p>import java.util.Date;</p>
<p>  // 获取当前时间:<br>  Date date = new Date();<br>  System.out.println(date.getYear() + 1900); // 必须加上1900<br>  System.out.println(date.getMonth() + 1); // 0<del>11，必须加上1<br>  System.out.println(date.getDate()); // 1</del>31，不能加1<br>  System.out.println(date.toString());// 转换为String<br>  System.out.println(date.toGMTString()); // 转换为GMT时区<br>  System.out.println(date.toLocaleString());// 转换为本地时区</p>
</li>
</ul>
</li>
<li><p>SimpleDateFormat</p>
<ul>
<li><p>使用java.text.SimpleDateFormat对Date进行格式化</p>
</li>
<li><p>它用预定义的字符串表示格式化</p>
<ul>
<li><p>yyyy：年<br>MM：月<br>dd: 日<br>HH: 小时<br>mm: 分钟<br>ss: 秒<br>e:周几</p>
<ul>
<li><p>字母越长，输出越长</p>
<ul>
<li><p>以M为例，假设当前月份是9月</p>
<ul>
<li>M：输出9<br>MM：输出09<br>MMM：输出Sep<br>MMMM：输出September</li>
</ul>
</li>
</ul>
</li>
<li><p>在格式化字符串中，如果需要输出固定字符，可以用’xxx’表示。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>自定义格式输出</p>
<ul>
<li>Date date = new Date();<br>var sdf = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”);//传入格式<br>System.out.println(sdf.format(date));//2020-08-01 01:31:03</li>
</ul>
</li>
</ul>
</li>
<li><p>Date对象有几个严重的问题：它不能转换时区，除了toGMTString()可以按GMT+0:00输出外，Date总是以当前计算机系统的默认时区为基础进行输出。此外，我们也很难对日期和时间进行加减，计算两个日期相差多少天，计算某个月第一个星期一的日期等。</p>
</li>
</ul>
<h3 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h3><ul>
<li><p>Calendar可以用于获取并设置年、月、日、时、分、秒，它和Date比，主要多了一个可以做简单的日期和时间运算的功能。</p>
</li>
<li><p>基本用法</p>
<ul>
<li><p>获取时间</p>
<ul>
<li><p>import java.util.Calendar;<br>Calendar c = Calendar.getInstance();//Calendar只有唯一方式获取并获取当前时间<br>int y = c.get(Calendar.YEAR);//年<br>int m = 1 + c.get(Calendar.MONTH);//月，要+1<br>int d = c.get(Calendar.DAY_OF_MONTH);//日<br>int w = c.get(Calendar.DAY_OF_WEEK);//星期<br>int hh = c.get(Calendar.HOUR_OF_DAY);//时<br>int mm = c.get(Calendar.MINUTE);//分<br>int ss = c.get(Calendar.SECOND);//秒<br>int ms = c.get(Calendar.MILLISECOND);//毫秒<br>System.out.println(y + “-“ + m + “-“ + d + “ “ + w + “ “ + hh + “:” + mm + “:” + ss + “.” + ms);<br>//2020-8-1 7 2:19:47.557</p>
<ul>
<li>int get(int field)</li>
</ul>
</li>
</ul>
</li>
<li><p>如果我们想给它设置成特定的一个日期和时间，就必须先清除所有字段</p>
<ul>
<li><p>import java.util.Calendar;<br>import java.text.SimpleDateFormat;</p>
<p>Calendar c = Calendar.getInstance(); // 得到的是当前时间:<br>c.clear();//所以需要清除当前字段<br>c.set(Calendar.YEAR, 2019);// 为其设置2019年<br>c.set(Calendar.MONTH, 8); // 设置9月:注意8表示9月<br>c.set(Calendar.DATE, 2);// 设置2日<br>c.set(Calendar.HOUR_OF_DAY, 21);  // 设置时间<br>c.set(Calendar.MINUTE, 22);<br>c.set(Calendar.SECOND, 23);<br>System.out.println(new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”).format(c.getTime()))<br>//输出：2019-09-02 21:22:23</p>
<ul>
<li>使用getTime(  )方法将Calendar转化为Date方便格式化。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="TimeZone"><a href="#TimeZone" class="headerlink" title="TimeZone"></a>TimeZone</h3><ul>
<li><p>Calendar和Date相比，它提供了时区转换的功能。时区用TimeZone对象表示</p>
<ul>
<li><p>import java.util.TimeZone;</p>
<p>  TimeZone tzDefault = TimeZone.getDefault(); // 当前时区<br>  TimeZone tzGMT9 = TimeZone.getTimeZone(“GMT+09:00”); // GMT+9:00时区<br>  TimeZone tzNY = TimeZone.getTimeZone(“America/New_York”); // 纽约时区<br>  System.out.println(tzDefault.getID()); // Asia/Shanghai<br>  System.out.println(tzGMT9.getID()); // GMT+09:00<br>  System.out.println(tzNY.getID()); // America/New_York</p>
<ul>
<li>时区的唯一标识是以字符串表示的ID，我们获取指定TimeZone对象也是以这个ID为参数获取，GMT+09:00、Asia/Shanghai都是有效的时区ID。</li>
<li>静态方法：TimeZone.getDefault(  )获取当前时区</li>
<li>静态方法：TimeZone.getTimeZone(时区ID)得到任意时区</li>
<li>TimeZone.getAvailableIDs(  )列出所有支持的ID</li>
</ul>
</li>
</ul>
</li>
<li><p>有了时区，可以对指定时间进行转换</p>
<ul>
<li><p>例如，下面的例子演示了如何将北京时间2019-11-20 8:15:00转换为纽约时间<br>import java.text.SimpleDateFormat;<br>import java.util.Calendar;<br>import java.util.TimeZone;</p>
<p>  Calendar c = Calendar.getInstance();// 当前时间<br>  c.clear();// 清除所有:<br>  c.setTimeZone(TimeZone.getTimeZone(“Asia/Shanghai”));// 为Calendar对象设置为北京时区<br>  c.set(2019, 10 /* 11月 */, 20, 8, 15, 0);   // 使用这种方法一次性设置年月日时分秒<br>  var sdf = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”);// 设置显示时间的格式<br>  sdf.setTimeZone(TimeZone.getTimeZone(“America/New_York”));//转为纽约时区<br>  System.out.println(sdf.format(c.getTime()));//使用纽约时区输出<br>  // 2019-11-19 19:15:00</p>
<ul>
<li>可见，利用Calendar进行时区转换的步骤是：</li>
<li>清除所有字段；</li>
<li>设定指定时区；</li>
<li>设定日期和时间；</li>
<li>创建SimpleDateFormat并设定目标时区；</li>
<li>格式化获取的Date对象（注意Date对象无时区信息，时区信息存储在SimpleDateFormat中）。</li>
<li>因此，本质上时区转换只能通过SimpleDateFormat在显示的时候完成。</li>
</ul>
</li>
</ul>
</li>
<li><p>Calendar对日期和时间进行简单的加减</p>
<ul>
<li><p>import java.text.SimpleDateFormat;<br>import java.util.Calendar;<br>import java.util.Date;</p>
<p>  Calendar c = Calendar.getInstance(); // 当前时间:<br>  c.clear(); // 清除所有:<br>  c.set(2019, 10 /* 11月 */, 20, 8, 15, 0);// 设置年月日时分秒:<br>  // 加5天并减去2小时:<br>  c.add(Calendar.DAY_OF_MONTH, 5);<br>  c.add(Calendar.HOUR_OF_DAY, -2);<br>  var sdf = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”);// 显示时间:<br>  Date d = c.getTime();<br>  System.out.println(sdf.format(d));<br>  // 2019-11-25 6:15:00</p>
</li>
</ul>
</li>
</ul>
<h3 id="新-java-time包"><a href="#新-java-time包" class="headerlink" title="(新)java.time包"></a>(新)java.time包</h3><ul>
<li><p>本地日期和时间：LocalDateTime，LocalDate，LocalTime；<br>带时区的日期和时间：ZonedDateTime；<br>时刻：Instant；<br>时区：ZoneId，ZoneOffset；<br>时间间隔：Duration。</p>
</li>
<li><p>新API修正了旧API不合理的常量设计</p>
<ul>
<li>Month的范围用1~12表示1月到12月；</li>
<li>Week的范围用1~7表示周一到周日。</li>
</ul>
</li>
<li><p>新API的类型几乎全部是不变类型（和String类似），可以放心使用不必担心被修改。</p>
</li>
<li><p>LocalDateTime</p>
<ul>
<li><p>表示一个本地日期和时间</p>
</li>
<li><p>LocalDateTime无法与时间戳进行转换，因为LocalDateTime没有时区，无法确定某一时刻。</p>
</li>
<li><p>获取当前时间</p>
<ul>
<li><p>import java.time.LocalDate;<br>import java.time.LocalTime;<br>import java.time.LocalDateTime;</p>
<p>LocalDate d = LocalDate.now(); // 当前日期<br>LocalTime t = LocalTime.now(); // 当前时间<br>LocalDateTime dt = LocalDateTime.now(); // 当前日期和时间<br>System.out.println(d); // 严格按照ISO 8601格式打印<br>System.out.println(t); // 严格按照ISO 8601格式打印<br>System.out.println(dt); // 严格按照ISO 8601格式打印</p>
<ul>
<li><p>本地日期和时间通过now()获取到的总是以当前默认时区返回的</p>
</li>
<li><p>在获取3个类型的时候，由于执行一行代码总会消耗一点时间，因此，3个类型的日期和时间很可能对不上（时间的毫秒数基本上不同）。为了保证获取到同一时刻的日期和时间，可以改写为：</p>
<ul>
<li>LocalDateTime dt = LocalDateTime.now(); // 直接获得当前日期和时间<br>LocalDate d = dt.toLocalDate(); // 然后用上面得到的再转换到当前日期，可以保证时间的相同<br>LocalTime t = dt.toLocalTime(); // 转换到当前时间</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>创建时间日期</p>
<ul>
<li><p>通过指定的日期和时间创建LocalDateTime可以通过of(  )方法：</p>
<ul>
<li>// 指定日期和时间:<br>LocalDate d2 = LocalDate.of(2019, 11, 30); // 2019-11-30, 注意11=11月<br>LocalTime t2 = LocalTime.of(15, 16, 17); // 15:16:17<br>LocalDateTime dt2 = LocalDateTime.of(2019, 11, 30, 15, 16, 17);<br>LocalDateTime dt3 = LocalDateTime.of(d2, t2);</li>
</ul>
</li>
<li><p>需要严格按照ISO 8601的格式，使用parse(  )方法将字符串转换为LocalDateTime就可以传入标准格式</p>
<ul>
<li>LocalDateTime dt = LocalDateTime.parse(“2019-11-19T15:16:17”);<br>LocalDate d = LocalDate.parse(“2019-11-19”);<br>LocalTime t = LocalTime.parse(“15:16:17”);</li>
<li>注意ISO 8601规定的日期和时间分隔符是T。标准格式如下：</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>日期：yyyy-MM-dd<br>时间：HH:mm:ss<br>带毫秒的时间：HH:mm:ss.SSS<br>日期和时间：yyyy-MM-dd’T’HH:mm:ss<br>带毫秒的日期和时间：yyyy-MM-dd’T’HH:mm:ss.SSS</p>
<pre><code>- LocalDateTime提供了对日期和时间进行加减的非常简单的链式调用

    - import java.time.LocalDateTime;  

    LocalDateTime dt = LocalDateTime.of(2019, 10, 26, 20, 30, 59);
    System.out.println(dt);
    LocalDateTime dt2 = dt.plusDays(5).minusHours(3); // 加5天减3小时:
    System.out.println(dt2); // 2019-10-31T17:30:59
    LocalDateTime dt3 = dt2.minusMonths(1); // 减1月:
    System.out.println(dt3); // 2019-09-30T17:30:59

        - 注意到月份加减会自动调整日期，例如从2019-10-31减去1个月得到的结果是2019-09-30，因为9月没有31日。

- 对日期和时间进行调整则使用withXxx()方法，例如：withHour(15)会把10:11:12变为15:11:12

    - 调整年：withYear(  )
    - 调整月：withMonth(  )
    - 调整日：withDayOfMonth(  )
    - 调整时：withHour(  )
    - 调整分：withMinute(  )
    - 调整秒：withSecond(  )
    - 还有一个通用的with()方法允许我们做更复杂的运算。

        - import java.time.*;</code></pre><p>import java.time.temporal.TemporalAdjusters;</p>
<pre><code>   // 本月第一天0:00时刻:
    LocalDateTime firstDay = LocalDate.now().withDayOfMonth(2).atStartOfDay();
    System.out.println(firstDay);//2020-08-01T00:00

    // 本月最后1天:
    LocalDate lastDay = LocalDate.now().with(TemporalAdjusters.lastDayOfMonth());
    System.out.println(lastDay);//2020-08-31

    // 下月第1天:
    LocalDate nextMonthFirstDay = LocalDate.now().with(TemporalAdjusters.firstDayOfNextMonth());
    System.out.println(nextMonthFirstDay);//2020-09-01

    // 本月第1个周一:
    LocalDate firstWeekday = 
    LocalDate.now().with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY));
    System.out.println(firstWeekday);//2020-08-03

            - 对于计算某个月第1个周日这样的问题，新的API可以轻松完成。

- 判断两个LocalDateTime的先后

    -         LocalDateTime now = LocalDateTime.now();
    LocalDateTime target = LocalDateTime.of(2019, 11, 19, 8, 15, 0);
    System.out.println(now.isBefore(target));//false
    System.out.println(LocalDate.now().isBefore(LocalDate.of(2021, 11, 19)));//true
    System.out.println(LocalTime.now().isAfter(LocalTime.parse(&quot;08:15:00&quot;)));//true

        - isBefore(  )  是否在前
        - isAfter(  )  是否在后
        - 对于LocalDate和LocalTime类似</code></pre><ul>
<li><p>java.time.format</p>
<ul>
<li><p>DateTimeFormatter</p>
<ul>
<li><p>可以自定义输出的格式，或将一个非ISO 8601格式的字符串解析成LocalDateTime，可使用新的DateTimeFormatter</p>
</li>
<li><p>创建DateTimeFormatter</p>
<ul>
<li>// 自定义格式化:<br>DateTimeFormatter dtf = DateTimeFormatter.ofPattern(“yyyy/MM/dd HH:mm:ss”);<br>System.out.println(dtf.format(LocalDateTime.now()));//将当前日期时间转化</li>
</ul>
<p>// 用自定义格式解析:<br>LocalDateTime dt2 = LocalDateTime.parse(“2019/11/30 15:16:17”, dtf);<br>System.out.println(dt2);//例如：2019-11-30T15:16:17</p>
<pre><code>- 静态方法  ofPattern(格式) 来设置格式
- 静态方法  ofPattern(格式,Locale)  传入格式化字符串时，同时指定Locale

    -         ZonedDateTime zdt = ZonedDateTime.now();</code></pre><p>var formatter = DateTimeFormatter.ofPattern(“yyyy-MM-dd’T’HH:mm ZZZZ”);<br>System.out.println(formatter.format(zdt));//2020-08-03T11:23 GMT+08:00</p>
<p>var zhFormatter = DateTimeFormatter.ofPattern(“yyyy MMM dd EE HH:mm”, Locale.CHINA);<br>System.out.println(zhFormatter.format(zdt));//2020 8月 03 周一 11:23</p>
<p>var usFormatter = DateTimeFormatter.ofPattern(“E, MMMM/dd/yyyy HH:mm”, Locale.US);<br>System.out.println(usFormatter.format(zdt)); //Mon, August/03/2020 11:23</p>
<pre><code>- 静态方法  paese(日期,格式对象)  来将符合格式化的日期解析为LocalDateTime 对象</code></pre></li>
<li><p>和SimpleDateFormat不同的是，DateTimeFormatter不但是不变对象，它还是线程安全的。</p>
</li>
<li><p>我们可以通过DateTimeFormatter预定义的几个静态变量来引用，实现一些比较简单的格式化</p>
<ul>
<li>例如：<br>var ldt = LocalDateTime.now();<br>System.out.println(DateTimeFormatter.ISO_DATE.format(ldt));//2020-08-03<br>System.out.println(DateTimeFormatter.ISO_DATE_TIME.format(ldt));//2020-08-03T11:43:49.9535651<br>System.out.println(DateTimeFormatter.ISO_TIME.format(ldt));//11:43:49.9535651</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Duration和Period</p>
<ul>
<li><p>Duration表示两个时刻之间的时间间隔。另一个类似的Period表示两个日期之间的天数</p>
</li>
<li><p>基本用法</p>
<ul>
<li><p>import java.time.*;       </p>
<p>LocalDateTime start = LocalDateTime.of(2019, 11, 19, 8, 15, 0);<br>LocalDateTime end = LocalDateTime.of(2020, 1, 9, 19, 25, 30);<br>Duration d = Duration.between(start, end);//时间间隔用Duration对象表示<br>System.out.println(d); // PT1235H10M30S</p>
<p>Period p = LocalDate.of(2019, 11, 19).until(LocalDate.of(2020, 1, 9));//间隔天数用Period对象表示<br>System.out.println(p); // P1M21D，一月21天</p>
<ul>
<li>Duration和Period的表示方法也符合ISO 8601的格式，它以P…T…的形式表示，P…T之间表示日期间隔，T后面表示时间间隔。如果是PT…的格式表示仅有时间间隔。</li>
</ul>
</li>
</ul>
</li>
<li><p>利用ofXxx(  )或者parse(  )方法也可以直接创建Duration和Period</p>
<ul>
<li>Duration d1 = Duration.ofHours(10); // 10 hours<br>Duration d2 = Duration.parse(“P1DT2H3M”); // 1 day, 2 hours, 3 minutes</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Period p1=Period.of(1,2,23);//</p>
<ul>
<li><p>ZonedDateTime</p>
<ul>
<li><p>用来表示一个带时区的时间日期</p>
<ul>
<li>可以简单地把ZonedDateTime理解成LocalDateTime加ZoneId。</li>
</ul>
</li>
<li><p>创建ZonedDateTime对象</p>
<ul>
<li><p>通过now(  )方法返回当前时间</p>
<ul>
<li>ZonedDateTime zbj = ZonedDateTime.now(); // 默认时区<br>ZonedDateTime zny = ZonedDateTime.now(ZoneId.of(“America/New_York”)); // 用指定时区获取当前时间<br>System.out.println(zbj);//2020-08-03T09:55:54.149585700+08:00[GMT+08:00]<br>System.out.println(zny);//2020-08-02T21:55:54.186615400-04:00[America/New_York]，两个时间有细微的间隔</li>
</ul>
</li>
<li><p>另一种方式是通过给一个LocalDateTime附加一个ZoneId(atZone(  )方法)，就可以变成ZonedDateTime</p>
<ul>
<li><p>LocalDateTime ldt = LocalDateTime.of(2019, 9, 15, 15, 16, 17);<br>ZonedDateTime zbj = ldt.atZone(ZoneId.systemDefault());//系统默认时区<br>ZonedDateTime zny = ldt.atZone(ZoneId.of(“America/New_York”));指定时区<br>System.out.println(zbj);//2019-09-15T15:16:17+08:00[GMT+08:00]<br>System.out.println(zny);//2019-09-15T15:16:17-04:00[America/New_York]</p>
<ul>
<li>这里只是在原LocalDateTime添加了时区信息，虽然日期时间相同但时区不同，所以是不同的时刻</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>时区转换</p>
<ul>
<li><p>withZoneSameInstant(  )将当前对象关联时区转换到另一个时区，同时，时间日期也会因为时区的转换而转换</p>
<ul>
<li>ZonedDateTime zbj = ZonedDateTime.now(ZoneId.of(“Asia/Shanghai”));// 以中国时区获取当前时间:<br>ZonedDateTime zny = zbj.withZoneSameInstant(ZoneId.of(“America/New_York”));  // 转换为纽约时间:<br>System.out.println(zbj);//2020-08-03T10:21:03.179574200+08:00[Asia/Shanghai]<br>System.out.println(zny);//2020-08-02T22:21:03.179574200-04:00[America/New_York]</li>
<li>时区转换的时候，由于夏令时的存在，不同的日期转换的结果很可能是不同的。</li>
</ul>
</li>
</ul>
</li>
<li><p>将ZonedDateTime转换为LocalDateTime</p>
<ul>
<li><p>toLocalDateTime(  )将其转换</p>
<ul>
<li>转换后只是丢失了时区信息，日期时间信息不变</li>
</ul>
</li>
</ul>
</li>
<li><p>ZonedDateTime也提供了plusDays()等加减操作</p>
</li>
</ul>
</li>
<li><p>Instant</p>
<ul>
<li><p>Epoch Time(时间戳)</p>
<ul>
<li><p>Epoch Time是计算从1970年1月1日零点（格林威治时区／GMT+00:00）到现在所经历的秒数</p>
<ul>
<li>这便是计算机中时间的本质，可以通过Epoch  Time获得日期时间</li>
<li>当需要显示为某一地区的当地时间时，我们就把它格式化为一个字符串</li>
</ul>
</li>
<li><p>Epoch Time又称为时间戳，在不同的编程语言中，会有几种存储方式</p>
<ul>
<li><p>以秒为单位的整数：1574208900，缺点是精度只能到秒；</p>
</li>
<li><p>以毫秒为单位的整数：1574208900123，最后3位表示毫秒数；</p>
</li>
<li><p>以秒为单位的浮点数：1574208900.123，小数点后面表示零点几秒。</p>
</li>
<li><p>Java程序中，时间戳通常是用long表示的毫秒数</p>
<ul>
<li>long t = 1574208900123L;</li>
</ul>
</li>
</ul>
</li>
<li><p>long  System.currentTimeMillis(  )获取当前时间戳</p>
</li>
</ul>
</li>
<li><p>时间戳在java.time中以Instant类型表示</p>
</li>
<li><p>获取时间戳</p>
<ul>
<li><p>Instant.now(  )获取当前时间戳</p>
<ul>
<li><p>Instant now = Instant.now();<br>System.out.println(now.getEpochSecond()); // 1596438837秒<br>System.out.println(now.toEpochMilli()); // 1596438837916毫秒</p>
<ul>
<li>它和System.currentTimeMillis()返回的long相比，只是多了更高精度的纳秒。</li>
</ul>
</li>
</ul>
</li>
<li><p>Instant.ofEpochSecond( 时间戳 )获取指定时间戳</p>
</li>
</ul>
</li>
<li><p>Instant就是时间戳，那么，给它附加上一个时区，就可以创建出ZonedDateTime</p>
<ul>
<li>Instant ins = Instant.ofEpochSecond(1568568760);// 以指定时间戳创建Instant:<br>ZonedDateTime zdt = ins.atZone(ZoneId.systemDefault());<br>System.out.println(zdt); // 2019-09-16T01:32:40+08:00[Asia/Shanghai]</li>
<li>所以，LocalDateTime，ZoneId，Instant，ZonedDateTime和long都可以互相转换</li>
</ul>
</li>
</ul>
</li>
<li><p>最佳实践</p>
<ul>
<li><p>旧API转新API</p>
<ul>
<li>Instant ins1 = new Date().toInstant();// Date -&gt; Instant:</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Calendar calendar = Calendar.getInstance();// Calendar -&gt; Instant -&gt; ZonedDateTime:<br>Instant ins2 = Calendar.getInstance().toInstant();<br>ZonedDateTime zdt = ins2.atZone(calendar.getTimeZone().toZoneId());</p>
<pre><code>        - toInstant(  )将Date或Calendar转换为Instant对象
        - toZoneId(  )将TimeZone转换为新的ZoneId

- 新API转旧API

    - 如果要把新的ZonedDateTime转换为旧的API对象，只能借助long型时间戳做一个“中转”

        - ZonedDateTime zdt = ZonedDateTime.now();// ZonedDateTime -&gt; long:</code></pre><p>long ts = zdt.toEpochSecond() * 1000;</p>
<p>Date date = new Date(ts);// long -&gt; Date:</p>
<p>Calendar calendar = Calendar.getInstance();// long -&gt; Calendar:<br>calendar.clear();<br>calendar.setTimeZone(TimeZone.getTimeZone(zdt.getZone().getId()));<br>//新的ZoneId转换为旧的TimeZone，需要借助ZoneId.getId()返回的String完成。<br>calendar.setTimeInMillis(zdt.toEpochSecond() * 1000);</p>
<pre><code>- 在数据库中存储时间戳时，尽量使用long型时间戳，它具有省空间，效率高，不依赖数据库的优点。</code></pre><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h3 id="单元测试就是针对最小的功能单元编写测试代码，即对单个方法的测试"><a href="#单元测试就是针对最小的功能单元编写测试代码，即对单个方法的测试" class="headerlink" title="单元测试就是针对最小的功能单元编写测试代码，即对单个方法的测试"></a>单元测试就是针对最小的功能单元编写测试代码，即对单个方法的测试</h3><h3 id="注解-1"><a href="#注解-1" class="headerlink" title="注解"></a>注解</h3><ul>
<li><p>@Test注解</p>
<ul>
<li><p>这是JUnit要求的，它会把带有@Test的方法识别为测试方法。</p>
<ul>
<li>import org.junit.jupiter.api.Test;</li>
</ul>
</li>
<li><p>在测试方法内部</p>
<ul>
<li><p>import static org.junit.jupiter.api.Assertions.*;</p>
</li>
<li><p>assertEquals(  )期待值相等</p>
<ul>
<li>使用浮点数时，由于浮点数无法精确地进行比较，因此，我们需要调用assertEquals(double expected, double actual, double delta)这个重载方法，指定一个误差值</li>
</ul>
</li>
<li><p>assertTrue(  ): 期待结果为true</p>
</li>
<li><p>assertFalse(  ): 期待结果为false</p>
</li>
<li><p>assertNotNull(  ): 期待结果为非null</p>
</li>
<li><p>assertArrayEquals(  ): 期待结果为数组并与期望数组每个元素的值均相等</p>
</li>
<li><p>异常测试</p>
<ul>
<li><p>assertThrows(  )来期望捕获一个指定的异常。</p>
<ul>
<li><p>@Test<br>void testNegative() {<br>assertThrows(IllegalArgumentException.class, new Executable() {<br>@Override<br>public void execute() throws Throwable {<br>Factorial.fact(-1);<br>}<br>});<br>}</p>
<ul>
<li><p>更简洁方式：<br>@Test<br>void testNegative() {<br>assertThrows(IllegalArgumentException.class, () -&gt; {<br>Factorial.fact(-1);//会抛出IllegalArgumentException<br>});<br>}</p>
<ul>
<li>奇怪的-&gt;语法就是函数式接口的实现代码</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>…</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>标记为@BeforeEach和@AfterEach的方法，它们会在运行每个@Test方法前后自动运行。</p>
<ul>
<li><p>public class CalculatorTest {</p>
<p>Calculator calculator; //先在测试类中声明一个原类对象</p>
<p>@BeforeEach<br>public void setUp() {//每次测试时初始化这个对象<br>  this.calculator = new Calculator(15);<br>}</p>
<p>@AfterEach<br>public void tearDown() {//每次测试完毕后将其清理<br>  this.calculator = null;<br>}</p>
<p>@Test<br>void testAdd() {//在测试方法中用刚刚初始化的对象进行测试<br>  assertEquals(115, this.calculator.add(100));<br>  assertEquals(165, this.calculator.add(50));<br>  assertEquals(145, this.calculator.add(-20));<br>}</p>
<p>@Test<br>void testSub() {<br>  assertEquals(-85, this.calculator.sub(100));<br>  assertEquals(-135, this.calculator.sub(50));<br>  assertEquals(-115, this.calculator.sub(-20));<br>}<br>}</p>
</li>
</ul>
</li>
<li><p>@BeforeAll和@AfterAll，它们在运行所有@Test前后运行</p>
<ul>
<li>因为@BeforeAll和@AfterAll在所有@Test方法运行前后仅运行一次，因此，它们只能初始化静态变量。</li>
</ul>
</li>
<li><p>条件测试</p>
<ul>
<li><p>@Disabled使测试暂时不运行</p>
<ul>
<li>为什么我们不直接注释掉@Test，而是要加一个@Disabled？这是因为注释掉@Test，JUnit就不知道这是个测试方法，而加上@Disabled，JUnit仍然识别出这是个测试方法，只是暂时不运行。</li>
</ul>
</li>
<li><p>@EnabledOnOs({ OS.LINUX, OS.MAC })只能在某个特定的系统测试</p>
<ul>
<li>这里是Linux和MAC</li>
</ul>
</li>
<li><p>@DisabledOnOs(OS.WINDOWS)不在某个特定的系统测试</p>
<ul>
<li>这里是Windows</li>
</ul>
</li>
<li><p>@DisabledOnJre(JRE.JAVA_8)只能在某个更高版本测试</p>
<ul>
<li>这里是java8以上</li>
</ul>
</li>
<li><p>@EnabledIfSystemProperty(named = “os.arch”, matches = “.<em>64.</em>“) 只能在特定的系统属性测试</p>
<ul>
<li>这里是64位操作系统上</li>
</ul>
</li>
<li><p>@EnabledIfEnvironmentVariable(named = “DEBUG”, matches = “true”)需传入特定的环境变量</p>
<ul>
<li>这里是需要传入环境变量DEBUG=true</li>
</ul>
</li>
</ul>
</li>
<li><p>参数化测试</p>
<ul>
<li><p>@ParameterizedTest，用来进行参数化测试。</p>
<ul>
<li><p>@ValueSource(  )来直接传入一组参数，实际上是数组</p>
<ul>
<li>例如：@ValueSource(ints = { 0, 1, 5, 100 })传入一组int参数</li>
</ul>
</li>
<li><p>@MethodSource，它允许编写一个同名的静态方法来提供测试参数，  这个静态方法需要返回一组测试参数</p>
<ul>
<li>@ParameterizedTest<br>@MethodSource<br>void testCapitalize(String input, String result) {<br>assertEquals(result, StringUtils.capitalize(input));<br>}</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>static List<Arguments> testCapitalize() {//返回的是一个存Arguments类型的List<br>    return List.of( // 使用Arguments类静态方法来添加元素<br>            Arguments.arguments(“abc”, “Abc”), //<br>            Arguments.arguments(“APPLE”, “Apple”), //<br>            Arguments.arguments(“gooD”, “Good”));<br>}</p>
<pre><code>- @CsvSource，它的每一个字符串表示一行，一行包含的若干参数用,分隔

    - 可将@MethodSource提供参数方法改为@CsvSource提供参数</code></pre><p>@ParameterizedTest<br>@CsvSource({ “abc, Abc”, “APPLE, Apple”, “gooD, Good” })<br>void testCapitalize(String input, String result) {<br>    assertEquals(result, StringUtils.capitalize(input));<br>}<br>            - 如果有成百上千的测试输入，那么，直接写@CsvSource就很不方便。可以把测试数据提到一个独立的CSV文件中，然后标注上@CsvFileSource</p>
<pre><code>- 如：</code></pre><p>@ParameterizedTest<br>@CsvFileSource(resources = { “/test-capitalize.csv” })</p>
<pre><code>- 文件内容可以为：</code></pre><p>apple, Apple<br>HELLO, Hello<br>JUnit, Junit<br>reSource, Resource</p>
<pre><code>- JUnit只在classpath中查找指定的CSV文件，因此，test-capitalize.csv这个文件要放到test目录下</code></pre><h3 id="使用Fixture"><a href="#使用Fixture" class="headerlink" title="使用Fixture"></a>使用Fixture</h3><ul>
<li>对于实例变量，在@BeforeEach中初始化，在@AfterEach中清理，它们在各个@Test方法中互不影响，因为是不同的实例；</li>
<li>对于静态变量，在@BeforeAll中初始化，在@AfterAll中清理，它们在各个@Test方法中均是唯一实例，会影响各个@Test方法。</li>
</ul>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="正则表达式可以用字符串来描述规则，并用来匹配字符串。"><a href="#正则表达式可以用字符串来描述规则，并用来匹配字符串。" class="headerlink" title="正则表达式可以用字符串来描述规则，并用来匹配字符串。"></a>正则表达式可以用字符串来描述规则，并用来匹配字符串。</h3><ul>
<li>Java标准库的java.util.regex包内置了正则表达式引擎</li>
</ul>
<h3 id="java字符串用-表示"><a href="#java字符串用-表示" class="headerlink" title="java字符串用\表示\"></a>java字符串用\表示\</h3><h3 id="正则表达式的匹配规则是从左到右按规则匹配。"><a href="#正则表达式的匹配规则是从左到右按规则匹配。" class="headerlink" title="正则表达式的匹配规则是从左到右按规则匹配。"></a>正则表达式的匹配规则是从左到右按规则匹配。</h3><h3 id="如果想匹配非ASCII字符，例如中文，那就用-u-的十六进制表示，例如：a-u548cc匹配字符串”a和c”，中文字符和的Unicode编码是548c。"><a href="#如果想匹配非ASCII字符，例如中文，那就用-u-的十六进制表示，例如：a-u548cc匹配字符串”a和c”，中文字符和的Unicode编码是548c。" class="headerlink" title="如果想匹配非ASCII字符，例如中文，那就用\u####的十六进制表示，例如：a\u548cc匹配字符串”a和c”，中文字符和的Unicode编码是548c。"></a>如果想匹配非ASCII字符，例如中文，那就用\u####的十六进制表示，例如：a\u548cc匹配字符串”a和c”，中文字符和的Unicode编码是548c。</h3><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ul>
<li><p>创建一个正则表达式字符串</p>
</li>
<li><p>让想要匹配的字符串来调用matches( 正则表达式 )得到是否匹配成功</p>
<ul>
<li><p>方法内部调用的就是Pattern和Matcher类的方法。</p>
</li>
<li><p>一直使用改方法来匹配的坏处</p>
<ul>
<li>反复使用String.matches()对同一个正则表达式进行多次匹配效率较低，因为每次都会创建出一样的Pattern对象。完全可以先创建出一个Pattern对象，然后反复使用，就可以实现编译一次，多次匹配</li>
</ul>
</li>
</ul>
</li>
<li><p>如：</p>
<pre><code>String regex = &quot;20\\d\\d&quot;;//正则表达式在Java代码中也是一个字符串
System.out.println(&quot;2019&quot;.matches(regex)); // true
System.out.println(&quot;2100&quot;.matches(regex)); // false </code></pre></li>
</ul>
<h3 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h3><ul>
<li><p>匹配任意字符</p>
<ul>
<li>.</li>
</ul>
</li>
<li><p>匹配数字字符</p>
<ul>
<li><p>\d</p>
<ul>
<li>d的意思是digit(数字)</li>
</ul>
</li>
<li><p>匹配非数字字符</p>
<ul>
<li>\D</li>
</ul>
</li>
</ul>
</li>
<li><p>匹配一个字母、数字或下划线</p>
<ul>
<li><p>\w</p>
<ul>
<li>w的意思是word。</li>
</ul>
</li>
<li><p>匹配\w不能匹配的</p>
<ul>
<li>\W</li>
</ul>
</li>
</ul>
</li>
<li><p>匹配空格字符</p>
<ul>
<li><p>\s</p>
<ul>
<li>注意空格字符不但包括空格，还包括tab字符（在Java中用\t表示）。s的意思是space。</li>
</ul>
</li>
<li><p>匹配非空格字符</p>
<ul>
<li>\S</li>
</ul>
</li>
</ul>
</li>
<li><p>修饰符</p>
<ul>
<li><p>用来修饰规则变成更完整的规则</p>
<ul>
<li>如：修饰\d使其可以匹配任意个数字：\d*</li>
</ul>
</li>
<li><p>匹配任意个字符，包括0个字符。</p>
<ul>
<li>*</li>
</ul>
</li>
<li><p>匹配至少一个字符。</p>
<ul>
<li>+</li>
</ul>
</li>
<li><p>匹配0个或一个字符。</p>
<ul>
<li>?</li>
</ul>
</li>
<li><p>精确指定匹配n个字符</p>
<ul>
<li>{n}</li>
</ul>
</li>
<li><p>精确指定匹配n~m个字符</p>
<ul>
<li><p>{n,m}</p>
<ul>
<li>如果没有上限，那么修饰符{n,}就可以匹配至少n个字符。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="复杂匹配规则"><a href="#复杂匹配规则" class="headerlink" title="复杂匹配规则"></a>复杂匹配规则</h3><ul>
<li><p>匹配开头和结尾</p>
<ul>
<li>用正则表达式进行多行匹配时，我们用^表示开头，$表示结尾。</li>
</ul>
</li>
<li><p>匹配指定范围</p>
<ul>
<li><p>使用[…]可以匹配范围内的字符</p>
<ul>
<li><p>如：例如，[123456789]可以匹配1~9,没有0</p>
</li>
<li><p>将所有字符全列出来太麻烦，直接写[1-9]即可。</p>
</li>
<li><p>排除法</p>
<ul>
<li><p>匹配不包含指定范围的字符</p>
<ul>
<li><p>在匹配的指定范围前加上  ^</p>
<ul>
<li><p>如：[^1-9]{3}</p>
<ul>
<li>可以匹配”ABC”，因为不包含字符1~9；<br>不能匹配”A01”，因为包含字符1；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>匹配十六进制数</p>
<ul>
<li><p>[0-9a-fA-F]</p>
<ul>
<li>它表示一共可以匹配以下任意范围的字符：</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>0-9：字符0<del>9；<br>a-f：字符a</del>f；<br>A-F：字符A~F。<br>            - 使用修饰符修饰一下</p>
<pre><code>- [0-9a-fA-F]{6}

    - 匹配6位十六进制数</code></pre><ul>
<li><p>或规则匹配</p>
<ul>
<li><p>用 | 连接的两个正则规则是或规则</p>
<ul>
<li>例如，AB|CD表示可以匹配AB或CD。</li>
</ul>
</li>
</ul>
</li>
<li><p>使用括号</p>
<ul>
<li><p>匹配字符串learn java、learn php和learn go</p>
<ul>
<li><p>一个最简单的规则是learn\sjava|learn\sphp|learn\sgo</p>
</li>
<li><p>把公共部分提出来，然后用(…)把子规则括起来表示成learn\s(java|php|go)。</p>
<ul>
<li>有点数学表达式的味儿</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>非贪婪匹配</p>
<ul>
<li><p>正则表达式默认使用贪婪匹配：任何一个规则，它总是尽可能多地向后匹配。</p>
<ul>
<li>Pattern pattern = Pattern.compile(“(\d+)(0*)”);<br>Matcher matcher = pattern.matcher(“1230000”);<br>if (matcher.matches()) {<br> System.out.println(“group1=” + matcher.group(1)); // “1230000”<br> System.out.println(“group2=” + matcher.group(0)); // “”<br>}</li>
</ul>
</li>
<li><p>在规则后面加个?即可表示非贪婪匹配，让其尽量少匹配，然后让其他规则匹配</p>
<ul>
<li>Pattern pattern = Pattern.compile(“(\d+?)(0*)”);<br>Matcher matcher = pattern.matcher(“1230000”);<br>if (matcher.matches()) {<br>  System.out.println(“group1=” + matcher.group(1)); // “123”<br>  System.out.println(“group2=” + matcher.group(2)); // “0000”<br>}</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Pattern"><a href="#Pattern" class="headerlink" title="Pattern"></a>Pattern</h3><ul>
<li><p>基本使用方法</p>
<ul>
<li><p>分组匹配</p>
<ul>
<li>用(…)先把要提取的规则分组，然后可以按括号提取子串</li>
</ul>
</li>
<li><p>import java.util.regex.*; </p>
</li>
</ul>
</li>
</ul>
<p>Pattern p = Pattern.compile(“(\d{3,4})-(\d{7,8})”);     //使用compile(  )创建一个带正则规则Pattern对象<br>        Matcher m = p.matcher(“010-12345678”);                //用Pattern匹配获得一个Matcher(匹配的信息)对象<br>        if (m.matches()) {                                                                //如果匹配成功<br>            String g1 = m.group(1);                                                 //返回第一组<br>            String g2 = m.group(2);                                              //返回第二组<br>            System.out.println(g1);                                              //010<br>            System.out.println(g2);                                            //12345678<br>        } else {                                                                                 //如果匹配失败<br>            System.out.println(“匹配失败!”);<br>        }</p>
<pre><code>- 使用一个规则创建Pattern对象

    -  Pattern  compile( 正则表达式 )

- 用Pattern匹配获得一个Matcher对象

    - Matcher  matcher( 匹配字符串 )

- 返回是否匹配成功

    - boolean  matches(  )

- 返回使用(  )分组的字符串

    - String  group( int group )</code></pre><ul>
<li><p>分割字符串</p>
<ul>
<li><p>创建一个Pattern对象后，调用split( 想要分割的字符串 )方法返回分割后的数组</p>
<ul>
<li>String s = “the quick brown”;<br>Pattern p = Pattern.compile(“ “);                                     //使用空格分割<br>System.out.println(Arrays.toString(p.split(s)));       //[the, quick, brown]</li>
</ul>
</li>
</ul>
</li>
<li><p>搜索字符串</p>
<ul>
<li><p>例子</p>
<ul>
<li><p>String s = “the quick brown fox jumps over the lazy dog.”;<br>Pattern p = Pattern.compile(“\wo\w”);                 //创建匹配规则<br>Matcher m = p.matcher(s);                                           //获取匹配信息<br>while (m.find()) {                                                             //查找是否有匹配成功的子串<br>String sub = s.substring(m.start(), m.end());   //得到子串的起始位置和结束位置后，截取<br>System.out.println(sub);<br>}  </p>
<ul>
<li>find(  )返回是否有匹配成功的子串，如果有，得到该次查找成功子串相关信息，下次查找将跳过已经匹配过的子串，直到查找完毕。</li>
<li>start(  )和end(  )得到Mather对象中现存串在匹配字符串中的起始位置和结束位置。</li>
<li>输出：row<br>fox<br>dog</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>反向引用</p>
<ul>
<li><p>使用replaceAll(  )的时候，我们传入的第二个参数可以使用$1、$2来反向引用匹配到的子串。</p>
<ul>
<li>String s = “the quick brown fox jumps over the lazy dog.”;<br>String r = s.replaceAll(“\s([a-z]{4})\s”, “ <b>$1</b> “);        //([a-z]{4})替换了$1<br>System.out.println(r);<br>//the quick brown fox jumps <b>over</b> the <b>lazy</b> dog.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="加密与安全"><a href="#加密与安全" class="headerlink" title="加密与安全"></a>加密与安全</h2><h3 id="应对潜在的安全威胁，需要做到三防"><a href="#应对潜在的安全威胁，需要做到三防" class="headerlink" title="应对潜在的安全威胁，需要做到三防"></a>应对潜在的安全威胁，需要做到三防</h3><ul>
<li>防窃听</li>
<li>防篡改</li>
<li>防伪造</li>
</ul>
<h3 id="编码算法"><a href="#编码算法" class="headerlink" title="编码算法"></a>编码算法</h3><ul>
<li><p>UTF-8编码</p>
<ul>
<li>UTF-8编码，它是一种不定长编码，但可以从给定字符的Unicode编码推算出来。需要三个字节</li>
</ul>
</li>
<li><p>URL编码</p>
<ul>
<li><p>URL编码是什么?</p>
<ul>
<li><p>URL编码是浏览器发送数据给服务器时使用的编码，它通常附加在URL的参数部分。</p>
<ul>
<li><p>例如：<a href="https://www.baidu.com/s?wd=%E4%B8%AD%E6%96%87" target="_blank" rel="noopener">https://www.baidu.com/s?wd=%E4%B8%AD%E6%96%87</a></p>
<ul>
<li><p>字符 ‘中’ 的UTF-8编码是0xe4b8ad，因此，它的URL编码是%E4%B8%AD。</p>
<ul>
<li>URL编码总是大写。</li>
</ul>
</li>
</ul>
</li>
<li><p>之所以需要URL编码，是因为出于兼容性考虑，很多服务器只识别ASCII字符。但如果URL中包含中文、日文这些非ASCII字符就需要按照规则</p>
<ul>
<li>如果字符是A<del>Z，a</del>z，0~9以及-、_、.、*，则保持不变；</li>
<li>如果是其他字符，先转换为UTF-8编码，然后对每个字节以%XX表示。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>URL编码的目的</p>
<ul>
<li>URL编码的目的是把任意文本数据编码为%前缀表示的文本，编码后的文本仅包含A<del>Z，a</del>z，0~9，-，_，.，*和%，便于浏览器和服务器处理。</li>
</ul>
</li>
<li><p>URL编解码</p>
<ul>
<li><p>对任意字符串进行URL编码</p>
<ul>
<li><p>java.net.URLEncoder</p>
<ul>
<li>import java.net.URLEncoder;<br>import java.nio.charset.StandardCharsets;</li>
</ul>
</li>
</ul>
<p>String encoded = URLEncoder.encode(“中文!”, StandardCharsets.UTF_8);<br>System.out.println(encoded);                 //%E4%B8%AD%E6%96%87%21</p>
<pre><code>- URLEncoder.encode(需要编码字符串,编码标准)</code></pre><ul>
<li><p>空格的编码</p>
<ul>
<li>和标准的URL编码稍有不同，URLEncoder把空格字符编码成+，而现在的URL编码标准要求空格被编码为%20，不过，服务器都可以处理这两种情况。</li>
</ul>
</li>
</ul>
</li>
<li><p>对URl编码字符串进行解码</p>
<ul>
<li><p>java.net.URLDecoder</p>
<ul>
<li>import java.net.URLDecoder;<br>import java.nio.charset.StandardCharsets;</li>
</ul>
</li>
</ul>
<p>String decoded = URLDecoder.decode(“%E4%B8%AD%E6%96%87%21”, StandardCharsets.UTF_8);<br>System.out.println(decoded);                  //中文!</p>
<pre><code>- URLDecoder.decode(需要解码字符串,编码标准)</code></pre></li>
</ul>
</li>
<li><p>关于URL编码需要注意</p>
<ul>
<li>URL编码是编码算法，不是加密算法。</li>
</ul>
</li>
</ul>
</li>
<li><p>Base64编码</p>
<ul>
<li><p>Base64编码的作用</p>
<ul>
<li><p>可以把任意长度的二进制数据变为纯文本，且只包含A<del>Z、a</del>z、0~9、+、/、=这些字符。</p>
<ul>
<li>例如：电子邮件协议就是文本协议，想要在电子邮件中添加一个二进制文件，就可以用Base64编码，然后以文本的形式传送。</li>
</ul>
</li>
</ul>
</li>
<li><p>Base64编码原理</p>
<ul>
<li><p>把3字节的二进制数据按6bit一组，用4个int整数表示，然后查表，把int整数用索引对应到字符，得到编码后的字符串。</p>
<ul>
<li><p>举个例子：3个byte数据分别是e4、b8、ad，按6bit分组得到39、0b、22和2d(16进制表示)</p>
<ul>
<li></li>
</ul>
</li>
<li><p>为什么按6bit一组?</p>
<ul>
<li>因为6位整数的范围总是0<del>63，所以，能用64个字符表示：字符A</del>Z对应索引0<del>25，字符a</del>z对应索引26<del>51，字符0</del>9对应索引52~61，最后两个索引62、63分别用字符+和/表示。</li>
</ul>
</li>
<li><p>如果输入的byte[]数组长度不是3的整数倍如何处理？</p>
<ul>
<li><p>这种情况下，需要对输入的末尾补一个或两个0x00，编码后，在结尾加一个=表示补充了1个0x00，加两个=表示补充了2个0x00，解码的时候，去掉末尾补充的一个或两个0x00即可。</p>
<ul>
<li><p>实际上，因为编码后的长度加上=总是4的倍数，所以即使不加=也可以计算出原始输入的byte[]。Base64编码的时候可以用withoutPadding()去掉=，解码出来的结果是一样的</p>
<ul>
<li>withoutPadding(  )去掉填充</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Base64编解码</p>
<ul>
<li><p>在Java中，二进制数据就是byte[]数组，即Base64对byte[]数组进行编解码</p>
</li>
<li><p>java.util.Base64</p>
<ul>
<li><p>对byte[]数组编码</p>
<ul>
<li><p>byte[] input ={ (byte) 0xe4, (byte) 0xb8, (byte) 0xad };<br>String b64encoded = Base64.getEncoder().encodeToString(input);<br>System.out.println(b64encoded);                        //5Lit</p>
<ul>
<li>Base64.getEncoder(  )返回一个Base64编码器</li>
<li>encodeToString( byte[] )使用Base64 编码方案将指定的字节数组编码为字符串。</li>
</ul>
</li>
</ul>
</li>
<li><p>对Base64编码字符串解码</p>
<ul>
<li><p>byte[] output = Base64.getDecoder().decode(“5Lit”);<br>System.out.println(Arrays.toString(output));                     // [-28, -72, -83]</p>
<ul>
<li>Base64.getDecoder(  )返回Base64解码器。</li>
<li>decode(String) 使用Base64编码方案将指定字符串解码为byte[]数组</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>标准的Base64编码会出现+、/和=(URL编码不能出现)，所以不适合把Base64编码后的字符串放到URL中。一种针对URL的Base64编码可以在URL中使用的Base64编码，它仅仅是把+变成-，/变成_。(=没有改变)</p>
<ul>
<li><p>byte[] input = new byte[] { 0x01, 0x02, 0x7f, 0x00 };<br>String b64encoded = Base64.getUrlEncoder().encodeToString(input);<br>System.out.println(b64encoded);                                                                             //AQJ_AA==<br>byte[] output = Base64.getUrlDecoder().decode(b64encoded);<br>System.out.println(Arrays.toString(output));                                                       //[1, 2, 127, 0]</p>
<ul>
<li>Base64.getUrlDecoder(  )返回一个使用 URL和Filename安全类型base64编码方案进行解码的解码器</li>
</ul>
</li>
</ul>
</li>
<li><p>Base64编码缺点</p>
<ul>
<li><p>它把原始数据的长度增加了1/3，传输效率会降低。</p>
<ul>
<li>如果把Base64的64个字符编码表换成32个、48个或者58个，就可以使用Base32编码，Base48编码和Base58编码。字符越少，编码的效率就会越低。</li>
</ul>
</li>
</ul>
</li>
<li><p>关于Base64编码需要注意</p>
<ul>
<li>Base64编码是一种编码算法，不是加密算法。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="哈希算法-Hash"><a href="#哈希算法-Hash" class="headerlink" title="哈希算法(Hash)"></a>哈希算法(Hash)</h3><ul>
<li><p>哈希算法的作用</p>
<ul>
<li>对任意一组输入数据进行计算，得到一个固定长度的输出摘要。</li>
</ul>
</li>
<li><p>哈希算法的目的</p>
<ul>
<li><p>为了验证原始数据是否被篡改。</p>
</li>
<li><p>存储用户口令</p>
<ul>
<li><p>若直接将用户的原始口令存放到数据库中，会产生极大的安全风险</p>
<ul>
<li>数据库管理员能够看到用户明文口令；</li>
<li>数据库数据一旦泄漏，黑客即可获取用户明文口令。</li>
</ul>
</li>
<li><p>应使用如：在用户输入原始口令后，系统计算用户输入的原始口令的MD5并与数据库存储的MD5对比，如果一致，说明口令正确，否则，口令错误。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>哈希算法最重要的特点</p>
<ul>
<li>相同的输入一定得到相同的输出；</li>
<li>不同的输入大概率得到不同的输出。</li>
</ul>
</li>
<li><p>字符串的hashcode</p>
<ul>
<li><p>hashCode(  )输出固定的4字节int整数</p>
<ul>
<li>如：System.out.println(“hello”.hashCode());      //99162322</li>
<li>两个相同的字符串永远会计算出相同的hashCode，否则基于hashCode定位的HashMap就无法正常工作。这也是为什么当自定义一个class时，覆写equals()方法时我们必须正确覆写hashCode()方法。</li>
</ul>
</li>
</ul>
</li>
<li><p>哈希碰撞</p>
<ul>
<li><p>哈希碰撞是什么？</p>
<ul>
<li><p>两个不同的输入得到了相同的输出</p>
<ul>
<li>如：<br>System.out.println(“AaAaAa”.hashCode());//1952508096<br>System.out.println(“BBAaBB”.hashCode());//1952508096</li>
</ul>
</li>
</ul>
</li>
<li><p>哈希碰撞的原因</p>
<ul>
<li><p>输出的字节长度是固定的</p>
<ul>
<li>如：String的hashCode()输出是4字节整数，最多只有4294967296种输出，但输入的数据长度是不固定的，有无数种输入。所以，哈希算法是把一个无限的输入集合映射到一个有限的输出集合，必然会产生碰撞。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>哈希算法的安全性</p>
<ul>
<li><p>安全的哈希算法必须满足</p>
<ul>
<li><p>碰撞概率低；</p>
<ul>
<li>碰撞概率的高低关系到哈希算法的安全性。</li>
</ul>
</li>
<li><p>不能猜测输出。</p>
<ul>
<li><p>输入的任意一个bit的变化会造成输出完全不同，这样就很难从输出反推输入（只能依靠暴力穷举）。</p>
<ul>
<li>即从输出不能推出哈希算法的规律</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>预防彩虹表</p>
<ul>
<li><p>彩虹表是什么？</p>
<ul>
<li><p>预先计算好的常用口令和它们的MD5的对照表</p>
<ul>
<li><ul>
<li>通过这个表可以将其常用口令直接查到</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>加盐处理</p>
<ul>
<li><p>每个口令额外添加随机数</p>
<ul>
<li><p>常规加盐</p>
<ul>
<li><ul>
<li>存储的是加盐后的口令，所以无法通过彩虹表查到</li>
</ul>
</li>
</ul>
</li>
<li><p>Hmac算法</p>
<ul>
<li></li>
</ul>
</li>
</ul>
</li>
<li><p>加盐的目的</p>
<ul>
<li>可以使黑客的彩虹表失效，即使用户使用常用口令，也无法从哈希算法反推原始口令。</li>
</ul>
</li>
<li><p>更好的选择</p>
<ul>
<li><p>Hmac算法</p>
<ul>
<li><p>Hmac算法是什么？</p>
<ul>
<li>一种基于密钥的消息认证码算法，全称是Hash-based Message Authentication Code，是一种更安全的消息摘要算法。</li>
</ul>
</li>
<li><p>Hmac算法总是和某种哈希算法配合起来用的。</p>
<ul>
<li><p>例如，使用MD5算法，对应的就是HmacMD5算法，它相当于“加盐”的MD5</p>
<ul>
<li>HmacMD5 ≈ md5(secure_random_key, input)</li>
<li>因此，HmacMD5可以看作带有一个安全的key的MD5。</li>
</ul>
</li>
<li><p>使用HmacMD5而不是用MD5加salt，有这些优势</p>
<ul>
<li>HmacMD5使用的key长度是64字节，更安全；</li>
<li>Hmac是标准算法，同样适用于SHA-1等其他哈希算法；</li>
<li>Hmac输出和原有的哈希算法长度一致。</li>
</ul>
</li>
<li><p>Hmac本质上就是把key混入摘要的算法。验证此哈希时，除了原始的输入数据，还要提供key。</p>
<ul>
<li>为了保证安全，我们不会自己指定key，而是通过javax.crypto.KeyGenerator生成一个安全的随机的key。</li>
<li>import java.math.BigInteger;<br>import javax.crypto.*;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>public class Main {<br>    public static void main(String[] args) throws Exception {<br>        KeyGenerator keyGen = KeyGenerator.getInstance(“HmacMD5”);<br>        SecretKey key = keyGen.generateKey();<br>        byte[] skey = key.getEncoded();                                                     // 打印随机生成的key:<br>        System.out.println(new BigInteger(1, skey).toString(16));<br>        Mac mac = Mac.getInstance(“HmacMD5”);<br>        mac.init(key);<br>        mac.update(“HelloWorld”.getBytes(“UTF-8”));<br>        byte[] result = mac.doFinal();<br>        System.out.println(new BigInteger(1, result).toString(16));<br>    }<br>}</p>
<pre><code>                            - 通过名称HmacMD5获取关于HmacMD5的KeyGenerator实例；

                                - KeyGenerator.getInstance(Hmac算法)来获取关于这个算法的KeyGenerator对象

                            - 通过KeyGenerator创建一个SecretKey实例；

                                - generateKey(  )来生成一个随机key

                            - 通过名称HmacMD5获取Mac实例；

                                -  Mac.getInstance(Hmac算法)来获取关于这个算法的Mac对象

                            - 用SecretKey初始化Mac实例；

                                - init(key)使用key来初始化mac

                            - 对Mac实例反复调用update(byte[])输入数据；
                            - 调用Mac实例的doFinal()获取最终的哈希值。

                                - doFinal(  )获取最终byte[]表示的哈希值

                            - getEncoded(  )将key转为byte[]以便存储

                                - SecretKey key = new SecretKeySpec(存储key的byte[], 算法名);来复原算法对应的key

-  注意：MD5因为输出长度较短，短时间内破解是可能的，目前已经不推荐使用。</code></pre><ul>
<li><p>常用的哈希算法</p>
<ul>
<li><ul>
<li>哈希算法的输出长度越长，就越难产生碰撞，也就越安全。</li>
</ul>
</li>
<li><p>使用常用哈希算法计算哈希值</p>
<ul>
<li><p>java.security.MessageDigest</p>
<ul>
<li><p>以MD5算法为例</p>
<ul>
<li>import java.math.BigInteger;<br>import java.security.MessageDigest;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>public class Main {<br>    public static void main(String[] args) throws Exception {<br>        MessageDigest md = MessageDigest.getInstance(“MD5”);  // 使用MD5算法创建一个MessageDigest实例<br>        md.update(“Hello”.getBytes(“UTF-8”));                                      //反复调用update输入byte[]数据:<br>        md.update(“World”.getBytes(“UTF-8”));<br>        byte[] result = md.digest();                                                               // 获得摘要<br>        System.out.println(new BigInteger(1, result).toString(16));//最后用BigInteger存储之后转换为16进制输出<br>    }                                                                                                                      //68e109f0f40ca72a15e05cc22786f8e6<br>}</p>
<pre><code>        - MessageDigest.getInstance(哈希算法) 获得使用对应的哈希算法的消息摘要实例
        - update( byte[])来输入需要转换为摘要的数据
        - digest(  )根据使用的哈希算法对输入数据计算摘要,返回byte[]

- 类似SHA-1、SHA-256、SHA-512等，直接将MD5换为对应的哈希算法既可使用</code></pre><ul>
<li><p>java提供标准库没有的加密和哈希算法</p>
<ul>
<li><p>第三方库BouncyCastle</p>
<ul>
<li><p>注册BouncyCastle</p>
<ul>
<li><p>Security.addProvider(new BouncyCastleProvider());</p>
<ul>
<li>注册只需要在启动时进行一次，后续就可以使用BouncyCastle提供的所有哈希算法和加密算法。</li>
</ul>
</li>
</ul>
</li>
<li><p>Security.addProvider(new BouncyCastleProvider());                                             // 注册BouncyCastle<br>MessageDigest md = MessageDigest.getInstance(“RipeMD160”);                   // 注册后即可使用该库的算法<br>md.update(“HelloWorld”.getBytes(“UTF-8”));<br>byte[] result = md.digest();<br>System.out.println(new BigInteger(1, result).toString(16));</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><ul>
<li><p>对称加密算法</p>
<ul>
<li><p>对称加密算法就是传统的用一个密码进行加密和解密。</p>
<ul>
<li>例如，我们常用的WinZIP和WinRAR对压缩包的加密和解密，就是使用对称加密算法。</li>
</ul>
</li>
<li><p>对称加密大体分析</p>
<ul>
<li><p>加密</p>
<ul>
<li><p>它接收密码和明文，然后输出密文</p>
<ul>
<li>secret = encrypt(key, message);</li>
</ul>
</li>
</ul>
</li>
<li><p>解密</p>
<ul>
<li><p>它接收密码和密文，然后输出明文</p>
<ul>
<li>plain = decrypt(key, secret);</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>对称加密算法局限</p>
<ul>
<li>对称加密算法决定了口令必须是固定长度，然后对明文进行分块加密。又因为安全需求，口令长度往往都是128位以上，即至少16个字符。</li>
</ul>
</li>
<li><p>常用对称加密算法</p>
<ul>
<li><ul>
<li><p>密钥长度直接决定加密强度，而工作模式和填充模式可以看成是对称加密算法的参数和格式选择。</p>
</li>
<li><p>DES算法由于密钥过短，可以在短时间内被暴力破解，所以现在已经不安全了。</p>
<ul>
<li>密钥较短的不建议使用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>对称加密使用</p>
<ul>
<li><p>使用AES算法ECB模式加密并解密</p>
<ul>
<li>import java.security.<em>;<br>import java.util.Base64;<br>import javax.crypto.</em>;<br>import javax.crypto.spec.*;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>public class Main {<br>    public static void main(String[] args) throws Exception {<br>        String message = “Hello, world!”;                                           //明文<br>        System.out.println(“Message: “ + message);<br>        byte[] key = “1234567890abcdef”.getBytes(“UTF-8”);// 固定128位密钥 = 16 bytes Key:<br>        byte[] data = message.getBytes(“UTF-8”);                        //将明文转换为byte[]方便处理<br>        byte[] encrypted = encrypt(key, data);                                // 加密:<br>        System.out.println(“Encrypted: “ + Base64.getEncoder().encodeToString(encrypted));//将加密后数据转为文本<br>        byte[] decrypted = decrypt(key, encrypted);                    // 解密:<br>        System.out.println(“Decrypted: “ + new String(decrypted, “UTF-8”));<br>    }</p>
<pre><code>public static byte[] encrypt(byte[] key, byte[] input) throws GeneralSecurityException {             // 加密算法
    Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;);           //设置算法、工作模式、填充模式
    SecretKey keySpec = new SecretKeySpec(key, &quot;AES&quot;);     //根据算法名称和指定长度的key创建一个SecretKey对象
    cipher.init(Cipher.ENCRYPT_MODE, keySpec);                    //选择加密模式和传入SecretKey初始化Cipher对象
    return cipher.doFinal(input);                                                       //没有输入，所以直接传入input对其加密
}

public static byte[] decrypt(byte[] key, byte[] input) throws GeneralSecurityException {          //解密算法
    Cipher cipher = Cipher.getInstance(&quot;AES/ECB/PKCS5Padding&quot;);
    SecretKey keySpec = new SecretKeySpec(key, &quot;AES&quot;);
    cipher.init(Cipher.DECRYPT_MODE, keySpec);                  //设置为解密模式并传入SecretKey初始化Cipher对象
    return cipher.doFinal(input);
}</code></pre><p>}</p>
<pre><code>            - 根据算法名称/工作模式/填充模式获取Cipher实例；
            - 根据算法名称初始化一个SecretKey实例，密钥必须是指定长度；
            - 使用SerectKey初始化Cipher实例，并设置加密或解密模式；
            - 传入明文或密文，获得密文或明文。

    - 更好的方式是通过CBC模式

        - public class Main {
public static void main(String[] args) throws Exception {
    String message = &quot;Hello, world!&quot;;                                                                                      // 原文
    System.out.println(&quot;Message: &quot; + message);
    byte[] key = &quot;1234567890abcdef1234567890abcdef&quot;.getBytes(&quot;UTF-8&quot;);  // 必须为256位密钥 = 32 bytes Key
    byte[] data = message.getBytes(&quot;UTF-8&quot;);
    byte[] encrypted = encrypt(key, data);        // 加密: 
    System.out.println(&quot;Encrypted: &quot; + Base64.getEncoder().encodeToString(encrypted));
    byte[] decrypted = decrypt(key, encrypted);    //解密:
    System.out.println(&quot;Decrypted: &quot; + new String(decrypted, &quot;UTF-8&quot;));
}

public static byte[] encrypt(byte[] key, byte[] input) throws GeneralSecurityException {    // 加密:
    Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
    SecretKeySpec keySpec = new SecretKeySpec(key, &quot;AES&quot;);
    SecureRandom sr = SecureRandom.getInstanceStrong();// 创建SecureRandom对象
    byte[] iv = sr.generateSeed(16);                                                   //生成16bytesiv
    IvParameterSpec ivps = new IvParameterSpec(iv);             //创建IvParameterSpec对象
    cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivps);         //相比ECB模式多传入一个ivps
    byte[] data = cipher.doFinal(input);
    return join(iv, data);                                                                         // IV不需要保密，把IV和密文连接一起返回:
}

public static byte[] decrypt(byte[] key, byte[] input) throws GeneralSecurityException {   // 解密:
    byte[] iv = new byte[16];
    byte[] data = new byte[input.length - 16]; 
    System.arraycopy(input, 0, iv, 0, 16);                                      // 把input分割成IV和密文:
    System.arraycopy(input, 16, data, 0, data.length);
    Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
    SecretKeySpec keySpec = new SecretKeySpec(key, &quot;AES&quot;);
    IvParameterSpec ivps = new IvParameterSpec(iv);
    cipher.init(Cipher.DECRYPT_MODE, keySpec, ivps);
    return cipher.doFinal(data);
}

public static byte[] join(byte[] bs1, byte[] bs2) {
    byte[] r = new byte[bs1.length + bs2.length];
    System.arraycopy(bs1, 0, r, 0, bs1.length);
    System.arraycopy(bs2, 0, r, bs1.length, bs2.length);
    return r;
}</code></pre><p>}</p>
<pre><code>            - 在CBC模式下，需要一个随机生成的16字节IV参数，必须使用SecureRandom生成。因为多了一个IvParameterSpec实例，因此，初始化方法需要调用Cipher的一个重载方法并传入IvParameterSpec。
            - 观察输出，可以发现每次生成的IV不同，密文也不同。

- 口令加密算法(PBE)

    - 使用PBE算法的原因

        - 用户输入的口令并不能直接作为AES的密钥进行加密（除非长度恰好是128/192/256位），并且用户输入的口令一般都有规律，安全性远远不如安全随机数产生的随机口令。因此，用户输入的口令，通常还需要使用PBE算法，采用随机数杂凑计算出真正的密钥，再进行加密。

    - PBE算法的作用

        - 将用户输入的口令和一个安全随机的口令采用杂凑后计算出真正的密钥。

            - key = generate(userPassword, secureRandomPassword);

    - PBE使用实例

        - public class Main {
public static void main(String[] args) throws Exception {
    Security.addProvider(new BouncyCastleProvider());                  // 把BouncyCastle作为Provider添加到java.security
    String message = &quot;Hello, world!&quot;;                                                        // 明文
    String password = &quot;hello12345&quot;;                                                         // 加密口令                                       
    byte[] salt = SecureRandom.getInstanceStrong().generateSeed(16);           // 16 bytes随机Salt
    System.out.printf(&quot;salt: %032x\n&quot;, new BigInteger(1, salt));                           //注意这里的输出格式，不太明白
    byte[] data = message.getBytes(&quot;UTF-8&quot;);
    byte[] encrypted = encrypt(password, salt, data);                                               // 加密
    System.out.println(&quot;encrypted: &quot; + Base64.getEncoder().encodeToString(encrypted));
    byte[] decrypted = decrypt(password, salt, encrypted);                                  // 解密      
    System.out.println(&quot;decrypted: &quot; + new String(decrypted, &quot;UTF-8&quot;));
}

public static byte[] encrypt(String password, byte[] salt, byte[] input) throws GeneralSecurityException {     // 加密
    PBEKeySpec keySpec = new PBEKeySpec(password.toCharArray());//将口令转为char[]用来构造PBEKeySpec
    SecretKeyFactory skeyFactory = SecretKeyFactory.getInstance(&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;);
    SecretKey skey = skeyFactory.generateSecret(keySpec);                       //用PBEKeySpec对象来创建key
    PBEParameterSpec pbeps = new PBEParameterSpec(salt, 1000);
    Cipher cipher = Cipher.getInstance(&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;);    //指定算法
    cipher.init(Cipher.ENCRYPT_MODE, skey, pbeps);
    return cipher.doFinal(input);
}

// 解密:
public static byte[] decrypt(String password, byte[] salt, byte[] input) throws GeneralSecurityException {
    PBEKeySpec keySpec = new PBEKeySpec(password.toCharArray());
    SecretKeyFactory skeyFactory = SecretKeyFactory.getInstance(&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;);
    SecretKey skey = skeyFactory.generateSecret(keySpec);
    PBEParameterSpec pbeps = new PBEParameterSpec(salt, 1000);
    Cipher cipher = Cipher.getInstance(&quot;PBEwithSHA1and128bitAES-CBC-BC&quot;);
    cipher.init(Cipher.DECRYPT_MODE, skey, pbeps);
    return cipher.doFinal(input);
}</code></pre><p>}</p>
<pre><code>            - 使用PBE时，我们还需要引入BouncyCastle，并指定算法是PBEwithSHA1and128bitAES-CBC-BC。观察代码，实际上真正的AES密钥是调用Cipher的init()方法时同时传入SecretKey和PBEParameterSpec实现的。在创建PBEParameterSpec的时候，我们还指定了循环次数1000，循环次数越多，暴力破解需要的计算量就越大。

- 密钥交换算法(DH)

    - 密钥交换算法的作用

        - 在不安全的通道上安全传输密钥

    - DH算法交换密钥的步骤

        - 假设甲乙双方需要传递密钥

            - 甲首选选择一个素数p，例如509；底数g，任选，例如5；随机数a，例如123，然后计算A=g^a mod p，结果是215，然后，甲发送p＝509，g=5，A=215给乙；
            - 乙方收到后，也选择一个随机数b，例如，456，然后计算B=g^b mod p，结果是181，乙再同时计算s=A^b mod p，结果是121；
            - 乙把计算的B=181发给甲，甲计算s＝B^a mod p的余数，计算结果与乙算出的结果一样，都是121。

                - 最终双方协商出的密钥s是121。注意到这个密钥s并没有在网络上传输。而通过网络传输的p，g，A和B是无法推算出s的，因为实际算法选择的素数是非常大的。

        - 将a看成甲的私钥，A看成甲的公钥，b看成乙的私钥，B看成乙的公钥，DH算法的本质就是双方各自生成自己的私钥和公钥，私钥仅对自己可见，然后交换公钥，并根据自己的私钥和对方的公钥，生成最终的密钥secretKey，DH算法通过数学定律保证了双方各自计算出的secretKey是相同的。

    - DH算法并未解决中间人攻击，即甲乙双方并不能确保与自己通信的是否真的是对方。消除中间人攻击需要其他方法。</code></pre><ul>
<li><p>非对称加密算法</p>
<ul>
<li><p>非对称加密的特点</p>
<ul>
<li><p>加密和解密使用的不是相同的密钥：只有同一个公钥-私钥对才能正常加解密。</p>
<ul>
<li>如：小明要加密一个文件发送给小红，他应该首先向小红索取她的公钥，然后，他用小红的公钥加密，把加密文件发送给小红，此文件只能由小红的私钥解开，因为小红的私钥在她自己手里，所以，除了小红，没有任何人能解开此文件。</li>
</ul>
</li>
</ul>
</li>
<li><p>非对称加密相比对称加密的显著优点在于</p>
<ul>
<li>对称加密需要协商密钥，而非对称加密可以安全地公开各自的公钥，在N个人之间通信的时候：使用非对称加密只需要N个密钥对，每个人只管理自己的密钥对。而使用对称加密需要则需要N*(N-1)/2个密钥，因此每个人需要管理N-1个密钥，密钥管理难度大，而且非常容易泄漏。</li>
</ul>
</li>
<li><p>非对称加密的缺点</p>
<ul>
<li>运算速度非常慢(因为使用的数字非常大)，比对称加密要慢很多。</li>
</ul>
</li>
<li><p>实际使用</p>
<ul>
<li><p>非对称加密总是和对称加密一起使用</p>
<ul>
<li><p>假设小明需要给小红需要传输加密文件，他俩首先交换了各自的公钥</p>
<ul>
<li><p>小明生成一个随机的AES口令，然后用小红的公钥通过RSA加密这个口令，并发给小红；</p>
</li>
<li><p>小红用自己的RSA私钥解密得到AES口令；</p>
</li>
<li><p>双方使用这个共享的AES口令用AES加密通信。</p>
<ul>
<li>双方通信实际上采用的是速度较快的AES对称加密，而不是缓慢的RSA非对称加密。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>getEncoded(  )获得公钥或私钥以byte[]表示的二进制数据，方便存储</p>
<ul>
<li><p>从byte[]数组恢复公钥或私钥</p>
<ul>
<li>byte[] pkData = …<br>byte[] skData = …<br>KeyFactory kf = KeyFactory.getInstance(“RSA”);<br>// 恢复公钥:<br>X509EncodedKeySpec pkSpec = new X509EncodedKeySpec(pkData);<br>PublicKey pk = kf.generatePublic(pkSpec);<br>// 恢复私钥:<br>PKCS8EncodedKeySpec skSpec = new PKCS8EncodedKeySpec(skData);<br>PrivateKey sk = kf.generatePrivate(skSpec);</li>
</ul>
</li>
</ul>
</li>
<li><p>以RSA算法为例</p>
<ul>
<li><p>它的密钥有256/512/1024/2048/4096等不同的长度。长度越长，密码强度越大，当然计算速度也越慢。</p>
</li>
<li><p>RSA算法的局限</p>
<ul>
<li><p>使用512bit的RSA加密时，明文长度不能超过63字节，使用1024bit的RSA加密时，明文长度不能超过117字节。</p>
<ul>
<li>这就是为什么使用RSA的时候，总是配合AES一起使用，即用AES加密任意长度的明文，用RSA加密AES口令。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>只使用非对称加密算法不能防止中间人攻击。</p>
</li>
</ul>
</li>
<li><p>签名算法</p>
<ul>
<li><p>数字签名是什么</p>
<ul>
<li>使用私钥加密得到的密文，可以使用公钥可以将其解密。</li>
</ul>
</li>
<li><p>数字签名的作用</p>
<ul>
<li><p>防止伪造；</p>
<ul>
<li>可以确认某个信息确实是由某个发送方发送的，因为可以用对方的公钥解密。</li>
</ul>
</li>
<li><p>防止抵赖；</p>
</li>
<li><p>检测篡改。</p>
</li>
</ul>
</li>
<li><p>数字签名的使用</p>
<ul>
<li><p>签名实际中并不是针对原始消息，而是针对原始消息的哈希进行签名。</p>
<ul>
<li>signature = encrypt(privateKey, sha256(message));</li>
</ul>
</li>
<li><p>数字签名的验证</p>
<ul>
<li><p>使用公钥解密</p>
<ul>
<li><p>hash = decrypt(publicKey, signature);</p>
</li>
<li><p>把解密后的哈希与原始消息的哈希进行对比得以验证。</p>
<ul>
<li>私钥就相当于用户身份。而公钥用来给外部验证用户身份。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>RSA签名</p>
<ul>
<li>实际上就是指定某种哈希算法进行RSA签名的方式。</li>
<li>MD5withRSA</li>
<li>SHA1withRSA</li>
<li>SHA256withRSA</li>
</ul>
</li>
<li><p>DSA签名</p>
<ul>
<li><p>DSA是Digital Signature Algorithm的缩写，它使用ElGamal数字签名算法。</p>
</li>
<li><p>DSA只能配合SHA使用</p>
<ul>
<li>SHA1withDSA</li>
<li>SHA256withDSA</li>
<li>SHA512withDSA</li>
</ul>
</li>
<li><p>和RSA数字签名相比，DSA的优点是更快。</p>
</li>
</ul>
</li>
<li><p>ECDSA签名</p>
<ul>
<li><p>椭圆曲线签名算法ECDSA：Elliptic Curve Digital Signature Algorithm也是一种常用的签名算法。</p>
</li>
<li><p>ECDSA签名的特点</p>
<ul>
<li><p>可以从私钥推出公钥</p>
<ul>
<li>比特币的签名算法就采用了ECDSA算法，使用标准椭圆曲线secp256k1。</li>
</ul>
</li>
</ul>
</li>
<li><p>BouncyCastle提供了ECDSA的完整实现。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>数字证书</p>
<ul>
<li><p>数字证书是什么？</p>
<ul>
<li><p>数字证书是集合了多种密码学算法，用于实现数据加解密、身份认证、签名等多种功能的一种安全标准。</p>
<ul>
<li>数字证书存储的是公钥，以及相关的证书链和算法信息。私钥必须严格保密，如果数字证书对应的私钥泄漏，就会造成严重的安全威胁。</li>
</ul>
</li>
</ul>
</li>
<li><p>数字证书的特点</p>
<ul>
<li><p>数字证书可以防止中间人攻击，因为它采用链式签名认证，即通过根证书（Root CA）去签名下一级证书，这样层层签名，直到最终的用户证书。</p>
<ul>
<li>Root CA证书内置于操作系统中，所以，任何经过CA认证的数字证书都可以对其本身进行校验，确保证书本身不是伪造的。</li>
</ul>
</li>
</ul>
</li>
<li><p>创建证书</p>
<ul>
<li><p>数字证书存储在一种Java专用的key store文件中，JDK提供了一系列命令来创建和管理key store。</p>
</li>
<li><p>使用命令创建key store</p>
<ul>
<li><p>keytool -storepass 123456 -genkeypair -keyalg RSA -keysize 1024 -sigalg SHA1withRSA -validity 3650 -alias mycert -keystore my.keystore -dname “CN=<a href="http://www.sample.com" target="_blank" rel="noopener">www.sample.com</a>, OU=sample, O=sample, L=BJ, ST=BJ, C=CN”</p>
<ul>
<li>几个主要的参数是：</li>
<li>storepass：设置口令为123456</li>
<li>keyalg：指定RSA加密算法；</li>
<li>sigalg：指定SHA1withRSA签名算法；</li>
<li>validity：指定证书有效期3650天；</li>
<li>alias：指定证书在程序中引用的名称；</li>
<li>dname：最重要的CN=<a href="http://www.sample.com指定了Common" target="_blank" rel="noopener">www.sample.com指定了Common</a> Name，如果证书用在HTTPS中，这个名称必须与域名完全一致。</li>
</ul>
</li>
<li><p>执行上述命令，JDK会在当前目录创建一个my.keystore文件，并存储创建成功的一个私钥和一个证书，它的别名是mycert。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h3><ul>
<li><p>进程</p>
<ul>
<li><p>什么是进程？</p>
<ul>
<li><p>在计算机中，把一个任务称为一个进程</p>
<ul>
<li>例如：浏览器就是一个进程，视频播放器是另一个进程，类似的，音乐播放器和Word都是进程。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>线程</p>
<ul>
<li><p>什么是线程？</p>
<ul>
<li><p>在进程内部同时执行的一个或多个子任务。</p>
<ul>
<li>例如，我们在使用Word时，Word可以让我们一边打字，一边进行拼写检查，同时还可以在后台进行打印。</li>
</ul>
</li>
</ul>
</li>
<li><p>操作系统调度的最小任务单位其实不是进程，而是线程。</p>
<ul>
<li>常用的Windows、Linux等操作系统都采用抢占式多任务，如何调度线程完全由操作系统决定，程序自己不能决定什么时候执行，以及执行多长时间。</li>
</ul>
</li>
</ul>
</li>
<li><p>进程和线程的关系</p>
<ul>
<li>一个进程可以包含一个或多个线程，但至少会有一个线程。</li>
</ul>
</li>
<li><p>实现多任务的方法</p>
<ul>
<li><p>多进程模式（每个进程只有一个线程）</p>
<ul>
<li><p>与多线程相比</p>
<ul>
<li><p>优点</p>
<ul>
<li>多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>创建进程比创建线程开销大，尤其是在Windows系统上；</li>
<li>进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>多线程模式（一个进程有多个线程）</p>
<ul>
<li>通信快、开销小、不稳定</li>
</ul>
</li>
<li><p>多进程＋多线程模式（多个进程有多个线程）</p>
</li>
</ul>
</li>
<li><p>Java语言内置了多线程支持</p>
<ul>
<li><p>一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行main()方法，在main()方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。</p>
<ul>
<li>所以，对于大多数Java程序来说，我们说多任务，实际上是说如何使用多线程实现多任务。</li>
<li>JVM中如果有一个线程没有退出，JVM进程就不会退出。所以，必须保证所有线程都能及时结束。</li>
</ul>
</li>
<li><p>和单线程相比，多线程编程的特点在于</p>
<ul>
<li><p>多线程经常需要读写共享数据，并且需要同步。</p>
<ul>
<li>例如，播放电影时，就必须由一个线程播放视频，另一个线程播放音频，两个线程需要协调运行，否则画面和声音就不同步。因此，多线程编程的复杂度高，调试更困难。</li>
</ul>
</li>
<li><p>多线程模型是Java程序最基本的并发模型；</p>
</li>
<li><p>后续读写网络、数据库、Web开发等都依赖Java多线程模型。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="线程重要方法"><a href="#线程重要方法" class="headerlink" title="线程重要方法"></a>线程重要方法</h3><ul>
<li><p>start(  )会在内部自动调用实例的run(  )方法来启动新线程。</p>
<ul>
<li>直接调用run( )方法，相当于调用了一个普通的Java方法，当前线程并没有任何改变，也不会启动新线程。</li>
</ul>
</li>
<li><p>强迫当前线程暂停一段时间</p>
<ul>
<li>Thread.sleep( 暂停毫秒时间 )</li>
</ul>
</li>
<li><p>对线程设定优先级</p>
<ul>
<li>Thread.setPriority(int n) // 1~10, 默认值5</li>
<li>优先级高的线程被操作系统调度的优先级较高，操作系统对高优先级线程可能调度更频繁，但我们决不能通过设置优先级来确保高优先级的线程一定会先执行。</li>
</ul>
</li>
<li><p>在一个线程中等待另一个线程直到其运行结束才恢复运行</p>
<ul>
<li><p>想要等待的线程.join(  )</p>
</li>
<li><p>可以指定一个等待时间，超过等待时间后就不再继续等待。</p>
<ul>
<li>join(long)</li>
</ul>
</li>
</ul>
</li>
<li><p>通知中断一个线程(不是强制性)</p>
<ul>
<li><p>在其他线程中对目标线程调用interrupt()方法</p>
<ul>
<li><p>目标线程需要反复检测自身状态是否是interrupted状态，如果是，就立刻结束运行。</p>
<ul>
<li><p>public class Main {<br>public static void main(String[] args) throws InterruptedException {<br>Thread t = new MyThread();<br>t.start();<br>Thread.sleep(1); // 暂停1毫秒<br>t.interrupt(); // 中断t线程<br>t.join(); // 等待t线程结束<br>System.out.println(“end”);<br>}<br>}</p>
<ul>
<li>class MyThread extends Thread {<br>public void run() {<br>int n = 0;<br>//所谓的中断就是在这里使其判断为假，然后结束某些语句执行，从而达到结束线程的目的。但是不会立刻结束线程<br>while (! isInterrupted()) {<br>n ++;<br>System.out.println(n + “ hello!”);<br>}<br>System.out.println(“还可以执行哦”);<br>}<br>}</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>    - 如果目标线程处于等待或休眠状态，该线程会中断失败并捕获到InterruptedException；
    -  isInterrupted(  )线程检查自身是否是interrupted状态

        - 上面例子用来作为循环条件

- 设置标志位

    - 通常会用一个running标志位来标识线程是否应该继续运行，在外部线程中，通过把线程的running标志位置为false，就可以让线程结束

        - public class Main {
public static void main(String[] args)  throws InterruptedException {
    HelloThread t = new HelloThread();
    t.start();
    Thread.sleep(1);
    t.running = false; // 标志位置为false
}

            - class HelloThread extends Thread {
public volatile boolean running = true;
public void run() {
    int n = 0;
    while (running) {      //通过标志位来决定是否执行语句
        n ++;
        System.out.println(n + &quot; hello!&quot;);
    }
    System.out.println(&quot;end!&quot;);
}</code></pre><p>}</p>
<pre><code>- 标志位boolean running是一个线程间共享的变量。线程间共享变量需要使用volatile关键字标记，确保每个线程都能读取到更新后的变量值。

    - volatile关键字的目的是告诉虚拟机

        - 每次访问变量时，总是获取主内存的最新值；
        - 每次修改变量后，立刻回写到主内存。</code></pre><ul>
<li><p>获取当前线程</p>
<ul>
<li>Thread.currentThread(  )</li>
</ul>
</li>
<li><p>获取线程名</p>
<ul>
<li><p>线程.getName(  )</p>
<ul>
<li>例如：Thread.currentThread().getName()获取当前线程名</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="创建新线程"><a href="#创建新线程" class="headerlink" title="创建新线程"></a>创建新线程</h3><ul>
<li><p>从Thread派生一个自定义类，然后覆写run()方法</p>
<ul>
<li><p>public class Main {<br>public static void main(String[] args) {<br>  Thread t = new MyThread();<br>  t.start(); // 启动新线程<br>}<br>}</p>
<ul>
<li>class MyThread extends Thread {<br>@Override<br>public void run() {<br>System.out.println(“start new thread!”);<br>}<br>}</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>创建Thread实例时，传入一个实现Runnable接口的实例</p>
<ul>
<li><p>public class Main {<br>public static void main(String[] args) {<br>  Thread t = new Thread(new MyRunnable());<br>  t.start(); // 启动新线程<br>}<br>}</p>
<ul>
<li>class MyRunnable implements Runnable {<br>@Override<br>public void run() {<br>System.out.println(“start new thread!”);<br>}<br>}</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>用Java8引入的lambda语法简写为</p>
<ul>
<li>public class Main {<br>public static void main(String[] args) {<br>  Thread t = new Thread(() -&gt; {<pre><code>System.out.println(&quot;start new thread!&quot;);</code></pre>  });<br>  t.start(); // 启动新线程<br>}<br>}</li>
<li>如果要实现lambda表达式，那么必须有一个前提，提供一个接口，且接口里面的抽象方法只能够存在一个。</li>
</ul>
</li>
</ul>
<h3 id="在线程中执行语句和在main-中执行的区别"><a href="#在线程中执行语句和在main-中执行的区别" class="headerlink" title="在线程中执行语句和在main()中执行的区别"></a>在线程中执行语句和在main()中执行的区别</h3><ul>
<li>在JVM中一个主线程执行main( )方法，线程对象调用start( )之后就会启动一个新的线程，所以两个线程会并发执行，由操作系统调度，程序本身无法确定线程的调度顺序。run( )方法结束时，新线程就结束了。而main()方法结束时，主线程也结束了。</li>
</ul>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><ul>
<li><p>在Java程序中，一个线程对象只能调用一次start()方法启动新线程，并在新线程中执行run()方法。一旦run()方法执行完毕，线程就结束了。</p>
</li>
<li><p>New：新创建的线程，尚未执行；</p>
<ul>
<li>线程启动后，它可以在Runnable、Blocked、Waiting和Timed Waiting这几个状态之间切换，直到最后变成Terminated状态，线程终止。</li>
</ul>
</li>
<li><p>Runnable：运行中的线程，正在执行run()方法的Java代码；</p>
</li>
<li><p>Blocked：运行中的线程，因为某些操作被阻塞而挂起；</p>
</li>
<li><p>Waiting：运行中的线程，因为某些操作在等待中；</p>
</li>
<li><p>Timed Waiting：运行中的线程，因为执行sleep()方法正在计时等待；</p>
</li>
<li><p>Terminated：线程已终止，因为run()方法执行完毕。</p>
<ul>
<li><p>线程终止的原因有</p>
<ul>
<li>线程正常终止：run()方法执行到return语句返回；</li>
<li>线程意外终止：run()方法因为未捕获的异常导致线程终止；</li>
<li>对某个线程的Thread实例调用stop()方法强制终止（强烈不推荐使用）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h3><ul>
<li><p>中断线程是什么？</p>
<ul>
<li>中断线程就是其他线程给该线程发一个信号，该线程收到信号后结束执行run()方法，使得自身线程能立刻结束运行。</li>
</ul>
</li>
<li><p>使用场景</p>
<ul>
<li><p>如果线程需要执行一个长时间任务，就可能需要能中断线程。</p>
<ul>
<li>假设从网络下载一个100M的文件，如果网速很慢，用户等得不耐烦，就可能在下载过程中点“取消”，这时，程序就需要中断下载线程的执行。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><ul>
<li><p>守护线程是什么？</p>
<ul>
<li>守护线程是指为其他线程服务的线程。</li>
</ul>
</li>
<li><p>守护线程的特点</p>
<ul>
<li><p>在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。</p>
<ul>
<li>如可以将时间记录打印线程设置为守护线程，因为它需要一直保持执行</li>
</ul>
</li>
</ul>
</li>
<li><p>创建守护线程</p>
<ul>
<li>在调用start(  )方法前，调用setDaemon(true)把该线程标记为守护线程</li>
</ul>
</li>
<li><p>守护线程注意事项</p>
<ul>
<li>在守护线程中，编写代码要注意：守护线程不能持有任何需要关闭的资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。</li>
</ul>
</li>
</ul>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><ul>
<li><p>线程在操作系统中的调度方式</p>
<ul>
<li><p>当多个线程同时运行时，线程的调度由操作系统决定，程序本身无法决定。因此，任何一个线程都有可能在任何指令处被操作系统暂停，然后在某个时间段后继续执行。</p>
</li>
<li><p>引出单线程模型下不存在的问题</p>
<ul>
<li><p>如果多个线程同时读写共享变量，会出现数据不一致的问题。</p>
<ul>
<li>因为在执行语句对应指令时可能会被操作系统中断</li>
</ul>
</li>
<li><ul>
<li><p>线程一读取数据时为100</p>
</li>
<li><p>线程一被操作系统中断，转而调度执行线程二</p>
</li>
<li><p>线程二读取数据时还是为100因为线程一还没有执行相加指令。线程二相加回写至主内存。线程二调度完成。</p>
</li>
<li><p>回到线程一，开始时已完成读取指令，所以直接在读取的数据(100)上相加然后回写至主内存。</p>
</li>
<li><p>解决办法</p>
<ul>
<li>让某个线程在调度时其他进程等待，不能被中断，即原子操作。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>原子操作</p>
<ul>
<li><p>什么是原子操作？</p>
<ul>
<li><p>字面理解</p>
<ul>
<li>原子最小，所以原子操作就是最小的操作单元，不能再分割操作。</li>
</ul>
</li>
<li><p>系统理解</p>
<ul>
<li>即某一个线程执行时，其他线程必须等待。</li>
</ul>
</li>
</ul>
</li>
<li><p>保证一段代码的原子性就是通过加锁和解锁实现的。</p>
</li>
<li><p>临界区</p>
<ul>
<li><p>什么是临界区</p>
<ul>
<li><ul>
<li>这种加锁和解锁之间的代码块我们称之为临界区（Critical Section），任何时候临界区最多只有一个线程能执行。</li>
</ul>
</li>
<li><p>通过加锁和解锁的操作，保证3条指令总是在一个线程执行期间，不会有其他线程会进入此指令区间。即使在执行期线程被操作系统中断执行，其他线程也会因为无法获得锁导致无法进入此指令区间。只有执行线程将锁释放后，其他线程才有机会获得锁并执行。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>乐观锁和悲观锁</p>
<ul>
<li><p>乐观锁</p>
<ul>
<li><p>什么是乐观锁？</p>
<ul>
<li>总是假设最好的情况，每次去读数据的时候都认为别人不会修改，所以不会上锁， 但是在更新的时候会判断一下在此期间有没有其他线程更新该数据， 可以使用版本号机制和CAS算法实现。 </li>
</ul>
</li>
<li><p>乐观锁的实现步骤</p>
<ul>
<li><p>冲突检测和数据更新</p>
</li>
<li><p>乐观锁的一种典型实现机制（CAS）</p>
<ul>
<li><p>CAS实现原理</p>
<ul>
<li>CAS操作包括三个操作数：需要读写的内存位置(V)、预期原值(A)、新值(B)。</li>
<li>如果内存位置与预期原值的A相匹配，那么将内存位置的值更新为新值B。如果内存位置与预期原值的值不匹配，那么处理器不会做任何操作。</li>
</ul>
</li>
<li><p>乐观锁是一种思想，CAS只是这种思想的一种实现方式。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>使用场景</p>
<ul>
<li>乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</li>
</ul>
</li>
</ul>
</li>
<li><p>悲观锁</p>
<ul>
<li><p>什么是悲观锁？</p>
<ul>
<li>总是假设最坏的情况，每次去读数据的时候都认为别人会修改，所以每次在读数据的时候都会上锁， 这样别人想读取数据就会阻塞直到它获取锁 （共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。</li>
</ul>
</li>
<li><p>使用场景</p>
<ul>
<li>悲观锁适用于读比较少的情况下（多写场景），如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>synchronized关键字</p>
<ul>
<li><p>synchronized保证了代码块在任意时刻最多只有一个线程能执行。</p>
<ul>
<li>即线程获得锁</li>
<li>synchronized解决了多线程竞争的问题。</li>
<li>但是synchronized并没有解决多线程协调的问题。</li>
</ul>
</li>
<li><p>使用synchronized(同步的)关键字</p>
<ul>
<li><p>例如：<br>class Counter {<br>public static final Object lock = new Object();//共享实例<br>public static final Object lock2 = new Object();<br>public static int count = 0;//共享变量<br>}</p>
<ul>
<li><p>synchronized(Counter.lock) { // 选择共享实例作为锁<br>Counter.count += 1;                //修改共享变量的语句<br>}                                                         // 自动释放锁<br>synchronized(Counter.lock2) {//错误，必须使用同一个锁<br>Counter.count -= 1;<br>}</p>
<ul>
<li><p>这样一来，对Counter.count变量进行读写就不可能同时进行，所以保证了共享变量的正确性。</p>
</li>
<li><p>这里使用的两个锁必须是同一个</p>
<ul>
<li>因为两个线程各自的synchronized锁住的不是同一个对象！这使得两个线程各自都可以同时获得锁：因为JVM只保证同一个锁在任意时刻只能被一个线程获取，但两个不同的锁在同一时刻可以被两个线程分别获取。锁对象如果不对，代码逻辑就不对。</li>
<li>即对同一个共享变量进行修改必须使用同一个锁</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>使用synchronized解决了多线程同步访问共享变量的正确性问题。</p>
<ul>
<li><p>因为synchronized代码块无法并发执行，所以会带来性能的下降</p>
<ul>
<li>因此synchronized代码块除了放置关于线程共享访问变量语句，尽量不要放入其他不重要语句，因为会降低性能</li>
</ul>
</li>
<li><p>此外，加锁和解锁需要消耗一定的时间，所以，synchronized会降低程序的执行效率。</p>
<ul>
<li>但必须这样做，不然无法得到正确的功能。</li>
</ul>
</li>
</ul>
</li>
<li><p>synchronized修饰方法</p>
<ul>
<li><p>用synchronized修饰的方法就是同步方法，它表示整个方法都必须用this实例加锁。</p>
</li>
<li><p>对一个静态方法添加synchronized修饰符，它锁住的是哪个对象？</p>
<ul>
<li><p>静态方法没有this实例，因为static方法是针对类而不是实例</p>
</li>
<li><p>拥有一个Class实例</p>
<ul>
<li>任何一个类都有一个由JVM自动创建的Class实例</li>
<li>因此，对static方法添加synchronized，锁住的是该类的Class实例。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>概括使用synchronized</p>
<ul>
<li><p>找出修改共享变量的线程代码块；</p>
</li>
<li><p>选择一个共享实例作为锁；</p>
</li>
<li><p>使用synchronized(lockObject) { … }。</p>
</li>
<li><p>对一个共享变量的操作使用一个锁。</p>
<ul>
<li>若多个共享变量都使用同一个锁将会造成不必要的效率降低，因为多个互不相干的非读写变量语句都需要等待使用同一个锁来同步，无法并发执行。所以每一个共享变量使用一个锁最为合理。</li>
</ul>
</li>
</ul>
</li>
<li><p>使用synchronized的时候，不必担心抛出异常。因为无论是否有异常，都会在synchronized结束处正确释放锁</p>
<ul>
<li>public void add(int m) {<br>synchronized (obj) {<br>if (m &lt; 0) {<br>throw new RuntimeException();<br>}<br>this.value += m;<br>} // 无论有无异常，都会在此释放锁<br>}</li>
</ul>
</li>
</ul>
</li>
<li><p>不需要synchronized的操作</p>
<ul>
<li><p>JVM规范定义了几种原子操作</p>
<ul>
<li><p>基本类型（long和double除外）赋值，例如：int n = m；</p>
<ul>
<li>long和double是64位数据，JVM没有明确规定64位赋值操作是不是一个原子操作，不过在x64平台的JVM是把long和double的赋值作为原子操作实现的。</li>
</ul>
</li>
<li><p>引用类型赋值，例如：List<String> list = anotherList。</p>
</li>
<li><p>读取操作也是原子操作</p>
</li>
</ul>
</li>
<li><p>单条原子操作的语句不需要同步</p>
<ul>
<li><p>例如：<br>public void set(int m) {<br>synchronized(lock) {<br>this.value = m;<br>}<br>}</p>
<ul>
<li>对引用也是类似。例如：</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>public void set(String s) {<br>    this.value = s;<br>}</p>
<pre><code>- 多行赋值语句，就必须保证是同步操作

    - //例如</code></pre><p>class Pair {<br>    int first;<br>    int last;<br>    public void set(int first, int last) {<br>        synchronized(this) {//用当前对象做锁<br>            this.first = first;<br>            this.last = last;<br>        }<br>    }<br>}</p>
<pre><code>- //有些时候，通过一些巧妙的转换，可以把非原子操作变为原子操作。</code></pre><p>class Pair {<br>    int[] pair;<br>    public void set(int first, int last) {<br>        int[] ps = new int[] { first, last };//是引用赋值的原子操作<br>        this.pair = ps;                    //ps是方法内部定义的局部变量，每个线程都会有各自的局部变量，互不影响，并且互不可见，并不需要同步。<br>    }<br>}</p>
<pre><code>- 为什么多行赋值语句需要保证同步？

    - 你想把游戏里一个人从坐标(10,10)移动到(20,20)，另一个线程把坐标准备移动到(30,30):</code></pre><p>public void setPosition(int x, int y) {<br>    this.x = x;<br>    this.y = y;<br>}<br>最终结果要么是(20,20)要么是(30,30)，</p>
<p>但是不同步的情况下，有可能出现(20, 30)或者(30,20)</p>
<p>这种是逻辑错误，不是想要的最终结果</p>
<pre><code>- 当前线程读第一个变量的时候，其他线程有可能已经修改了第二个变量。除非保证所有线程对这两个变量只进行读操作。</code></pre><p>即写入原子操作不加锁是多线程安全的，但是加锁的目的是保证逻辑正确。</p>
<ul>
<li><p>同步方法</p>
<ul>
<li><p>使用synchronized的时候，锁住的是哪个对象非常重要。让线程自己选择锁对象往往会使得代码逻辑混乱，也不利于封装。更好的方法是把synchronized逻辑封装起来。</p>
<ul>
<li>//例如，编写一个计数器如下：<br>public class Counter {<br>private int count = 0;</li>
</ul>
<p>public void add(int n) {<br>  synchronized(this) {             //使用当前对象作为锁非常合理</p>
<pre><code>count += n;</code></pre><p>  }<br>}</p>
<p>public void dec(int n) {<br>  synchronized(this) {</p>
<pre><code>count -= n;</code></pre><p>  }<br>}</p>
<p>public int get() {<br>  return count;<br>}<br>}</p>
<pre><code>- 这样一来，线程调用add()、dec()方法时，它不必关心同步逻辑，因为synchronized代码块在add()、dec()方法内部。并且，我们注意到，synchronized锁住的对象是this，即当前实例，这又使得创建多个Counter实例的时候，它们之间互不影响，可以并发执行。
- //对于add方法这样写是等价的：</code></pre><p>public synchronized void add(int n) { // 在这个方法中默认用this锁住<br>count += n;<br>} // 解锁</p>
</li>
<li><p>线程安全</p>
<ul>
<li><p>如果一个类被设计为允许多线程正确访问，我们就说这个类就是“线程安全”的（thread-safe）。</p>
</li>
<li><p>线程安全类实例</p>
<ul>
<li>不变类，String，Integer，LocalDate，它们的所有成员变量都是final，多线程同时访问时只能读不能写，这些不变类也是线程安全的。</li>
<li>类似Math这些只提供静态方法，没有成员变量的类，也是线程安全的。</li>
<li>Java标准库的java.lang.StringBuffer也是线程安全的。</li>
</ul>
</li>
<li><p>没有特殊说明时，一个类默认是非线程安全的。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul>
<li><p>Java的线程锁是可重入的锁。</p>
<ul>
<li><p>什么是可重入的锁？</p>
<ul>
<li>能被同一个线程反复获取的锁，就叫做可重入锁。</li>
<li>public class Counter {<br>private int count = 0;</li>
</ul>
<p>public synchronized void add(int n) {<br>  if (n &lt; 0) {</p>
<pre><code>dec(-n);</code></pre><p>  } else {</p>
<pre><code>count += n;</code></pre><p>  }<br>}</p>
<p>public synchronized void dec(int n) {<br>  count += n;<br>}<br>}</p>
<pre><code>- 一旦线程执行到add()方法内部，说明它已经获取了当前实例的this锁。如果传入的n &lt; 0，将在add()方法内部调用dec()方法，会再一次重复的获取this锁。</code></pre></li>
<li><p>由于Java的线程锁是可重入锁，所以，获取锁的时候，不但要判断是否是第一次获取，还要记录这是第几次获取。每获取一次锁，记录+1，每退出synchronized块，记录-1，减到0的时候，才会真正释放锁。</p>
</li>
</ul>
</li>
<li><p>一个线程可以获取一个锁后，再继续获取另一个锁。</p>
<ul>
<li><p>获取多个锁可能出现死锁</p>
<ul>
<li>public void add(int m) {<br>synchronized(lockA) {       // 获得lockA的锁<br>this.value += m;<br>synchronized(lockB) {    // 获得lockB的锁<br>  this.another += m;<br>} // 释放lockB的锁<br>} // 释放lockA的锁<br>}</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>public void dec(int m) {<br>    synchronized(lockB) {        // 获得lockB的锁<br>        this.another -= m;<br>        synchronized(lockA) {   // 获得lockA的锁<br>            this.value -= m;<br>        } // 释放lockA的锁<br>    } // 释放lockB的锁<br>}</p>
<pre><code>    - 线程1和线程2如果分别执行add()和dec()方法时，可能会出现的情况
    - 线程1：进入add()，获得lockA；
    - 线程2：进入dec()，获得lockB。
    - 线程1：准备获得lockB，失败，等待中；
    - 线程2：准备获得lockA，失败，等待中。
    - 此时，两个线程各自持有不同的锁，然后各自试图获取对方手里的锁，造成了双方无限等待下去，便会造成死锁。

- 死锁发生后，没有任何机制能解除死锁，只能强制结束JVM进程。</code></pre><ul>
<li><p>避免死锁的方法</p>
<ul>
<li><p>线程获取锁的顺序要一致。</p>
<ul>
<li><p>例如：改写上面dec()方法如下<br>public void dec(int m) {<br>synchronized(lockA) { // 获得lockA的锁<br>this.value -= m;<br>synchronized(lockB) { // 获得lockB的锁<br>  this.another -= m;<br>} // 释放lockB的锁<br>} // 释放lockA的锁<br>}</p>
<ul>
<li>更改后出现的情况</li>
<li>线程1：进入add()，获得lockA；</li>
<li>线程2：进入dec()，准备获得lockA，失败，等待中；</li>
<li>线程1：获得lockB，调度完毕，释放锁</li>
<li>线程2：获得lockA</li>
<li>线程2：获得lockB，调度完毕，释放锁</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="多线程协调"><a href="#多线程协调" class="headerlink" title="多线程协调"></a>多线程协调</h3><ul>
<li><p>多线程协调运行的原则</p>
<ul>
<li>当条件不满足时，线程进入等待状态；当条件满足时，线程被唤醒，继续执行任务。</li>
</ul>
</li>
<li><p>重要方法</p>
<ul>
<li><p>wait(  )</p>
<ul>
<li><p>方法使用</p>
<ul>
<li><p>当前获得的线程锁.wait(  )</p>
<ul>
<li><p>如果是在synchronized关键字修饰的方法中就是获得的this对象作为锁</p>
<ul>
<li>即this.wait(  )</li>
</ul>
</li>
<li><p>如过是指明对象加锁方式</p>
<ul>
<li><p>synchronized(Counter.lock2) {<br>Counter.count -= 1;<br>}</p>
<ul>
<li>即Counter.lock2.wait(  )</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>方法作用</p>
<ul>
<li><p>使线程进入等待状态</p>
<ul>
<li>wait()方法不会返回，直到将来某个时刻，线程从等待状态被其他线程唤醒后，wait()方法才会返回继续执行下一条语句。</li>
</ul>
</li>
</ul>
</li>
<li><p>方法特点</p>
<ul>
<li><p>它不是一个普通的Java方法，而是定义在Object类的一个native方法，也就是由JVM的C代码实现的。</p>
</li>
<li><p>必须在synchronized块中才能调用wait()方法，因为wait()方法调用时，会释放线程获得的锁，wait()方法返回后，线程又会重新试图获得锁。</p>
<ul>
<li><p>为什么需要释放锁？</p>
<ul>
<li>例如因为当以当前对象this为锁的时候，如果在等待时不释放锁，将会一直占用，其他使用this对象加锁的方法也会一直等待不能执行</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>唤醒正在等待的线程</p>
<ul>
<li><p>notify(  )</p>
<ul>
<li><p>方法使用</p>
<ul>
<li><p>在使用wait()相同的锁对象上调用notify()方法。</p>
<ul>
<li>如果是this.wait()那么this.notify()</li>
</ul>
</li>
</ul>
</li>
<li><p>方法作用</p>
<ul>
<li><p>唤醒该线程锁对象正在wait()等待的线程，从而使得等待线程从wait()方法返回，并重新获取锁。</p>
<ul>
<li>如果有多个等待进程的话只会唤醒其中一个，而具体哪个依赖操作系统，有一定的随机性。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>notifyAll(  )</p>
<ul>
<li><p>方法作用</p>
<ul>
<li><p>唤醒所有当前线程锁对象正在wait()等待的线程</p>
<ul>
<li>通常来说，notifyAll()更安全。有些时候，如果我们的代码逻辑考虑不周，用notify()会导致只唤醒了一个线程，而其他线程可能永远等待下去醒不过来了。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><ul>
<li><p>在一个线程中，横跨若干方法调用，需要传递的对象，我们通常称之为上下文（Context），它是一种状态，可以是用户身份、任务信息等。</p>
</li>
<li><p>如何在一个线程内传递状态？</p>
<ul>
<li><p>参数传递</p>
<ul>
<li><p>public void process(User user) {<br>checkPermission(user);<br>doWork(user);<br>saveStatus(user);<br>sendResponse(user);<br>}</p>
<ul>
<li>但是往往一个方法又会调用其他很多方法，这样会导致User传递到所有地方，给每个方法增加一个context参数非常麻烦，而且有些时候，如果调用链有无法修改源码的第三方库，User对象就传不进去了。</li>
</ul>
</li>
</ul>
</li>
<li><p>使用ThreadLocal</p>
<ul>
<li>它可以在一个线程中传递同一个对象。</li>
</ul>
</li>
</ul>
</li>
<li><p>初始化ThreadLocal</p>
<ul>
<li><p>通常总是以静态字段初始化</p>
<ul>
<li><p>例如：static ThreadLocal<User> threadLocalUser = new ThreadLocal&lt;&gt;();</p>
</li>
<li><p>ThreadLocal相当于给每个线程都开辟了一个独立的存储空间，各个线程的ThreadLocal关联的实例互不干扰。</p>
<ul>
<li>可以把ThreadLocal看成一个全局Map&lt;Thread, Object&gt;：每个线程获取ThreadLocal变量时，总是使用Thread自身作为key：Object threadLocalValue = threadLocalMap.get(Thread.currentThread());</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>重要方法</p>
<ul>
<li><p>set( 初始化时指定的泛型类型对象 )通过设置一个所指实例关联到ThreadLocal中，在移除之前，所有方法都可以随时通过get方法获取到该实例。</p>
</li>
<li><p>get(  )通过set方法设置对象之后，使用该方法可以得到所设置对象。若未设置将返回空。</p>
<p>在任何地方都可以通过get来获取对象，就不需要参数传递了。有点像全局变量的使用。</p>
</li>
<li><p>remove(  )清除对象</p>
<ul>
<li>特别注意ThreadLocal一定要在finally中清除：</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>try {<br>    threadLocalUser.set(user);<br>    …<br>} finally {<br>    threadLocalUser.remove();<br>}</p>
<pre><code>    - 不清除的后果

        - 当前线程执行完相关代码后，很可能会被重新放入线程池中，如果ThreadLocal没有被清除，该线程执行其他代码时，会把上一次的状态带进去。

- 通过AutoCloseable接口配合try (resource) {...}结构保证释放

    - //例如，一个保存了当前用户名的ThreadLocal可以封装为一个UserContext对象</code></pre><p>public class UserContext implements AutoCloseable {<br>    static final ThreadLocal<String> ctx = new ThreadLocal&lt;&gt;();<br>    public UserContext(String user) {<br>        ctx.set(user);                                       //在构造函数中设置关联对象<br>    }<br>    public static String currentUser() {  //静态方法，方便调用<br>        return ctx.get();<br>    }<br>    @Override<br>    public void close() {<br>        ctx.remove();<br>    }<br>}</p>
<pre><code>- 使用的时候，我们借助try (resource) {...}结构</code></pre><p>try (var ctx = new UserContext(“Bob”)) {<br>    // 可任意调用UserContext.currentUser():<br>    String currentUser = UserContext.currentUser();<br>} // 在此自动调用UserContext.close()方法释放ThreadLocal关联对象<br>                - 这样就在UserContext中完全封装了ThreadLocal，外部代码在try (resource) {…}内部可以随时调用UserContext.currentUser()获取当前线程绑定的用户名。</p>
<ul>
<li><p>小结</p>
<ul>
<li>ThreadLocal表示线程的“局部变量”，它确保每个线程的ThreadLocal变量都是各自独立的；</li>
<li>ThreadLocal适合在一个线程的处理流程中保持上下文（避免了同一参数在所有方法中传递）；</li>
<li>使用ThreadLocal要用try … finally结构，并在finally中清除。</li>
</ul>
</li>
</ul>
<h3 id="java-util-concurrent包"><a href="#java-util-concurrent包" class="headerlink" title="java.util.concurrent包"></a>java.util.concurrent包</h3><ul>
<li><p>它提供了大量更高级的并发功能，能大大简化多线程程序的编写。</p>
</li>
<li><p>java.util.concurrent.locks包</p>
<ul>
<li><p>ReentrantLock</p>
<ul>
<li><p>ReentrantLock的作用</p>
<ul>
<li>用于替代synchronized加锁</li>
</ul>
</li>
<li><p>ReentrantLock也是可重入锁，一个线程可以多次获取同一个锁。</p>
</li>
<li><p>使用方法</p>
<ul>
<li><p>先使用ReentrantLock实例化一个Lock对象</p>
<ul>
<li>例子：  private final Lock lock = new ReentrantLock();      </li>
<li>最好使用final修饰一下，不然的话可以重新更换ReentrantLock对象，容易混淆</li>
</ul>
</li>
<li><p>再在需要加锁的语句使用固定格式</p>
<ul>
<li><p>Lock对象.lock()<br>try {<br>//需要加锁的语句块<br>} finally {<br>Lock对象.unlock();<br>}    </p>
<ul>
<li><p>必须使用try..finally语句，因为需要保证无论什么情况都能释放锁。</p>
<ul>
<li>如果加锁语句有需要捕获的异常就加上catch块</li>
</ul>
</li>
<li><p>lock( )获取锁</p>
</li>
<li><p>unlock( )释放锁</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>使用例子</p>
<ul>
<li><p>传统的synchronized代码</p>
<ul>
<li>public class Counter {<br>private int count;<br>public void add(int n) {<br>synchronized(this) {<br>count += n;<br>}<br>}<br>}</li>
</ul>
</li>
<li><p>用ReentrantLock替代，把代码改造</p>
<ul>
<li><p>public class Counter {<br>//创建ReentrantLock实例，上转为Lock并用final修饰<br>private final Lock lock = new ReentrantLock();<br>private int count;<br>public void add(int n) {<br>lock.lock();             //获取锁<br>try {<br>count += n;<br>} finally {                 //在finally中以保证无论加锁的语句中有没有异常都可以释放锁<br>lock.unlock();  //释放锁<br>}<br>}<br>}</p>
<ul>
<li>获取锁了之后到释放锁之前都是加锁的语句</li>
<li>ReentrantLock是Java代码实现的锁，我们就必须先获取锁，然后在必须finally中保证能够正确释放锁。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>和synchronized不同的是，ReentrantLock可以尝试获取锁</p>
<ul>
<li><p>if (lock.tryLock(1, TimeUnit.SECONDS)) {<br>try {<br>…<br>} finally {<br>lock.unlock();<br>}<br>}else{…}</p>
<ul>
<li><p>tryLock( 等待时间,时间单位)设置等待时间，如果在获取成功返回true，超过等待时间返回false。</p>
</li>
<li><p>代码在尝试获取锁的时候，最多等待1秒。如果1秒后仍未获取到锁，tryLock()返回false，程序就可以做一些额外处理，而不是无限等待下去。</p>
<ul>
<li>所以，使用ReentrantLock比直接使用synchronized更安全，线程在tryLock()失败的时候不会导致死锁。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Condition</p>
<ul>
<li><p>Condition的作用</p>
<ul>
<li><p>使用Condition对象来实现wait和notify的功能。</p>
<ul>
<li>Condition提供的await()、signal()、signalAll()原理和synchronized锁对象的wait()、notify()、notifyAll()是一致的，并且其行为也是一样的。</li>
</ul>
</li>
</ul>
</li>
<li><p>使用方法</p>
<ul>
<li><p>先使用ReentrantLock实例化一个Lock对象，再使用该Lock对象的newCondition()返回一个Condition实例；<br>获得一个绑定了Lock实例的Condition实例，然后便可对锁进行等待、唤醒操作。</p>
<ul>
<li>例子： private final Lock lock = new ReentrantLock();<br>private final Condition condition = lock.newCondition();</li>
</ul>
</li>
<li><p>await(  )会释放当前锁，进入等待状态；</p>
<ul>
<li><p>唤醒线程从await()返回后也需要重新获得锁。</p>
</li>
<li><p>与tryLock()类似，await()可以在等待指定时间后，如果还没有被其他线程通过signal()或signalAll()唤醒，可以自己醒来。</p>
<ul>
<li>if (condition.await(1, TimeUnit.SECOND)) {<br>// 被其他线程唤醒<br>} else {<br>// 指定时间内没有被其他线程唤醒<br>}</li>
</ul>
</li>
</ul>
</li>
<li><p>signal(  )随机会唤醒某个等待线程；</p>
</li>
<li><p>signalAll(  )会唤醒所有等待线程；</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>ReadWriteLock(悲观锁)</p>
<ul>
<li><p>ReadWriteLock的作用</p>
<ul>
<li><p>不使用ReadWriteLock会出现的问题</p>
<ul>
<li>ReentrantLock保证了只有一个线程可以执行临界区代码，但是有些时候，这种保护有点过头。如果只使用ReentrantLock，在多行读操作的时候也必须加锁，因为如果不加的话有可能在执行时调度其他写线程修改数据，导致读操作读取修改后的数据出现逻辑错误。但如果加锁将会无法使读操作多线程调用。</li>
</ul>
</li>
<li><p>所以会需要ReadWriteLock</p>
<ul>
<li><p>允许多个线程同时读，但只要有一个线程在写，其他线程就必须等待</p>
<ul>
<li>只允许一个线程写入（其他线程既不能写入也不能读取）；</li>
<li>没有写入时，多个线程允许同时读（提高性能）。</li>
</ul>
</li>
</ul>
</li>
<li><p>还有个潜在的问题</p>
<ul>
<li>如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，即读的过程中不允许写，这是一种悲观的读锁。</li>
</ul>
</li>
</ul>
</li>
<li><p>使用方法</p>
<ul>
<li><p>使用new ReentrantReadWriteLock()创建一个ReadWriteLock实例</p>
<ul>
<li>例如：private final ReadWriteLock rwlock = new ReentrantReadWriteLock();</li>
</ul>
</li>
<li><p>再使用得到的这个ReadWriteLock实例来创建读锁和写锁</p>
<ul>
<li><p>例如：  private final Lock rlock = rwlock.readLock();        //读锁<br>private final Lock wlock = rwlock.writeLock();     //写锁</p>
<ul>
<li>读锁和写锁不同</li>
</ul>
</li>
</ul>
</li>
<li><p>最后在需要加锁的地方按需求使用读锁或者写锁</p>
<ul>
<li><p>例如：<br>wlock.lock(); // 加写锁<br>try {<br>counts[index] += 1;<br>} finally {<br>wlock.unlock(); // 释放写锁<br>}</p>
<ul>
<li>读锁同理</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>StampedLock(乐观锁)</p>
<ul>
<li><p>StampedLock的作用</p>
<ul>
<li><p>StampedLock和ReadWriteLock相比</p>
<ul>
<li><p>改进之处在于：读的过程中也允许获取写锁后写入，因为读操作本身不会加锁，没有了锁的开销。但这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入，这种读锁是一种乐观锁。</p>
<ul>
<li>乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>使用方法</p>
<ul>
<li><p>先实例化一个StampedLock对象</p>
<ul>
<li>例如：private final StampedLock stampedLock = new StampedLock();</li>
</ul>
</li>
<li><p>使用写锁</p>
<ul>
<li><p>例如：<br>long stamp = stampedLock.writeLock(); // 获取写锁<br>try {<br>x += 200;<br>y += 200;<br>} finally {<br>stampedLock.unlockWrite(stamp); // 释放写锁<br>}</p>
<ul>
<li>writeLock( )获取一个long的写戳。</li>
<li>unlockWrite( 戳记 )将传入戳与锁状态匹配，如果匹配成功则释放锁，不然抛除异常。</li>
</ul>
</li>
</ul>
</li>
<li><p>使用乐观读锁</p>
<ul>
<li><p>例如：<br>long stamp = stampedLock.tryOptimisticRead(); // 使用乐观读锁，即对读不加锁   // 注意下面两行代码不是原子操作<br>double currentX = x; // 假设x,y = (100,200)此处已读取到x=100，但x,y可能被写线程修改为(300,400)<br>double currentY = y; // 此处已读取到y，若没有写入，读取是正确的(100,200)，若有写入，读取是错误的(100,400)<br>if (!stampedLock.validate(stamp)) { // 检查乐观读锁后是否有其他写锁发生<br>stamp = stampedLock.readLock(); // 获取一个悲观读锁<br>try {<br>currentX = x;                                       //这里使用悲观锁重新读取的应该是其他线程写入后的数据<br>currentY = y;<br>} finally {<br>stampedLock.unlockRead(stamp); // 释放悲观读锁<br>}<br>}<br>return Math.sqrt(currentX * currentX + currentY * currentY);<br>}</p>
<ul>
<li><p>乐观读锁</p>
<ul>
<li>tryOptimisticRead(  )获取一个long型乐观读戳。</li>
<li>validate( 戳记 )传入乐观读戳尝试匹配，如果读取过程中没有写入，读戳不变，匹配成功(true)。<br>若读取过程中有写入，读戳发生变化，匹配失败(false)。</li>
</ul>
</li>
<li><p>悲观读锁</p>
<ul>
<li>readLock(  )获取悲观读锁，返回一个long型悲观读戳。</li>
<li>unlockRead( 戳记 )将传入戳与锁状态匹配，如果匹配成功则释放锁，不然抛除异常。</li>
</ul>
</li>
<li><p>可以看到如果在读入过程中有写入，将会再次使用悲观锁重新读数据，防止数据逻辑错误。所以如果在写入比较频繁的场景使用乐观锁反而会降低性能！</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>使用场景</p>
<ul>
<li><p>适用条件是同一个数据，有大量线程读取，但仅有少数线程修改。</p>
<ul>
<li>例如，一个论坛的帖子，回复可以看做写入操作，它是不频繁的，但是，浏览可以看做读取操作，是非常频繁的，这种情况就可以使用ReadWriteLock。</li>
</ul>
</li>
</ul>
</li>
<li><p>StampedLock缺点</p>
<ul>
<li>一是代码更加复杂。</li>
<li>二是StampedLock是不可重入锁，不能在一个线程中反复获取同一个锁。</li>
</ul>
</li>
<li><p>StampedLock还提供了更复杂的将悲观读锁升级为写锁的功能，它主要使用在if-then-update的场景：<br>即先读，如果读的数据满足条件，就返回，如果读的数据不满足条件，再尝试写。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>线程安全的集合类</p>
<ul>
<li><ul>
<li>使用这些并发集合与使用非线程安全的集合类完全相同。</li>
<li>需要使用多线程时就使用对应的并发集合类即可。</li>
</ul>
</li>
</ul>
</li>
<li><p>java.util.concurrent.atomic包</p>
<ul>
<li><p>atomic包提供了一组原子操作的封装类。</p>
<ul>
<li><p>作用是</p>
<ul>
<li><p>使用java.util.concurrent.atomic提供的原子操作可以简化多线程编程。</p>
<ul>
<li>即一些常用的原子操作不用我们自己来设置加锁，可以直接使用现成的封装类来实现。</li>
</ul>
</li>
</ul>
</li>
<li><p>AtomicInteger为例</p>
<ul>
<li><p>它提供的主要操作有</p>
<ul>
<li>增加值并返回新值：int addAndGet(int delta)</li>
<li>加1后返回新值：int incrementAndGet()</li>
<li>获取当前值：int get()</li>
<li>用CAS方式设置：int compareAndSet(int expect, int update)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Atomic类是通过无锁（lock-free）的方式实现的线程安全（thread-safe）访问。它的主要原理是利用了CAS：Compare and Swap。</p>
</li>
<li><p>在高度竞争的情况下，还可以使用Java 8提供的LongAdder和LongAccumulator。</p>
</li>
</ul>
</li>
<li><p>使用线程池</p>
<ul>
<li><p>为什么需要使用线程池？</p>
<ul>
<li>Java语言虽然内置了多线程支持，启动一个新线程非常方便。<br>但是，创建线程需要操作系统资源（线程资源，栈空间等），频繁创建和销毁大量线程需要消耗大量时间。</li>
</ul>
</li>
<li><p>什么是线程池？</p>
<ul>
<li>复用一组线程，将很多小任务让这组线程来执行，而不是一个任务对应一个新线程。<br>这种能接收大量小任务并进行分发处理的就是线程池。</li>
</ul>
</li>
<li><p>线程池工作原理</p>
<ul>
<li>线程池内部维护了若干个线程，没有任务的时候，这些线程都处于等待状态。如果有新任务，就分配一个空闲线程执行。如果所有线程都处于忙碌状态，新任务要么放入队列等待，要么增加一个新线程进行处理。</li>
</ul>
</li>
<li><p>ExecutorService</p>
<ul>
<li><p>ExecutorService接口表示线程池</p>
</li>
<li><p>使用方法</p>
<ul>
<li>ExecutorService executor = Executors.newFixedThreadPool(3);<br>//即用该接口来接收不同类型的线程池。这里的是固定大小为3的线程池</li>
</ul>
</li>
<li><p>接口常用方法</p>
<ul>
<li><p>关闭线程池</p>
<ul>
<li><p>等待正在执行的任务先完成，然后再关闭。</p>
<ul>
<li>shutdown(  )</li>
</ul>
</li>
<li><p>立刻停止正在执行的任务。</p>
<ul>
<li>shutdownNow(  )</li>
</ul>
</li>
<li><p>等待指定的时间让线程池关闭。</p>
<ul>
<li>awaitTermination()</li>
</ul>
</li>
</ul>
</li>
<li><p>传入任务线程</p>
<ul>
<li>submit( 线程 )</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Executors</p>
<ul>
<li><p>ExecutorService只是接口，Java标准库提供的几个常用实现类有</p>
<ul>
<li><p>创建这些线程池的方法都被封装到Executors这个类中</p>
</li>
<li><p>FixedThreadPool：线程数固定的线程池</p>
<ul>
<li><p>ExecutorService es = Executors.newFixedThreadPool(4);//固定值大小为4</p>
<ul>
<li>一次可以执行4个任务</li>
</ul>
</li>
</ul>
</li>
<li><p>CachedThreadPool：线程数根据任务动态调整的线程池；</p>
<ul>
<li><p>ExecutorService es = Executors.newCachedThreadPool();</p>
<ul>
<li>直接创建跟任务数相同数量的线程池</li>
</ul>
</li>
<li><p>可以限制线程池大小</p>
<ul>
<li><p>想把线程池的大小限制在4～10个之间动态调整</p>
<ul>
<li>int min = 4;<br>int max = 10;<br>//注意没使用Executors来创建<br>ExecutorService es = new ThreadPoolExecutor(min, max,60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>SingleThreadExecutor：仅单线程执行的线程池。</p>
<ul>
<li>ExecutorService es = Executors.newSingleThreadExecutor();</li>
</ul>
</li>
</ul>
</li>
<li><p>其他类</p>
<ul>
<li><p>ScheduledThreadPool：需要定期反复执行的任务线程池</p>
<ul>
<li><p>ScheduledExecutorService ses = Executors.newScheduledThreadPool(4);<br>//依然使用Executors类创建，但使用的SingleThreadExecutor接口</p>
</li>
<li><p>只执行一次</p>
<ul>
<li><p>可以提交一次性任务，它会在指定延迟后只执行一次</p>
<ul>
<li>// 1秒后执行一次性任务:<br>ses.schedule(new Task(“one-time”), 1, TimeUnit.SECONDS);</li>
</ul>
</li>
</ul>
</li>
<li><p>重复执行</p>
<ul>
<li><p>任务以固定的每3秒执行</p>
<ul>
<li><p>// 2秒后开始执行定时任务，每3秒执行:<br>ses.scheduleAtFixedRate(new Task(“fixed-rate”), 2, 3, TimeUnit.SECONDS);</p>
</li>
<li><p>可能出现的问题</p>
<ul>
<li><p>在FixedRate模式下，假设每秒触发，如果某次任务执行时间超过1秒，后续任务会不会并发执行？</p>
<ul>
<li>如果此任务的任何执行时间超过其周期，则后续执行可能会延迟开始，但不会并发执行。</li>
</ul>
</li>
<li><p>如果任务抛出了异常，后续任务是否继续执行？</p>
<ul>
<li>如果任务的任何执行遇到异常，则将禁止后续任务的执行。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>任务以固定的3秒为间隔执行</p>
<ul>
<li>// 2秒后开始执行定时任务，以3秒为间隔执行:<br>ses.scheduleWithFixedDelay(new Task(“fixed-delay”), 2, 3, TimeUnit.SECONDS);</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>ForkJoin线程池</p>
<ul>
<li><p>ForkJoinPool的作用</p>
<ul>
<li><p>它可以执行一种特殊的任务：把一个大任务拆成多个小任务并行执行。</p>
</li>
<li><p>ForkJoin任务原理</p>
<ul>
<li>判断一个任务是否足够小，如果是，直接计算，否则，就分拆成几个小任务分别计算。这个过程可以反复“裂变”成一系列小任务。</li>
<li>任务类必须继承自RecursiveTask或RecursiveAction。</li>
</ul>
</li>
</ul>
</li>
<li><p>ForkJoin的大致使用</p>
<ul>
<li><p>先使用ForkJoinPool.commonPool()创建一个ForkJoinPool对象</p>
</li>
<li><p>创建一个任务对象</p>
<ul>
<li><p>任务类大致实现</p>
<ul>
<li><p>class SumTask extends RecursiveTask<Long> {<br>protected Long compute() {<br>//若任务足够小，那么执行计算，该处代码省略<br>//若任务不够小，按分裂要求“分裂”子任务:<br>SumTask subtask1 = new SumTask(…);<br>SumTask subtask2 = new SumTask(…);<br>// invokeAll会并行运行两个子任务:<br>invokeAll(subtask1, subtask2);<br>// 获得子任务的结果:<br>Long result1 =subtask1.join();<br>Long result2 =subtask2.join();<br>// 汇总结果:<br>return result1 + result2;<br>}<br>}</p>
<ul>
<li><p>invokeAll( 任务序列 )并行执行所有任务。</p>
</li>
<li><p>join(  )当计算完成时返回计算结果。</p>
<ul>
<li>也会自动调用任务里的compute方法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>再使用ForkJoinPool对象调用invoke( 任务对象 )调用任务</p>
<ul>
<li>调用任务对象后好像自动执行执行里面的compute方法</li>
</ul>
</li>
</ul>
</li>
<li><p>Fork/Join线程池在Java标准库中的应用</p>
<ul>
<li><p>java.util.Arrays.parallelSort(array)可以进行并行排序</p>
<ul>
<li>它的原理就是内部通过Fork/Join对大数组分拆进行并行排序，在多核CPU上就可以大大提高排序的速度。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Callable与Future</p>
<ul>
<li><p>Callable的作用</p>
<ul>
<li><p>和Runnable接口比，它多了一个返回值。<br>Callable接口是一个泛型接口，可以返回指定类型的结果。</p>
<ul>
<li>Runnable有个问题，它的方法没有返回值。如果任务需要一个返回结果，那么只能保存到变量，还要提供额外的方法读取，非常不便。</li>
<li>所以Runnable与Callable相比是不同类型的任务，根据需要选择。</li>
</ul>
</li>
</ul>
</li>
<li><p>Future的作用</p>
<ul>
<li><p>用来获得异步执行的结果。</p>
<ul>
<li>ExecutorService的submit()返回了一个Future类型。所以线程池调用传入任务线程后，可以用Future来接收返回结果。</li>
</ul>
</li>
<li><p>Future<V>接口表示一个未来可能会返回的结果，它定义的方法有</p>
<ul>
<li>get(  )：获取结果（可能会等待）</li>
<li>get(long timeout, TimeUnit unit)：获取结果，但只等待指定的时间；</li>
<li>cancel(boolean mayInterruptIfRunning)：取消当前任务；</li>
<li>isDone(  )：判断任务是否已完成。</li>
</ul>
</li>
</ul>
</li>
<li><p>使用实例</p>
<ul>
<li><p>ExecutorService executor = Executors.newFixedThreadPool(4);<br>// 定义任务，这个Task实现Callable接口并指定泛型<br>Callable<String> task = new Task();<br>// 为线程池提交任务并获得Future，Future类型取决于指定泛型<br>Future<String> future = executor.submit(task);<br>// 从Future获取异步执行返回的结果:<br>String result = future.get(); // 可能阻塞</p>
<ul>
<li>class Task implements Callable<String> {<br>public String call() throws Exception {//注意这里可能引发异常<br>return longTimeCalculation();<br>}<br>}</li>
<li>当我们提交一个Callable任务后，我们会同时获得一个Future对象，然后，我们在主线程某个时刻调用Future对象的get()方法，就可以获得异步执行的结果。在调用get()时，如果异步任务已经完成，我们就直接获得结果。如果异步任务还没有完成，那么get()会阻塞，直到任务完成后才返回结果。</li>
</ul>
</li>
</ul>
</li>
<li><p>小结</p>
<ul>
<li>对线程池传入一个Callable任务，可以获得Future对象，通过这个对象可以得到线程返回的结果。</li>
</ul>
</li>
</ul>
</li>
<li><p>CompletableFuture类</p>
<ul>
<li><p>使用CompletableFuture的原因</p>
<ul>
<li><p>使用Future会出现的问题</p>
<ul>
<li>使用Future获得异步执行结果时，要么调用阻塞方法get()，要么轮询看isDone()是否为true，这两种方法都不是很好，因为主线程也会被迫等待。</li>
</ul>
</li>
<li><p>CompletableFuture的好处</p>
<ul>
<li>它针对Future做了改进，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。</li>
</ul>
</li>
</ul>
</li>
<li><p>使用实例</p>
<ul>
<li><p>Lambda表达式相关的Consumer、Function、Predicate与Supplier的区别</p>
<ul>
<li><ul>
<li>public interface Consumer<T> {<br>void accept(T t);<br>}</li>
<li>public interface Function&lt;T, R&gt; {<br>R apply(T t);<br>}</li>
<li>public interface Supplier<T> {<br>T get();<br>}</li>
</ul>
</li>
</ul>
</li>
<li><p>public class Main {<br>public static void main(String[] args) throws Exception {<br>// 创建异步执行任务，指定泛型为返回数据类型<br>CompletableFuture<Double> cf = CompletableFuture.supplyAsync(Main::fetchPrice);<br>cf.thenAccept((result) -&gt; {                            // 如果执行成功,直接用Lambda语法整一个Consumer对象<br>  System.out.println(“price: “ + result);<br>});<br>cf.exceptionally((e) -&gt; {                                // 如果执行异常:<br>  e.printStackTrace();<br>  return null;<br>});<br>Thread.sleep(200);      // 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭<br>}</p>
</li>
</ul>
<p>static Double fetchPrice() {<br>  try {</p>
<pre><code>Thread.sleep(100);</code></pre><p>  } catch (InterruptedException e) {<br>  }<br>  if (Math.random() &lt; 0.3) {</p>
<pre><code>throw new RuntimeException(&quot;fetch price failed!&quot;);</code></pre><p>  }<br>  return 5 + Math.random() * 20;<br>}<br>}</p>
<pre><code>- 使用CompletableFuture.supplyAsync(Supplier&lt;U&gt; supplier)创建一个 CompletableFuture并指定泛型为任务返回值类型。

    - 实例中fetchPrice方法符合Supplier的无参有返，所以可以使用Lambda语法简化表达。</code></pre><p>CompletableFuture<String> cf = CompletableFuture.supplyAsync(new Supplier<String>() {</p>
<pre><code>@Override
public String get() {
    return Main.fetchPrice();
}</code></pre><p>  });    //实例中所表达和该表达同理</p>
<pre><code>    - 创建任务时注意任务的返回值类型，然后在创建的时候指定泛型为相同类型。

- 执行成功

    - thenAccept(Consumer&lt;? super T&gt; action)传入一个实现Consumer的对象设置执行成功后的操作，并将执行后的返回值传入Consumer对象作为参数。

- 执行失败

    - exceptionally( Function&lt;Throwable, ? extends T&gt; fn)传入一个实现Function的对象设置执行失败后的操作，并将执行后返回的Throwable对象作为参数，最后还会返回一个东东。

- 注意设置主线程暂停，防止提前关闭线程池导致线程没有执行完毕。</code></pre></li>
<li><p>CompletableFuture的优点</p>
<ul>
<li>异步任务结束时，会自动回调某个对象的方法；</li>
<li>异步任务出错时，会自动回调某个对象的方法；</li>
<li>主线程设置好回调后，不再关心异步任务的执行。</li>
</ul>
</li>
<li><p>CompletableFuture的串行执行和并行执行</p>
<ul>
<li><p>串行执行</p>
<ul>
<li><p>串行执行步骤</p>
<ul>
<li><p>使用CompletableFuture.supplyAsync(Supplier<U> supplier)创建第一个任务，执行完毕后会返回一个值。</p>
</li>
<li><p>然后使用 前一个任务对象.thenApplyAsync( Function&lt;? super T,? extends U&gt; fn)创建第二个任务，若第一个任务成功执行，他会使用第一个任务返回的值作为参数。该任务执行完毕后也回返回一个值。</p>
<ul>
<li>前一个任务对象.thenApplyAsync( Function&lt;? super T,? extends U&gt; fn)来创建一个在前一个任务之后执行的任务。<br>传入的参数是前一个对象的返回值。该任务也会返回值。</li>
</ul>
</li>
</ul>
</li>
<li><p>串行执行实例</p>
<ul>
<li>// 第一个任务:<br>CompletableFuture<String> cfQuery = CompletableFuture.supplyAsync(() -&gt; {<br>return queryCode(“中国石油”);                  //返回一个String值<br>});<br>// cfQuery成功后继续执行下一个任务，将上一个任务返回值作为参数<br>CompletableFuture<Double> cfFetch = cfQuery.thenApplyAsync((code) -&gt; {<br>return fetchPrice(code);                             //code为上一任务返回值。这里返回值为Double型<br>});<br>// cfFetch成功后打印结果:<br>cfFetch.thenAccept((result) -&gt; {                //最后打印第二次任务的返回值<br>System.out.println(“price: “ + result);<br>});</li>
</ul>
</li>
</ul>
</li>
<li><p>并行执行</p>
<ul>
<li><p>使用CompletableFuture.supplyAsync(Supplier<U> supplier)创建多个任务就是并行任务。</p>
<ul>
<li><p>CompletableFuture<Object> anyOf(CompletableFuture&lt;?&gt;… cfs)若传入任务中任一执行完毕返回值，那么该方法将该完成任务返回为CompletableFuture<Object>对象。</p>
<ul>
<li>使用场景：新建多个查找任务，有其中一个查找成功就继续往下执行。<br>//这种场景先用到了并行执行，然后再用到了串行执行。</li>
</ul>
</li>
<li><p>CompletableFuture<Void> allOf(CompletableFuture&lt;?&gt;… cfs)需全部任务执行完毕返回CompletableFuture<Void>(注意首字符大写)对象。该对象没有存储值。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>小结</p>
<ul>
<li><p>CompletableFuture可以指定异步处理流程</p>
<ul>
<li>thenAccept()处理正常结果；</li>
<li>exceptional()处理异常结果；</li>
<li>thenApplyAsync()用于串行化另一个CompletableFuture；</li>
<li>anyOf()和allOf()用于并行化多个CompletableFuture。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Maven基础"><a href="#Maven基础" class="headerlink" title="Maven基础"></a>Maven基础</h2><h3 id="Maven是什么？"><a href="#Maven是什么？" class="headerlink" title="Maven是什么？"></a>Maven是什么？</h3><ul>
<li><p>Maven就是是专门为Java项目打造的管理和构建工具，它的主要功能有</p>
<ul>
<li><p>提供了一套标准化的项目结构；</p>
</li>
<li><p>提供了一套标准化的构建流程（编译，测试，打包，发布……）；</p>
</li>
<li><p>提供了一套依赖管理机制。</p>
<ul>
<li><p>在项目描述文件pom.xml中声明依赖后，会自动解析将声明依赖的相关依赖也一并加入，不必手动添加。</p>
</li>
<li><p>Maven工作原理相关</p>
<ul>
<li><p>Maven如何知道从何处下载所需的依赖？也就是相关的jar包？</p>
<ul>
<li>答案是Maven维护了一个中央仓库，所有第三方库将自身的jar以及相关信息上传至中央仓库，Maven就可以从中央仓库把所需依赖下载到本地。</li>
</ul>
</li>
<li><p>Maven并不会每次都从中央仓库下载jar包。一个jar包一旦被下载过，就会被Maven自动缓存在本地目录（用户主目录的.m2目录），所以，除了第一次编译时因为下载需要时间会比较慢，后续过程因为有本地缓存，并不会重复下载相同的jar包。</p>
<ul>
<li>某个jar包一旦被Maven下载过，即可永久地安全缓存在本地。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Maven项目结构"><a href="#Maven项目结构" class="headerlink" title="Maven项目结构"></a>Maven项目结构</h3><ul>
<li><p>一个使用Maven管理的普通的Java项目，它的目录结构默认如</p>
<ul>
<li><ul>
<li><p>项目的根目录a-maven-project是项目名</p>
</li>
<li><p>src目录</p>
<ul>
<li><p>main目录</p>
<ul>
<li>存放Java源码的目录是src/main/java</li>
<li>存放资源文件的目录是src/main/resources</li>
</ul>
</li>
<li><p>test目录</p>
<ul>
<li>存放测试源码的目录是src/test/java</li>
<li>存放测试资源的目录是src/test/resources</li>
</ul>
</li>
</ul>
</li>
<li><p>它有一个项目描述文件pom.xml</p>
<ul>
<li><p>Maven依赖管理</p>
<ul>
<li><p>一个Maven工程就是由groupId，artifactId和version作为唯一标识。</p>
<ul>
<li><p>groupId类似于Java的包名，通常是公司或组织名称</p>
</li>
<li><p>artifactId类似于Java的类名</p>
</li>
<li><p>version表示版本</p>
</li>
<li><p>我们在引用其他第三方库的时候，也是通过这3个变量确定。</p>
<ul>
<li>例如，添加依赖commons-logging：</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><dependencies>     //使用<dependencies>声明一个存放依赖的依赖块<br><dependency>        //使用<dependency>声明一个依赖<br>    <groupId>commons-logging</groupId><br>    <artifactId>commons-logging</artifactId><br>    <version>1.2</version><br></dependency><br></dependencies></p>
<pre><code>- 依赖关系

    - 添加依赖时需使用  &lt;scope&gt;依赖关系&lt;/scope&gt;  声明依赖的依赖关系。

        - 例如：</code></pre><dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter-api</artifactId>
    <version>5.3.2</version>
    <scope>test</scope>
</dependency>

<pre><code>            - 编译时需要用到该jar包（默认）

                - compile

                    - 示例依赖：    commons-logging

            - 编译Test时需要用到该jar包

                - test

                    - 示例依赖：    junit

            - 编译时不需要，但运行时需要用到

                - runtime

                    - 示例依赖：    mysql

            - 编译时需要用到，但运行时由JDK或某个服务器提供

                - provided

                    - 示例依赖：    servlet-api

- 所有编译、打包生成的文件都放在target目录里</code></pre><ul>
<li><p>小结</p>
<ul>
<li>Maven使用pom.xml定义项目内容，并使用预设的目录结构；</li>
<li>在Maven中声明一个依赖项可以自动下载并导入classpath；</li>
<li>Maven使用groupId，artifactId和version唯一定位一个依赖。</li>
</ul>
</li>
</ul>
<h3 id="Maven构建流程"><a href="#Maven构建流程" class="headerlink" title="Maven构建流程"></a>Maven构建流程</h3><ul>
<li><p>Lifecycle和Phase</p>
<ul>
<li><p>什么是Maven的生命周期（lifecycle）？</p>
<ul>
<li><p>Maven的生命周期由一系列阶段（phase）构成。</p>
<ul>
<li>执行一个phase又会触发一个或多个goal</li>
</ul>
</li>
<li><p>更好理解的方式</p>
<ul>
<li>ifecycle相当于Java的package，它包含一个或多个phase；</li>
<li>phase相当于Java的class，它包含一个或多个goal；</li>
<li>goal相当于class的method，它其实才是真正干活的。</li>
</ul>
</li>
</ul>
</li>
<li><p>指定执行</p>
<ul>
<li><p>指定phase</p>
<ul>
<li><p>mvn  <phase></p>
<ul>
<li>Maven就会根据phase自动确定相关lifecycle，它会从lifecycle开始一直运行到这个phase为止。</li>
</ul>
</li>
<li><p>指定多个phase</p>
<ul>
<li><p>mvn <phase>  <phase>…(多个phase可以来自不同lifecycle)</p>
<ul>
<li>同样，Maven根据phase自动确定lifecycle并执行到指定phase为止，执行完第一个后，开始执行第二个，以此类推。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>指定goal(极少数)</p>
<ul>
<li><p>mvn  <goal></p>
</li>
<li><p>goal的命名总是abc:xyz这种形式。</p>
<ul>
<li>例如：Phase                          Goal<br>test                    compiler:testCompile<pre><code>surefire:test </code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>在实际开发过程中，经常使用的命令有 </p>
<ul>
<li><p>mvn clean：清理所有生成的class和jar；</p>
<ul>
<li>clean：清理</li>
</ul>
</li>
<li><p>mvn clean compile：先清理，再执行到compile；</p>
<ul>
<li>compile：编译</li>
</ul>
</li>
<li><p>mvn clean test：先清理，再执行到test，因为执行test前必须执行compile，所以这里不必指定compile；</p>
<ul>
<li>test：运行测试</li>
</ul>
</li>
<li><p>mvn clean package：先清理，再执行到package。</p>
<ul>
<li>package：打包</li>
</ul>
</li>
</ul>
</li>
<li><p>小结</p>
<ul>
<li>使用Maven构建项目就是执行lifecycle，执行到指定的phase为止。</li>
<li>每个phase会执行自己默认的一个或多个goal。</li>
<li>goal是最小任务单元。</li>
</ul>
</li>
</ul>
</li>
<li><p>构建原理</p>
<ul>
<li><p>通过phase调用插件</p>
<ul>
<li><p>以compile这个phase为例。<br>执行：mvn compile</p>
<ul>
<li>Maven将执行compile这个phase，这个phase会调用compiler插件执行关联的compiler:compile这个goal。</li>
</ul>
</li>
<li><p>实际上，执行每个phase，都是通过某个插件（plugin）来执行的，Maven本身其实并不知道如何执行phase，它只是负责找到对应的插件，然后执行默认的goal来完成编译。</p>
<ul>
<li>使用Maven，实际上就是配置好需要使用的插件，然后通过phase调用它们。</li>
</ul>
</li>
</ul>
</li>
<li><p>Maven内置的一些常用的标准插件</p>
<ul>
<li><ul>
<li>Maven自带的标准插件无需声明。</li>
</ul>
</li>
</ul>
</li>
<li><p>自定义插件</p>
<ul>
<li>使用自定义插件的时候，需要在pom.xml中声明。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="模块管理"><a href="#模块管理" class="headerlink" title="模块管理"></a>模块管理</h3><ul>
<li><p>Maven支持模块化管理，可以把一个大项目拆成几个模块</p>
<ul>
<li>可以通过继承在parent的pom.xml统一定义重复配置；</li>
<li>可以通过<modules>编译多个模块。</li>
</ul>
</li>
</ul>
<h3 id="mvnw-Maven-Wrapper"><a href="#mvnw-Maven-Wrapper" class="headerlink" title="mvnw(Maven Wrapper)"></a>mvnw(Maven Wrapper)</h3><ul>
<li><p>什么是mvnw？</p>
<ul>
<li>Maven Wrapper就是给一个项目提供一个独立的，指定版本的Maven给它使用，而其他项目不受影响。</li>
<li>Maven Wrapper的另一个作用是把项目的mvnw、mvnw.cmd和.mvn提交到版本库中，可以使所有开发人员使用统一的Maven版本。</li>
</ul>
</li>
<li><p>为什么需要mvnw？</p>
<ul>
<li>因为所有项目默认使用全局安装的Maven版本，有些项目可能不适用这个版本，所以需要指定Maven版本。</li>
</ul>
</li>
<li><p>安装Maven Wrapper后把mvn命令改成mvnw就可以使用跟项目关联的Maven。</p>
</li>
</ul>
<h3 id="发布Artifact"><a href="#发布Artifact" class="headerlink" title="发布Artifact"></a>发布Artifact</h3></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">JG</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://unomisa.github.io/2020/08/26/java/">https://unomisa.github.io/2020/08/26/java/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://unomisa.github.io" target="_blank">J‘G Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/unomisa/photo-cloud/blogImg/U%7BK(I%5DFXA1FFAG)G%5BGEV$02.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2020/08/27/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><img class="prev-cover" data-src="https://cdn.jsdelivr.net/gh/unomisa/photo-cloud/blogImg/U%7BK(I%5DFXA1FFAG)G%5BGEV$02.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java基础知识</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By JG</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">欢迎来到菌菇的博客🦋</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script>if (document.getElementsByClassName('mermaid').length) {
  loadScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js',function () {
    mermaid.initialize({
      theme: 'default',
  })
})
}</script></body></html>