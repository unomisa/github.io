<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java进阶知识 | Lunomi Blog</title><meta name="description" content="java的较难理解的知识"><meta name="keywords" content="java 进阶"><meta name="author" content="Lunomi"><meta name="copyright" content="Lunomi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://unomisa.github.io/Java%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Java进阶知识"><meta property="og:url" content="https://unomisa.github.io/Java%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"><meta property="og:site_name" content="Lunomi Blog"><meta property="og:description" content="java的较难理解的知识"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/unomisa/photo-cloud/blogImg/7.png"><meta property="article:published_time" content="2020-09-06T14:37:11.839Z"><meta property="article:modified_time" content="2020-09-08T09:24:21.714Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '4.2.1',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '天',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
      const now = new Date()
      const expiryDay = ttl * 86400000
      const item = {
        value: value,
        expiry: now.getTime() + expiryDay,
      }
      localStorage.setItem(key, JSON.stringify(item))
    },
  
  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-09-08 17:24:21'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/unomisa/unomisa.github.io/mycss/my.css"><link rel="stylesheet" href="/self/duotone.css"><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="https://cdn.jsdelivr.net/gh/unomisa/photo-cloud/blogImg/8.jpg" onerror="onerror=null;src='https://pic1.zhimg.com/v2-6a23112368d020c4b353e8ae991716e0_b.webp'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">5</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">2</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">1</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="color"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java异常"><span class="toc-number">1.</span> <span class="toc-text">Java异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java异常的特点"><span class="toc-number">1.1.</span> <span class="toc-text">Java异常的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java异常的使用"><span class="toc-number">1.2.</span> <span class="toc-text">Java异常的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用JDK-Logging"><span class="toc-number">1.3.</span> <span class="toc-text">使用JDK Logging</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用Commons-Logging"><span class="toc-number">1.4.</span> <span class="toc-text">使用Commons Logging</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#反射"><span class="toc-number">2.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#反射的特点"><span class="toc-number">2.1.</span> <span class="toc-text">反射的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#反射涉及到四个核心类"><span class="toc-number">2.2.</span> <span class="toc-text">反射涉及到四个核心类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Class类"><span class="toc-number">2.3.</span> <span class="toc-text">Class类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Class类使用"><span class="toc-number">2.3.1.</span> <span class="toc-text">Class类使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#字段关于"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">字段关于</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法关于"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">方法关于</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#继承关系"><span class="toc-number">2.3.1.3.</span> <span class="toc-text">继承关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动态代理"><span class="toc-number">2.3.1.4.</span> <span class="toc-text">动态代理</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#注解"><span class="toc-number">3.</span> <span class="toc-text">注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#注解的特点"><span class="toc-number">3.1.</span> <span class="toc-text">注解的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#定义注解："><span class="toc-number">3.2.</span> <span class="toc-text">定义注解：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#读取注解"><span class="toc-number">3.3.</span> <span class="toc-text">读取注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#元注解"><span class="toc-number">3.3.1.</span> <span class="toc-text">元注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用注解"><span class="toc-number">3.3.2.</span> <span class="toc-text">使用注解</span></a></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/unomisa/photo-cloud/blogImg/7.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Lunomi Blog</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Java进阶知识</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-09-06T14:37:11.839Z" title="发表于 2020-09-06 22:37:11">2020-09-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-09-08T09:24:21.714Z" title="更新于 2020-09-08 17:24:21">2020-09-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="Java异常"><a href="#Java异常" class="headerlink" title="Java异常"></a>Java异常</h1><h2 id="Java异常的特点"><a href="#Java异常的特点" class="headerlink" title="Java异常的特点"></a>Java异常的特点</h2><ol>
<li><p><strong>异常是一种<code>class</code>，因此它本身带有类型信息。</strong><br>异常可以在<strong>任何地方抛出</strong>，但只需要在<strong>上层捕获</strong>，这样就和方法调用分离了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>String s = processFile(“C:\\test.txt”); <span class="hljs-comment">//操作文件，若出现异常将抛出</span><br><span class="hljs-comment">// ok:</span><br>&#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br><span class="hljs-comment">// file not found:</span><br>&#125; <span class="hljs-keyword">catch</span> (SecurityException e) &#123;<br><span class="hljs-comment">// no read permission:</span><br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br><span class="hljs-comment">// io error:</span><br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><span class="hljs-comment">// other error:</span><br>&#125;<span class="hljs-comment">//注意以上catch的先后</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>存在多个catch的时候，catch的顺序非常重要：子类必须写在前面。</p>
</blockquote>
</li>
<li><p><strong>异常是<code>class</code>，因此有继承关系如下：</strong></p>
<p><code>Throwable</code>是异常体系的根，它继承自<code>Object</code>。</p>
<p><code>Throwable</code>有两个体系：<code>Error</code>和<code>Exception</code>。</p>
<ul>
<li><p><code>Error</code>表示<strong>严重</strong>的错误，程序对此一般无能为力。<br>例如：<br>①OutOfMemoryError：内存耗尽</p>
<p>②NoClassDefFoundError：无法加载某个Class</p>
<p>③StackOverflowError：栈溢出</p>
</li>
<li><p><code>Exception</code>表示运行时的错误，它可以被捕获并处理。</p>
<p>某些异常是应用程序逻辑处理的一部分，应该捕获并处理。<br>例如：</p>
<p>①NumberFormatException：数值类型的格式错误</p>
<p>②FileNotFoundException：未找到文件</p>
<p>③SocketException：读取网络失败</p>
<ul>
<li><p><code>Exception</code>分为两大类</p>
<p>①<code>RuntimeException</code>以及它的子类；</p>
<p>②非<code>RuntimeException</code>（包括<code>IOException、ReflectiveOperationException</code>等等）</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>需要捕获的异常与不需要捕获的异常</strong></p>
<p>① 必须捕获的异常，包括<code>Exception</code>及其子类，但不包括RuntimeException及其子类，这种类型的异常称为<code>Checked Exception</code>。 </p>
<p>② 不需要捕获的异常，包括<code>Error</code>及其子类，<code>RuntimeException</code>及其子类。</p>
</li>
</ol>
<h2 id="Java异常的使用"><a href="#Java异常的使用" class="headerlink" title="Java异常的使用"></a>Java异常的使用</h2><ol>
<li><p><strong>在方法定义的时候，使用<code>throws Xxx</code>表示该方法可能抛出的异常类型。</strong><br>调用方在调用的时候，必须<strong>强制捕获</strong>这些异常，否则编译器会<strong>报错</strong>。<br>例如：</p>
<p><code>String.getBytes(String)</code>方法定义是：</p>
<pre><code>public byte[] getBytes(String charsetName) throws UnsupportedEncodingException {
    ...
}
static byte[] toGBK(String s) {      //toGBK方法中调用getBytes( )
    return s.getBytes(&quot;GBK&quot;);
}</code></pre><p>调用方<code>toGBK()</code><strong>没有捕获</strong>可能抛出的异常，会出现<strong>编译错误</strong></p>
<p>我们也可以不捕获它，而是在方法定义处用<code>throws</code>表示<code>toGBK()</code>方法可能会抛出<code>UnsupportedEncodingException</code>，就可以让<code>toGBK()</code>方法通过编译器检查：</p>
<pre><code>static byte[] toGBK(String s) throws UnsupportedEncodingException {
return s.getBytes(&quot;GBK&quot;);
}</code></pre><blockquote>
<p>同理，调用toGBK( )方法的方法也需要处理会抛出的异常，main( )方法也是。</p>
</blockquote>
</li>
<li><p><strong>Java的<code>try ... catch</code>机制还提供了<code>finally</code>语句，<code>finally</code>语句块保证有无错误都会执行。</strong></p>
<p>可见，<code>finally</code>是用来保证一些代码必须执行的。</p>
<p>▷ <code>finally</code>语句不是必须的，可写可不写；</p>
<p>▷ <code>finally</code>总是<strong>最后执行</strong>。</p>
</li>
<li><p><strong>一个<code>catch</code>语句也可以匹配多个非继承关系的异常。</strong></p>
<p>如果两个非继承关系的异常处理相同，那么可以用<code>&#39;|&#39;</code>将他们合并在同一个catch语句中</p>
<p>例如： </p>
<pre><code>catch (IOException e) {
    System.out.println(&quot;Bad input&quot;);
} 
catch (NumberFormatException e) {
    System.out.println(&quot;Bad input&quot;);
}
catch (IOException | NumberFormatException e) { // IOException或NumberFormatException
    System.out.println(&quot;Bad input&quot;);
}</code></pre></li>
<li><p><strong>通过<code>printStackTrace()</code>可以打印出方法的调用栈。</strong></p>
<p>使用实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br>    process1();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process1</span><span class="hljs-params">()</span> </span>&#123;<br>    process2();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process2</span><span class="hljs-params">()</span> </span>&#123;<br>    Integer.parseInt(<span class="hljs-keyword">null</span>); <span class="hljs-comment">// 会抛出NumberFormatException</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果类似：</p>
<pre><code>java.lang.NumberFormatException: null
    at java.base/java.lang.Integer.parseInt(Integer.java:614)
    at java.base/java.lang.Integer.parseInt(Integer.java:770)
    at Main.process2(Main.java:16)
    at Main.process1(Main.java:12)
    at Main.main(Main.java:5)</code></pre><p><code>printStackTrace()</code>对于调试错误非常有用，上述信息表示：<code>NumberFormatException</code>是在<code>java.lang.Integer.parseInt</code>方法中被抛出的。</p>
<p>从下往上看，调用层次依次是：</p>
<p>①main()调用process1()；<br>②process1()调用process2()；<br>③process2()调用Integer.parseInt(String)；<br>④Integer.parseInt(String)调用Integer.parseInt(String, int)。</p>
</li>
<li><p><strong>在<code>catch</code>中抛出异常，不会影响<code>finally</code>的执行：JVM会先执行<code>finally</code>，然后抛出异常。</strong></p>
<p><code>finally</code>抛出异常后，原来在catch中准备抛出的异常就<strong>“消失”</strong>了，因为只能抛出一个异常。<br>没有被抛出的异常称为<strong>“被屏蔽”</strong>的异常（Suppressed Exception）。</p>
<p>通常不要在<code>finally</code>中抛出异常。<br>若在<code>finally</code>中抛出异常，应该原始异常加入到原有异常中(方法是先用变量保存原始异常，然后调用<code>Throwable.addSuppressed()</code>，把原始异常添加进来)。<br>调用方可通过<code>Throwable.getSuppressed()</code>获取所有添加的<code>Suppressed Exception</code>。<br>如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    Exception origin = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        System.out.println(Integer.parseInt(<span class="hljs-string">"abc"</span>));<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        origin = e;<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        Exception e = <span class="hljs-keyword">new</span> IllegalArgumentException();<br>        <span class="hljs-keyword">if</span> (origin != <span class="hljs-keyword">null</span>) &#123;<br>            e.addSuppressed(origin);<br>        &#125;<br>        <span class="hljs-keyword">throw</span> e;<br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="使用JDK-Logging"><a href="#使用JDK-Logging" class="headerlink" title="使用JDK Logging"></a>使用JDK Logging</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.logging.Level;<br><span class="hljs-keyword">import</span> java.util.logging.Logger;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Logger logger = Logger.getGlobal();<br>        logger.info(<span class="hljs-string">"start process..."</span>);<br>        logger.warning(<span class="hljs-string">"memory is running out..."</span>);<br>        logger.fine(<span class="hljs-string">"ignored."</span>);<br>        logger.severe(<span class="hljs-string">"process will be terminated..."</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>输出如下：    </p>
<pre><code>Jun 15, 2020 2:12:55 AM Hello main
INFO: start process...
Jun 15, 2020 2:12:55 AM Hello main
WARNING: memory is running out...
Jun 15, 2020 2:12:55 AM Hello main
SEVERE: process will be terminated...</code></pre><p>4条日志，只打印了3条，<code>logger.fine()</code>没有打印。<br>这是因为，日志的输出可以<strong>设定级别</strong>。<br>JDK的Logging定义了7个日志级别，从<strong>严重</strong>到<strong>普通</strong>：<br>①SEVERE<br>②WARNING<br>③INFO<br>④CONFIG<br>⑤FINE<br>⑥FINER<br>⑦FINEST</p>
<p>默认级别是<strong>INFO</strong>，因此，INFO级别以下的日志，不会被打印出来。</p>
</li>
</ul>
<blockquote>
<p>使用日志级别的好处在于，调整级别，就可以屏蔽掉很多调试相关的日志输出。</p>
</blockquote>
<h2 id="使用Commons-Logging"><a href="#使用Commons-Logging" class="headerlink" title="使用Commons Logging"></a>使用Commons Logging</h2><p>和Java标准库提供的日志不同，<code>Commons Logging</code>是一个<strong>第三方日志库</strong>，它是由Apache创建的日志模块。</p>
<ol>
<li><p><strong>它可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统。</strong><br>默认情况下，<code>Commons Loggin</code>自动搜索并使用<code>Log4j</code>（Log4j是另一个流行的日志系统）。<br>如果没有找到<code>Log4j</code>，再使用<code>JDK Logging</code>。</p>
<blockquote>
<p>利用JVM<strong>动态加载class</strong>的特性，我们才能在运行期根据条件加载不同的实现类。<br>例如，Commons Logging总是优先使用Log4j，只有当Log4j不存在时，才使用JDK的logging。</p>
</blockquote>
</li>
<li><p><strong>使用Commons Logging只需要和两个类打交道，并且只有两步：</strong></p>
<p>第一步，通过<code>LogFactory</code>获取<code>Log</code>类的实例； </p>
<p>第二步，使用<code>Log</code>实例的方法打日志。</p>
<p>Commons Logging的日志方法，例如<code>info()</code>。</p>
<p>除了标准的<code>info(String)</code>外，还提供了一个非常有用的重载方法：<code>info(String, Throwable)</code>，这使得记录异常更加简单：<br>例如：</p>
<pre><code>try {
...
} catch (Exception e) {
log.error(&quot;got exception!&quot;, e);
}</code></pre></li>
</ol>
<hr>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="反射的特点"><a href="#反射的特点" class="headerlink" title="反射的特点"></a>反射的特点</h2><ol>
<li><p><strong>通过<code>Class</code>实例获取<code>class</code>信息的方法称为反射（Reflection），即程序在运行期可以拿到一个对象的所有信息。</strong></p>
</li>
<li><p><strong>反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。</strong></p>
</li>
</ol>
<h2 id="反射涉及到四个核心类"><a href="#反射涉及到四个核心类" class="headerlink" title="反射涉及到四个核心类"></a>反射涉及到四个核心类</h2><ul>
<li>java.lang.<strong>Class.java</strong>：类对象；</li>
<li>java.lang.reflect.<strong>Constructor.java</strong>：类的构造器对象；</li>
<li>java.lang.reflect.<strong>Method.java</strong>：类的方法对象；</li>
<li>java.lang.reflect.<strong>Field.java</strong>：类的属性对象；</li>
</ul>
<h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><ol>
<li><p><strong><code>Class</code>类型是一个名叫<code>Class</code>的<code>class</code>。</strong></p>
</li>
<li><p><strong>Class实例是JVM内部创建的，查看JDK源码，可以发现Class类的构造方法是<code>private</code>，<u>只有JVM能创建Class实例</u>，自己的Java程序是无法创建Class实例的。</strong></p>
</li>
<li><p><strong>JVM为每个加载的<code>class</code>都创建了对应的Class实例，并在实例中保存了该<code>class</code>的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等。</strong></p>
</li>
</ol>
<p>因此，若获取了某个Class实例，我们就可以通过这个Class实例获取到该实例对应的class的<strong>所有信息</strong>。</p>
<h3 id="Class类使用"><a href="#Class类使用" class="headerlink" title="Class类使用"></a>Class类使用</h3><ol>
<li><p><strong>如何获取一个<code>class</code>的Class实例？有三个方法：</strong></p>
<p><strong>方法一：</strong>直接通过一个class的<strong>静态变量</strong><code>class</code>获取：</p>
<pre><code>Class cls = String.class;</code></pre><p><strong>方法二：</strong>如果我们有一个<strong>实例变量</strong>，可以通过该实例变量提供的<code>getClass()</code>方法获取：</p>
<pre><code>String s = &quot;Hello&quot;;
Class cls = s.getClass();</code></pre><p><strong>方法三：</strong>如果知道一个<code>class</code>的完整类名，可以通过静态方法<code>Class.forName()</code>获取：</p>
<pre><code>Class cls = Class.forName(&quot;java.lang.String&quot;);</code></pre></li>
<li><p><strong>获取父类的Class</strong></p>
<p>有了Class实例，我们还可以获取它的父类的Class：</p>
<pre><code>Class i = Integer.class;
Class n = i.getSuperclass();
System.out.println(n);
Class o = n.getSuperclass();
System.out.println(o);
System.out.println(o.getSuperclass());</code></pre><p>输出为：</p>
<pre><code>class java.lang.Number
class java.lang.Object
null</code></pre></li>
<li><p><strong>获取父接口的Class</strong></p>
<div class="note info"><p>对所有<strong>interface</strong>的Class调用<code>getSuperclass()</code>返回的是<strong>null</strong>，获取接口的父接口要用<code>getInterfaces()</code>。</p>
</div>
</li>
<li><p><strong>获取interface</strong></p>
<p>由于一个类可能实现一个或多个接口，通过Class我们就可以查询到实现的接口类型。<br>例如，查询<strong>Integer</strong>实现的接口：</p>
<pre><code>Class s = Integer.class;
Class[] is = s.getInterfaces();//接口可能有多个，所以用数组存储
for (Class i : is) {
    System.out.println(i);
}</code></pre><p>输出为：</p>
<pre><code>interface java.lang.Comparable</code></pre><p>特别注意：<code>getInterfaces()</code>只返回当前类直接实现的接口类型，并不包括其父类实现的接口类型。</p>
</li>
</ol>
<h4 id="字段关于"><a href="#字段关于" class="headerlink" title="字段关于"></a>字段关于</h4><ol start="5">
<li><p><strong>获取字段信息。</strong></p>
<p>Class类提供了以下几个方法来获取字段：</p>
<p>▷ <code>Field getField(name)</code>：根据字段名获取某个public的FieldF（包括父类）。<br>▷ <code>Field getDeclaredField(name)</code>：根据字段名获取F当前类的某个FieFld（不包括父类）。<br>▷ <code>Field[] getFields()</code>：获取所有public的Field（包括父类）。<br>▷ <code>Field[] getDeclaredFields()</code>：获取当前类的所有Field（不包括父类）。</p>
<p>Field对象包含了一个字段的所有信息：</p>
<p>使用<code>Field</code>对象调用：</p>
<p>▷ <code>getName()</code>：返回字段名称，例如，”name”；<br>▷ <code>getType()</code>：返回字段类型，也是一个Class实例，例如，String.class；<br>▷ <code>getModifiers()</code>：返回字段的修饰符，它是一个int，不同的bit表示不同的含义。<br>⁢⁢⁢⁢可以通过返回的<code>int</code>值的二进制来判断各个属性的值。<br>⁢⁢⁢⁢⁢以<code>String</code>类的<code>value</code>字段为例，它的定义是：</p>
<pre><code>public final class String {
    private final byte[] value;
    }</code></pre><p>⁢⁢⁢⁢使用反射获取该字段的信息：</p>
<pre><code>Field f = String.class.getDeclaredField(&quot;value&quot;);  //利用反射拿到一个实例 f  ↓
f.getName(); // &quot;value&quot;
f.getType(); // class [B 表示byte[]类型
int m = f.getModifiers();//m=18=10010，对应下面各个属性的真假↙
Modifier.isFinal(m); // true
Modifier.isPublic(m); // false
Modifier.isProtected(m); // false
Modifier.isPrivate(m); // true
Modifier.isStatic(m); // false</code></pre></li>
<li><p><strong>获取字段值</strong></p>
<p>利用反射拿到字段的一个<code>Field</code>实例只是第一步，还可以拿到一个实例对应的该字段的<strong>值</strong>。</p>
<p>例如，对于一个Person实例，我们可以先拿到name字段对应的Field，再获取这个实例的name字段的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Object p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"Xiao Ming"</span>);<br>        Class c = p.getClass();    <span class="hljs-comment">//得到类的class</span><br>        Field f = c.getDeclaredField(<span class="hljs-string">"name"</span>);<span class="hljs-comment">//得到这个class的name字段</span><br>        f.setAccessible(<span class="hljs-keyword">true</span>);     <span class="hljs-comment">//不管这个字段是不是public，一律允许访问。</span><br>        Object value = f.get(p);   <span class="hljs-comment">//关于p对象的f字段的值</span><br>        System.out.println(value); <span class="hljs-comment">// "Xiao Ming"</span><br>    &#125;<br>&#125;   <br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>引申疑问</p>
<p>在这里获取了private的值，如果使用反射可以获取<code>private</code>字段的值，那么类的封装还有什么意义？</p>
<p><strong>答案</strong>是正常情况下，我们总是通过<code>p.name</code>来访问Person的name字段，编译器会根据public、protected和private决定是否允许访问字段，这样就达到了数据封装的目的。</p>
<p>而反射是一种<strong>非常规</strong>的用法，使用反射，首先代码非常繁琐。<br>其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标实例任何信息的情况下，获取特定字段的值。</p>
<p>此外，<code>setAccessible(true)</code>可能会失败。<br>如果JVM运行期存在<code>SecurityManager</code>，那么它会根据规则进行检查，有可能阻止<code>setAccessible(true)</code>。<br>例如，某个<code>SecurityManager</code>可能不允许对<strong>java</strong>和<strong>javax</strong>开头的<strong>package</strong>的类调用<code>setAccessible(true)</code>，这样可以保证JVM核心库的安全。</p>
</li>
</ul>
</li>
<li><p><strong>设置字段值</strong></p>
<p>设置字段值是通过<code>Field.set(Object, Object)</code>实现的。<br>其中第一个Object参数是<strong>指定的实例</strong>，第二个Object参数是<strong>待修改的值</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>  Person p = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">"Xiao Ming"</span>);<br>  System.out.println(p.getName()); <span class="hljs-comment">// "Xiao Ming"</span><br>  Class c = p.getClass();<br>  Field f = c.getDeclaredField(<span class="hljs-string">"name"</span>);<br>  f.setAccessible(<span class="hljs-keyword">true</span>);<br>  f.set(p, <span class="hljs-string">"Xiao Hong"</span>);<span class="hljs-comment">//p对象的f字段</span><br>  System.out.println(p.getName()); <span class="hljs-comment">// "Xiao Hong"</span><br>&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>通过反射读写字段是一种非常规方法，它会破坏对象的封装。</p>
</blockquote>
</li>
</ol>
<h4 id="方法关于"><a href="#方法关于" class="headerlink" title="方法关于"></a>方法关于</h4><ol>
<li><p><strong>获取Method信息</strong></p>
<p>Class类提供了以下几个方法来获取<code>Method</code>：</p>
<p>① <code>Method getMethod(name, Class...)</code>：获取某个public的Method（包括父类）<br>② <code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个Method（不包括父类）<br>③ <code>Method[] getMethods()</code>：获取所有public的Method（包括父类）<br>④ <code>Method[] getDeclaredMethods()</code>：获取当前类的所有Method（不包括父类）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>Class stdClass = Student<span class="hljs-class">.<span class="hljs-keyword">class</span></span>;<br><span class="hljs-comment">// 获取public方法getScore，参数为String:</span><br>System.out.println(stdClass.getMethod(<span class="hljs-string">"getScore"</span>, String<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;<br><span class="hljs-comment">// 获取继承的public方法getName，无参数:</span><br>System.out.println(stdClass.getMethod(<span class="hljs-string">"getName"</span>));<br><span class="hljs-comment">// 获取private方法getGrade，参数为int:</span><br>System.out.println(stdClass.getDeclaredMethod(<span class="hljs-string">"getGrade"</span>, <span class="hljs-keyword">int</span><span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;<br>&#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getScore</span><span class="hljs-params">(String type)</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">99</span>;<br> &#125;<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getGrade</span><span class="hljs-params">(<span class="hljs-keyword">int</span> year)</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"Person"</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<pre><code>public int Student.getScore(java.lang.String)
public java.lang.String Person.getName()
private int Student.getGrade(int)</code></pre><p>一个<code>Method</code>对象包含一个方法的所有信息：</p>
<p>①<code>getName()</code>：返回方法名称，例如：”getScore”；<br>②<code>getReturnType()</code>：返回方法返回值类型，也是一个Class实例，例如：String.class；<br>③<code>getParameterTypes()</code>：返回方法的参数类型，是一个Class数组，例如：{String.class, int.class}；<br>④<code>getModifiers()</code>：返回方法的修饰符，它是一个int，不同的bit表示不同的含义。</p>
<p>当获取到一个Method对象时，就可以使用它进行调用。<br>以下面的代码为例：</p>
<pre><code>String s = &quot;Hello world&quot;;
String r = s.substring(6); // &quot;world&quot;</code></pre><p>如果用反射来调用<code>substring</code>方法，需要以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// String对象:</span><br>        String s = <span class="hljs-string">"Hello world"</span>;<br>        <span class="hljs-comment">// 获取String substring(int)方法，参数为int:</span><br>        Method m = String.class.getMethod("substring", int.class);<br>        <span class="hljs-comment">// 在s对象上调用该方法并获取结果:</span><br>        String r = (String) m.invoke(s, <span class="hljs-number">6</span>);<br>        <span class="hljs-comment">// 打印调用结果:</span><br>        System.out.println(r);<span class="hljs-comment">//world</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>调用静态方法</strong></p>
<p>如果获取到的Method表示一个静态方法，调用静态方法时，由于无需指定实例对象，所以<code>invoke</code>方法传入的第一个参数永远为<code>null</code>。</p>
<p>以Integer.parseInt(String)为例：</p>
<pre><code>Integer n = (Integer) m.invoke(null, &quot;12345&quot;); // 调用该静态方法并获取结果:</code></pre></li>
<li><p><strong>调用非public方法</strong></p>
<p>和Field类似，对于非public方法，虽然可以通过<code>Class.getDeclaredMethod()</code>获取该方法实例，但直接对其调用将得到一个<code>IllegalAccessException</code>。</p>
<p>为了调用非public方法，通过<code>Method.setAccessible(true)</code>允许其调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Person p = <span class="hljs-keyword">new</span> Person();<br>        Method m = p.getClass().getDeclaredMethod(<span class="hljs-string">"setName"</span>, String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br>        m.setAccessible(<span class="hljs-keyword">true</span>);<span class="hljs-comment">//同样，该方法可能调用失败</span><br>        m.invoke(p, <span class="hljs-string">"Bob"</span>);<br>        System.out.println(p.name);<span class="hljs-comment">//Bob</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    String name;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>使用反射调用方法时，仍然遵循多态原则：即总是调用实际类型的覆写方法（如果存在）。</p>
</blockquote>
</li>
<li><p><strong>调用构造方法</strong></p>
<p>我们<strong>通常使用</strong><code>new</code>操作符创建新的实例：</p>
<pre><code>Person p = new Person(  );</code></pre><p>如果通过<strong>反射</strong>来创建新的实例，可以调用Class提供的<code>newInstance()</code>方法：</p>
<pre><code>Person p = Person.class.newInstance(  );</code></pre><p>调用<code>newInstance()</code>的局限是，它只能调用该类的<code>public</code><strong>无参数构造方法</strong>。<br>如果构造方法带<strong>有参数</strong>，或者不是<code>public</code>，就无法直接通过<code>newInstance()</code>来调用。<br>可使用下面方法调用构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>     <span class="hljs-comment">// 获取Integer(int)构造器:</span><br>     Constructor cons1 = Integer<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getConstructor</span>(<span class="hljs-title">int</span>.<span class="hljs-title">class</span>)</span>;<br><br>​    <span class="hljs-comment">// 调用构造方法:</span><br>​    Integer n1 = (Integer) cons1.newInstance(<span class="hljs-number">123</span>);<br>​    System.out.println(n1);<span class="hljs-comment">//123</span><br><br>​    <span class="hljs-comment">// 获取Integer(String)构造器</span><br>​    Constructor cons2 = Integer<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getConstructor</span>(<span class="hljs-title">String</span>.<span class="hljs-title">class</span>)</span>;<br>​    Integer n2 = (Integer) cons2.newInstance(<span class="hljs-string">"456"</span>);<br>​    System.out.println(n2);<span class="hljs-comment">//456</span><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>即步骤是：</p>
<p>①先通过<code>Class</code>获得想调用构造方法的构造器。<br>②然后通过构造器来调用有参构造方法。</p>
<p>通过Class实例获取<code>Constructor</code>的方法如下：</p>
<p>①<code>getConstructor(Class...)</code>：获取某个public的Constructor；<br>②<code>getDeclaredConstructor(Class...)</code>：获取某个Constructor；<br>③<code>getConstructors()</code>：获取所有public的Constructor；<br>④<code>getDeclaredConstructors()</code>：获取所有Constructor。</p>
<blockquote>
<p>注意<code>Constructor</code>总是当前类定义的构造方法，和父类无关，因此不存在多态的问题。</p>
</blockquote>
<blockquote>
<p>调用<strong>非public</strong>的<code>Constructor</code>时，必须首先通过<code>setAccessible(true)</code>设置允许访问。<code>setAccessible(true)</code>可能会失败。</p>
</blockquote>
</li>
</ol>
<h4 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h4><ul>
<li><p><strong>当我们判断一个实例是否是某个类型时，正常情况下，使用<code>instanceof</code>操作符：</strong><br>即一个<strong>实例对象</strong>和一个<strong>类</strong>的方式判断：</p>
<pre><code>Object n = Integer.valueOf(123);
boolean isDouble = n instanceof Double; // false
boolean isInteger = n instanceof Integer; // true
boolean isNumber = n instanceof Number; // true
boolean isSerializable = n instanceof java.io.Serializable; // true</code></pre></li>
<li><p><strong>如果是两个Class实例，要判断一个向上转型是否成立，可以调用<code>isAssignableFrom()</code>：</strong></p>
<pre><code>// Integer i = ?
Integer.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Integer
// Number n = ?
Number.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Number
// Object o = ?
Object.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Object
// Integer i = ?
Integer.class.isAssignableFrom(Number.class); // false，因为Number不能赋值给Integer</code></pre></li>
</ul>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>​    ⁢⁢⁢⁢<strong>Java标准库提供了一种动态代理（Dynamic Proxy）的机制：可以在运行期动态创建某个<code>interface</code>的实例。</strong></p>
<ul>
<li><p><strong>什么叫运行期动态创建？所谓动态代理，是和静态相对应的。</strong><br><strong>静态代码：</strong> </p>
<p>①定义接口：</p>
<pre><code>public interface Hello {
    void morning(String name);
}</code></pre><p>②编写实现类：</p>
<pre><code>public class HelloWorld implements Hello {
    public void morning(String name) {
        System.out.println(&quot;Good morning, &quot; + name);
    }
}</code></pre><p>③创建实例，转型为接口并调用：</p>
<pre><code>Hello hello = new HelloWorld();
hello.morning(&quot;Bob&quot;);</code></pre><p><strong>动态代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        InvocationHandler handler = <span class="hljs-keyword">new</span> InvocationHandler() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>                System.out.println(method);<br>                <span class="hljs-keyword">if</span> (method.getName().equals(<span class="hljs-string">"morning"</span>)) &#123;<br>                    System.out.println(<span class="hljs-string">"Good morning, "</span> + args[<span class="hljs-number">0</span>]);<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;<br>        &#125;;<span class="hljs-comment">//类似匿名类实现方式</span><br>        Hello hello = (Hello) Proxy.newProxyInstance(<br>            Hello<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getClassLoader</span>(), // 传入<span class="hljs-title">ClassLoader</span></span><br>            new Class[] &#123; Hello.class &#125;, // 传入要实现的接口，可能不止一个所以用class数组表示？<br>            handler); <span class="hljs-comment">// 传入处理调用方法的InvocationHandler</span><br>        hello.morning(<span class="hljs-string">"Bob"</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Hello</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">morning</span><span class="hljs-params">(String name)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<pre><code>public abstract void Hello.morning(java.lang.String)
Good morning, Bob</code></pre><p>仍然先定义了接口Hello，但是并<strong>不去编写实现类</strong>，而是直接通过JDK提供的<code>Proxy.newProxyInstance()</code>创建了一个Hello接口对象。<br>这种<strong>没有实现类</strong>但是在运行期动态创建了一个接口对象的方式，称为<strong>动态代码</strong>。<br>JDK提供的动态创建接口对象的方式，就叫动态代理。</p>
<p>使用思路是：</p>
<p>⑴  定义一个<code>InvocationHandler</code>实例，它负责实现接口的方法调用；<br>⑵  通过<code>Proxy.newProxyInstance()</code>创建<code>interface</code>实例，它需要3个参数：<br>⁢⁢⁢⁢⁢⁢①使用的ClassLoader，通常就是接口类的ClassLoader；<br>⁢⁢⁢⁢⁢⁢②需要实现的接口数组，至少需要传入一个接口进去；<br>⁢⁢⁢⁢⁢⁢③用来处理接口方法调用的InvocationHandler实例。<br>⑶  将返回的<code>Object</code>强制转型为接口。</p>
</li>
</ul>
<hr>
<h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p>⁢⁢⁢⁢<strong>注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”。</strong></p>
<h2 id="注解的特点"><a href="#注解的特点" class="headerlink" title="注解的特点"></a>注解的特点</h2><ol>
<li><p><strong>注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。</strong></p>
</li>
<li><p><strong>Java的注解可以分为三类：</strong></p>
<p><strong>第一类是由编译时使用的注解，例如：</strong></p>
<p><code>@Override</code>：让编译器检查该方法是否正确地实现了覆写；<br><code>@SuppressWarnings</code>：告诉编译器忽略此处代码产生的警告。</p>
<blockquote>
<p>这类注解不会被编译进入.class文件，它们在编译后就被编译器扔掉了。</p>
</blockquote>
<p><strong>第二类是由工具处理.class文件使用的注解</strong></p>
<p>比如有些工具会在加载<code>class</code>的时候，对<code>class</code>做动态修改，实现一些特殊的功能。</p>
<blockquote>
<p>这类注解会被编译进入<code>.class</code>文件，但加载结束后并不会存在于内存中。<br>这类注解只被一些底层库使用，一般我们不必自己处理。</p>
</blockquote>
<p><strong>第三类是在程序运行期能够读取的注解</strong></p>
<p>在运行阶段还起作用，甚至会影响运行逻辑的注解。</p>
<p>例如，一个配置了<code>@PostConstruct</code>的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</p>
<blockquote>
<p>这类注解在加载后一直存在于JVM中，这也是最常用的注解。</p>
</blockquote>
</li>
</ol>
<h2 id="定义注解："><a href="#定义注解：" class="headerlink" title="定义注解："></a>定义注解：</h2><ul>
<li><p><strong>java语言使用<code>@interface</code>语法来定义注解（Annotation）</strong>，它的格式如下：</p>
<pre><code>public @interface Report {
int type() default 0;
String level() default &quot;info&quot;;
String value() default &quot;&quot;;
}</code></pre><blockquote>
<p>注解的参数类似无参数方法，可以用default设定一个默认值（强烈推荐）。最常用的参数应当命名为value。</p>
</blockquote>
<ol>
<li><p><strong>第一步</strong>，用<code>@interface</code>定义注解：</p>
<pre><code>public @interface Report {
}</code></pre></li>
<li><p><strong>第二步</strong>，添加参数、默认值：</p>
<p>把最常用的参数定义为<code>value()</code>，推荐所有参数都尽量设置默认值。</p>
<pre><code>public @interface Report {
    int type() default 0;
    String level() default &quot;info&quot;;
    String value() default &quot;&quot;;
}</code></pre></li>
<li><p><strong>第三步</strong>，用元注解配置注解：</p>
<pre><code>@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Report {
int type() default 0;
String level() default &quot;info&quot;;
String value() default &quot;&quot;;
}</code></pre><p>其中，必须设置<code>@Target</code>和<code>@Retention</code>。<br><code>@Retention</code>一般设置为<code>RUNTIME</code>，因为我们自定义的注解通常要求在<strong>运行期读取</strong>。<br>一般情况下，不必写<code>@Inherited</code>和<code>@Repeatable</code>。</p>
</li>
</ol>
</li>
</ul>
<h2 id="读取注解"><a href="#读取注解" class="headerlink" title="读取注解"></a>读取注解</h2><p>⁢⁢⁢⁢<strong>注解定义后也是一种<code>class</code>，所有的注解都继承自<code>java.lang.aCnnotation.Annotation</code>，读取注解，需要使用反射API。</strong></p>
<p>⁢⁢⁢⁢<strong>Java提供的使用反射API读取Annotation的方法包括：</strong></p>
<ol>
<li><p><strong>判断某个注解是否存在于<code>Class</code>、<code>Field</code>、<code>Method</code>或<code>Constructor</code>：</strong></p>
<p>▷ <code>Class实例.isAnnotationPresent(注解Class实例)</code><br>▷ <code>Field实例.isAnnotationPresent(注解Class实例)</code><br>▷ <code>Method实例.isAnnotationPresent(注解Class实例)</code><br>▷ <code>Constructor实例.isAnnotationPresent(注解Class实例)</code></p>
<p>例如：判断@Report是否存在于Person类:</p>
<pre><code>Person.class.isAnnotationPresent(Report.class);</code></pre></li>
<li><p><strong>使用反射API获取<code>Annotation</code>：</strong></p>
<p>▷ <code>Class.getAnnotation(Class)</code><br>▷ <code>Field.getAnnotation(Class)</code><br>▷ <code>Method.getAnnotation(Class)</code><br>▷ <code>Constructor.getAnnotation(Class)</code></p>
<p>例如：</p>
<pre><code>// 获取Person定义的@Report注解:
Report report = Person.class.getAnnotation(Report.class);
//若注解Report不存在将返回空
int type = report.type();//获取注解设置的值
String level = report.level();</code></pre></li>
</ol>
<ul>
<li><p>读取方法、字段和构造方法的Annotation和Class类似。但要读取方法参数的Annotation就比较麻烦一点，因为方法参数本身可以看成一个数组，而每个参数又可以定义多个注解，所以，一次获取方法参数的所有注解就必须用一个二维数组来表示。</p>
<ul>
<li>例如，对于以下方法定义的注解：</li>
</ul>
</li>
</ul>
<p>public void hello(@NotNull @Range(max=5) String name, @NotNull String prefix) {}</p>
<pre><code>- 要读取方法参数的注解，我们先用反射获取Method实例，然后读取方法参数的所有注解：</code></pre><p>// 获取Method实例:<br>Method m = …<br>// 获取所有参数的Annotation:<br>Annotation[][] annos = m.getParameterAnnotations();//每个一维数组存储一个参数的注解<br>// 第一个参数（索引为0）的所有Annotation:<br>Annotation[] annosOfName = annos[0];<br>for (Annotation anno : annosOfName) {//这里好像只求了第一个一维数组的注解<br>    if (anno instanceof Range) { // @Range注解<br>        Range r = (Range) anno;<br>    }<br>    if (anno instanceof NotNull) { // @NotNull注解<br>        NotNull n = (NotNull) anno;<br>    }<br>}</p>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><ul>
<li>有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。</li>
</ul>
<p>Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。</p>
<ul>
<li><p>@Target</p>
<ul>
<li><p>最常用的元注解是@Target。使用@Target可以定义注解能够被应用于源码的哪些位置：</p>
<ul>
<li>▲   类或接口：ElementType.TYPE；<br>▲   字段：         ElementType.FIELD；<br>▲   方法：         ElementType.METHOD；<br>▲   构造方法：ElementType.CONSTRUCTOR；<br>▲   方法参数：ElementType.PARAMETER。</li>
<li>例如，定义注解@Report可用在方法上，我们必须添加一个@Target(ElementType.METHOD)：</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>@Target(ElementType.METHOD)  //在此修饰Report注解<br>public @interface Report {<br>    int type() default 0;<br>    String level() default “info”;<br>    String value() default “”;<br>}</p>
<p>//定义注解@Report可用在方法或字段上，可以把@Target注解参数变为数组{ ElementType.METHOD, ElementType.FIELD }：</p>
<ul>
<li><p>@Retention</p>
<ul>
<li><p>另一个重要的元注解@Retention定义了Annotation的生命周期：</p>
<ul>
<li><p>▧    仅编译期：      RetentionPolicy.SOURCE；<br>▨    仅class文件：RetentionPolicy.CLASS；<br>▨    运行期：          RetentionPolicy.RUNTIME。</p>
<ul>
<li>如何使用注解完全由工具决定。SOURCE类型的注解主要由编译器使用，因此我们一般只使用，不编写。CLASS类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。只有RUNTIME类型的注解不但要使用，还经常需要编写。</li>
</ul>
</li>
<li><p>如果@Retention不存在，则该Annotation默认为CLASS。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>因为通常我们自定义的注解都是RUNTIME，所以，务必要加上@Retention(RetentionPolicy.RUNTIME)这个元注解</p>
<pre><code>- @Retention(RetentionPolicy.RUNTIME)</code></pre><p>public @interface Report {<br>    int type() default 0;<br>    String level() default “info”;<br>    String value() default “”;<br>}</p>
<ul>
<li><p>@Repeatable</p>
<ul>
<li>使用@Repeatable这个元注解可以定义Annotation是否可重复。</li>
</ul>
</li>
<li><p>@Inherited</p>
<ul>
<li><p>使用@Inherited定义子类是否可继承父类定义的Annotation。@Inherited仅针对@Target(ElementType.TYPE)类型的annotation有效，并且仅针对class的继承，对interface的继承无效：</p>
<ul>
<li><p>@Inherited<br>@Target(ElementType.TYPE)<br>public @interface Report {//定义注解Report<br>int type() default 0;<br>String level() default “info”;<br>String value() default “”;<br>}</p>
<ul>
<li>在使用的时候，如果一个类用到了@Report：</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>@Report(type=1)<br>public class Person {<br>}</p>
<p>则它的子类默认也定义了该注解：</p>
<p>public class Student extends Person {<br>}</p>
<h3 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h3><ul>
<li>注解如何使用，完全由程序自己决定。例如，JUnit是一个测试框架，它会自动运行所有标记为@Test的方法。<br>//什么意思?↑<br>我们来看一个@Range注解，我们希望用它来定义一个String字段的规则：字段长度满足@Range的参数定义：</li>
</ul>
<p>@Retention(RetentionPolicy.RUNTIME)<br>@Target(ElementType.FIELD)<br>public @interface Range {<br>    int min() default 0;<br>    int max() default 255;<br>}</p>
<p>在某个JavaBean中，我们可以使用该注解：</p>
<p>public class Person {<br>    @Range(min=1, max=20)<br>    public String name;</p>
<pre><code>@Range(max=10)
public String city;</code></pre><p>}</p>
<pre><code>- 但是，定义了注解，本身对程序逻辑没有任何影响。我们必须自己编写代码来使用注解。这里，我们编写一个Person实例的检查方法，它可以检查Person实例的String字段长度是否满足@Range的定义：</code></pre><p>void check(Person person) throws IllegalArgumentException, ReflectiveOperationException {<br>    // 遍历所有Field:<br>    for (Field field : person.getClass().getFields()) {<br>        // 获取Field定义的@Range:<br>        Range range = field.getAnnotation(Range.class);<br>        // 如果@Range存在:<br>        if (range != null) {<br>            // 获取Field的值:<br>            Object value = field.get(person);<br>            // 如果值是String:<br>            if (value instanceof String) {<br>                String s = (String) value;<br>                // 判断值是否满足@Range的min/max:<br>                if (s.length() &lt; range.min() || s.length() &gt; range.max()) {<br>                    throw new IllegalArgumentException(“Invalid field: “ + field.getName());<br>                }<br>            }<br>        }<br>    }<br>}</p>
<pre><code>- 这样一来，我们通过@Range注解，配合check()方法，就可以完成Person实例的检查。注意检查逻辑完全是我们自己编写的，JVM不会自动给注解添加任何额外的逻辑。</code></pre><p>##</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Lunomi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://unomisa.github.io/Java%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/">https://unomisa.github.io/Java进阶知识/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://unomisa.github.io" target="_blank">Lunomi Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/unomisa/photo-cloud/blogImg/7.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/SQL/"><img class="prev-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/unomisa/photo-cloud/blogImg/10.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SQL</div></div></a></div><div class="next-post pull-right"><a href="/Java%E5%B8%B8%E7%94%A8%E7%B1%BB/"><img class="next-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/unomisa/photo-cloud/blogImg/5.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java基础类</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/Java常用类/" title="Java基础类"><img class="cover" data-lazy-src="https://cdn.jsdelivr.net/gh/unomisa/photo-cloud/blogImg/5.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-02</div><div class="title">Java基础类</div></div></a></div><div><a href="/Java基础知识/" title="Java基础知识"><img class="cover" data-lazy-src="https://cdn.jsdelivr.net/gh/unomisa/photo-cloud/blogImg/6.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-27</div><div class="title">Java基础知识</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Lunomi</div><div class="framework-info"><span>框架 </span><a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener">Butterfly</a></div><div class="footer_custom_text">🦋</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    $.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js', function () {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      false && mermaid.init()
    })
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script id="canvas_nest" defer="defer" color="255,255,255" opacity="0.8" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script></div></body></html>