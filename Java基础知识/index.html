<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java基础知识 | Lunomi Blog</title><meta name="description" content="java的基础性知识"><meta name="keywords" content="java 基础"><meta name="author" content="Lunomi"><meta name="copyright" content="Lunomi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://unomisa.github.io/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Java基础知识"><meta property="og:url" content="https://unomisa.github.io/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"><meta property="og:site_name" content="Lunomi Blog"><meta property="og:description" content="java的基础性知识"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/unomisa/photo-cloud/blogImg/6.png"><meta property="article:published_time" content="2020-08-27T04:06:59.602Z"><meta property="article:modified_time" content="2020-09-06T01:19:31.119Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '4.2.1',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '天',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
      const now = new Date()
      const expiryDay = ttl * 86400000
      const item = {
        value: value,
        expiry: now.getTime() + expiryDay,
      }
      localStorage.setItem(key, JSON.stringify(item))
    },
  
  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-09-06 09:19:31'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = 'false'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/unomisa/unomisa.github.io/mycss/my.css"><link rel="stylesheet" href="/self/duotone.css"><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="https://cdn.jsdelivr.net/gh/unomisa/photo-cloud/blogImg/8.jpg" onerror="onerror=null;src='https://pic1.zhimg.com/v2-6a23112368d020c4b353e8ae991716e0_b.webp'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">5</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">2</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">1</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="color"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#到底什么是classpath？"><span class="toc-number">1.</span> <span class="toc-text">到底什么是classpath？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#面向对象编程-OOP"><span class="toc-number">2.</span> <span class="toc-text">面向对象编程(OOP)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#所有类的父类-Object类"><span class="toc-number">3.</span> <span class="toc-text">所有类的父类:Object类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#动态加载"><span class="toc-number">4.</span> <span class="toc-text">动态加载</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#输入"><span class="toc-number">5.</span> <span class="toc-text">输入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数组"><span class="toc-number">6.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数组常用方法"><span class="toc-number">6.1.</span> <span class="toc-text">数组常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组基础知识"><span class="toc-number">6.2.</span> <span class="toc-text">数组基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二维数组"><span class="toc-number">6.3.</span> <span class="toc-text">二维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#二维数组常用方法"><span class="toc-number">6.3.1.</span> <span class="toc-text">二维数组常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更高维度的数组"><span class="toc-number">6.3.2.</span> <span class="toc-text">更高维度的数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList"><span class="toc-number">6.4.</span> <span class="toc-text">ArrayList</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#带泛型的数组"><span class="toc-number">6.5.</span> <span class="toc-text">带泛型的数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#字符串"><span class="toc-number">7.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串基本概念"><span class="toc-number">7.1.</span> <span class="toc-text">字符串基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串常用方法"><span class="toc-number">7.2.</span> <span class="toc-text">字符串常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#判断字符串"><span class="toc-number">7.2.1.</span> <span class="toc-text">判断字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#修改字符串"><span class="toc-number">7.2.2.</span> <span class="toc-text">修改字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#替换子串"><span class="toc-number">7.2.2.1.</span> <span class="toc-text">替换子串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查找字符串"><span class="toc-number">7.2.3.</span> <span class="toc-text">查找字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分割字符串"><span class="toc-number">7.2.4.</span> <span class="toc-text">分割字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拼接字符串"><span class="toc-number">7.2.5.</span> <span class="toc-text">拼接字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#格式化字符串"><span class="toc-number">7.2.6.</span> <span class="toc-text">格式化字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#转换为字符串"><span class="toc-number">7.2.7.</span> <span class="toc-text">转换为字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串转换为其他类型"><span class="toc-number">7.2.8.</span> <span class="toc-text">字符串转换为其他类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串转换成其他编码"><span class="toc-number">7.2.9.</span> <span class="toc-text">字符串转换成其他编码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类"><span class="toc-number">8.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#类基本知识"><span class="toc-number">8.1.</span> <span class="toc-text">类基本知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承"><span class="toc-number">8.2.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final关键字"><span class="toc-number">8.3.</span> <span class="toc-text">final关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#abstract关键字"><span class="toc-number">8.4.</span> <span class="toc-text">abstract关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口-interface"><span class="toc-number">8.5.</span> <span class="toc-text">接口(interface)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static关键字"><span class="toc-number">8.6.</span> <span class="toc-text">static关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#包"><span class="toc-number">8.7.</span> <span class="toc-text">包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#访问权限"><span class="toc-number">8.8.</span> <span class="toc-text">访问权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#判断类所属"><span class="toc-number">8.9.</span> <span class="toc-text">判断类所属</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#包装类型"><span class="toc-number">9.</span> <span class="toc-text">包装类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#包装类型的作用"><span class="toc-number">9.1.</span> <span class="toc-text">包装类型的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Integer"><span class="toc-number">9.2.</span> <span class="toc-text">Integer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建实例"><span class="toc-number">9.2.1.</span> <span class="toc-text">创建实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自动装拆"><span class="toc-number">9.2.2.</span> <span class="toc-text">自动装拆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态工厂方法"><span class="toc-number">9.2.3.</span> <span class="toc-text">静态工厂方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#格式化"><span class="toc-number">9.2.4.</span> <span class="toc-text">格式化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#包装类型定义的静态变量"><span class="toc-number">9.2.5.</span> <span class="toc-text">包装类型定义的静态变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#处理无符号整型"><span class="toc-number">9.3.</span> <span class="toc-text">处理无符号整型</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/unomisa/photo-cloud/blogImg/6.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Lunomi Blog</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 日志</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Java基础知识</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-08-27T04:06:59.602Z" title="发表于 2020-08-27 12:06:59">2020-08-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-09-06T01:19:31.119Z" title="更新于 2020-09-06 09:19:31">2020-09-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="到底什么是classpath？"><a href="#到底什么是classpath？" class="headerlink" title="到底什么是classpath？"></a>到底什么是classpath？</h1><div class="note info"><p><strong>classpath是JVM用到的一个环境变量，它用来指示JVM如何搜索class。</strong></p>
</div>

<p>因为Java是<strong>编译型语言</strong>，源码文件是.java，而编译后的.class文件才是真正可以被JVM执行的<strong>字节码</strong>。</p>
<p>因此，JVM需要知道，如果要加载一个abc.xyz.Hello的类，应该<strong>去哪搜索</strong>对应的Hello.class文件。</p>
<p>所以，classpath就是一组<strong>目录的集合</strong>，它设置的搜索路径与操作系统相关。</p>
<p>例如，在Windows系统上，用<code>;</code>分隔，带空格的目录用<code>&quot;&quot;</code>括起来，可能长这样：</p>
<p><code>C:\work\project1\bin;C:\shared;&quot;D:\My Documents\project1\bin&quot;</code></p>
<h1 id="面向对象编程-OOP"><a href="#面向对象编程-OOP" class="headerlink" title="面向对象编程(OOP)"></a>面向对象编程(OOP)</h1><font color=#ec4e8a>

<blockquote>
<p><strong>六句真言：继承不抽象，拿来不要还。封装加权限，接口要简单。多态不变态，接口不依赖。每日默念，必定成仙。</strong></font></p>
</blockquote>
<h1 id="所有类的父类-Object类"><a href="#所有类的父类-Object类" class="headerlink" title="所有类的父类:Object类"></a>所有类的父类:Object类</h1><font color=#d276a3>

<p><em>因为所有的class最终都继承自Object，而Object定义了几个重要的方法：</em></p>
</font>

<div class="note default"><p>toString(  )：把instance输出为String；</p>
</div>

<div class="note default"><p>equals(  )：判断两个instance是否逻辑相等；</p>
</div>

<div class="note default"><p>hashCode(  )：计算一个instance的哈希值。</p>
</div>

<div class="note info"><p><strong>在必要的情况下，我们可以覆写Object的这几个方法。</strong></p>
</div>

<h1 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h1><div class="note primary no-icon"><p>JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。</p>
</div>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-comment">// Main.java</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (args.length &gt; <span class="hljs-number">0</span>) &#123;<br>            create(args[<span class="hljs-number">0</span>]);<br>      &#125;<br>    &#125;<br><br>​    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">create</span><span class="hljs-params">(String name)</span> </span>&#123;<br>​      Person p = <span class="hljs-keyword">new</span> Person(name);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当执行Main.java时，由于用到了Main，因此，JVM首先会把<strong>Main.class加载到内存。</strong></p>
<p>然而，并<strong>不会加载Person.class</strong>，除非程序执行到create( )方法，JVM发现需要加载Person类时，才会<strong>首次加载Person.class。</strong></p>
<p>如果<em>没有执行</em>create( )方法，那么Person.class根本就<strong>不会被加载</strong>。</p>
{% note default no-icon %}

这就是JVM动态加载class的特性。

{% endnote %}

<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;           <span class="hljs-comment">//添加引用</span><br><br>Scanner cin=<span class="hljs-keyword">new</span> Scanner(System.in); <span class="hljs-comment">//创建对象</span><br> <span class="hljs-keyword">int</span> a[]=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>];<br> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        a[i]=cin.nextInt();         <span class="hljs-comment">//用这个对象输入</span><br> &#125;<br></code></pre></td></tr></table></figure>



<hr>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组常用方法"><a href="#数组常用方法" class="headerlink" title="数组常用方法"></a>数组常用方法</h2><ol>
<li><code>数组名.length</code> 可以直接得到数组长度。</li>
<li><code>Arrays.toString( 数组名)</code> 将数组内容返回字符串表示。</li>
<li><code>Arrays.sort( 数组名 )</code>直接对数组进行排序。</li>
<li><code>clone(  )</code>返回复制的数组。</li>
</ol>
<h2 id="数组基础知识"><a href="#数组基础知识" class="headerlink" title="数组基础知识"></a>数组基础知识</h2><div class="note danger"><p><strong>不能使用</strong><code>=</code>号来<del>连接</del>两个数组，会造成引用相同，更改其中一个数组两个都会改变 </p>
</div>

<div class="note primary"><p>与C语言不同的是，Java允许使用<code>int</code>型变量的值指定数组元素的个数。</p>
</div>
<pre><code>int size=30;                    
double number[ ]=new double[size];</code></pre><ol>
<li><p>使用<code>for each</code> 语句遍历数组</p>
<pre><code>for (与数组类型相同的变量 : 数组名) {
    System.out.println(变量名);
}</code></pre><blockquote>
<p>传统for遍历可以<strong>得到索引</strong>，该种for遍历是直接<strong>拿到数组元素</strong>。根据需求使用其中一种遍历方式。</p>
</blockquote>
</li>
</ol>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><ol>
<li><p>二维数组的<code>length</code>取决于它的一维数组个数。</p>
</li>
<li><p>二维数组的每个数组元素的长度并<strong>不要求</strong>相同。</p>
<pre><code>int a[ ][ ]=new int [3][ ];  
a[0]=new int[6];  
a[1]=new int [12];   
a[2]=new int[8];</code></pre></li>
</ol>
<h3 id="二维数组常用方法"><a href="#二维数组常用方法" class="headerlink" title="二维数组常用方法"></a>二维数组常用方法</h3><ol>
<li><code>Arrays.deepToString(二维数组名)</code> 将二维数组内容返回字符串表示。</li>
</ol>
<h3 id="更高维度的数组"><a href="#更高维度的数组" class="headerlink" title="更高维度的数组"></a>更高维度的数组</h3><ul>
<li>二维数组的<strong>元素</strong>为一维数组，而三维数组的元素为二维数组，以此类推。</li>
</ul>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><ul>
<li>ArrayList<strong>内部</strong>就是一个<code>Object[]</code>数组，配合存储一个当前分配的长度，就可以充当“可变数组”。</li>
</ul>
<h2 id="带泛型的数组"><a href="#带泛型的数组" class="headerlink" title="带泛型的数组"></a>带泛型的数组</h2><ol>
<li>创建带泛型的数组</li>
</ol>
<ul>
<li><p>可以声明带泛型的数组，但不能用<code>new</code>操作符创建带泛型的数组：</p>
<pre><code>Pair&lt;String&gt;[] ps = null; // ok
Pair&lt;String&gt;[] ps = new Pair&lt;String&gt;[2]; // compile error!</code></pre></li>
<li><p>必须通过<strong>强制转型</strong>实现带泛型的数组：</p>
<pre><code>@SuppressWarnings(&quot;unchecked&quot;)
Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) new Pair[2];</code></pre></li>
<li><p>尽量不要这样声明：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair[] arr = <span class="hljs-keyword">new</span> Pair[<span class="hljs-number">2</span>];                  <span class="hljs-comment">//会多出一个可以操作泛型数组的引用arr</span><br>Pair&lt;String&gt;[] ps = (Pair&lt;String&gt;[]) arr;<br><br>ps[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Pair&lt;String&gt;(<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>);        <span class="hljs-comment">//ps是泛型数组，编译器会检查是否为String</span><br>arr[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Pair&lt;Integer&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);          <span class="hljs-comment">//但arr不是，编译器不会检查其类型，可能造成错误</span><br><br><span class="hljs-comment">// ClassCastException:</span><br>Pair&lt;String&gt; p = ps[<span class="hljs-number">1</span>];<br>String s = p.getFirst();<br></code></pre></td></tr></table></figure>

{% note info %}

应该扔掉`arr`引用，像前面一样直接声明。

{% endnote %}

<ol start="2">
<li><p>借助Class<T>来创建泛型数组：</p>
<pre><code>T[] createArray(Class&lt;T&gt; cls) {
    return (T[]) Array.newInstance(cls, 5);
}</code></pre></li>
<li><p>利用可变参数创建泛型数组T[]：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayHelper</span> </span>&#123;<br>    <span class="hljs-meta">@SafeVarargs</span><br>    <span class="hljs-keyword">static</span> &lt;T&gt; T[] asArray(T... objs) &#123;<br>        <span class="hljs-keyword">return</span> objs;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//可以用一个方法创建不同类型的数组</span><br>String[] ss = ArrayHelper.asArray(<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>);  <br>Integer[] ns = ArrayHelper.asArray(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure>



<hr>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串基本概念"><a href="#字符串基本概念" class="headerlink" title="字符串基本概念"></a>字符串基本概念</h2><ol>
<li><p>字符串在String内部是通过一个<code>char[]</code>数组表示的，因此，按下面的写法也是可以的：</p>
<pre><code>String s2 = new String(new char[] {&apos;H&apos;, &apos;e&apos;, &apos;l&apos;, &apos;l&apos;, &apos;o&apos;, &apos;!&apos;});</code></pre><blockquote>
<p>注意：char[]后面没有 <code>=</code></p>
</blockquote>
</li>
<li><p>Java字符串的一个重要特点就是字符串<strong>不可变</strong>。</p>
<p>这种不可变性是通过内部的<code>private final char[]</code>字段，以及没有任何修改<code>char[]</code>的方法实现的。</p>
<blockquote>
<p>始终牢记：Java的String和char在内存中总是以Unicode编码表示。</p>
</blockquote>
</li>
<li><p>Java编译器对String做了特殊处理，使得我们可以直接用<code>+</code>拼接字符串。        </p>
<p>Java编译器在编译时就自动把多个连续的<code>+</code>操作编码为<code>StringConcatFactory</code>的操作。</p>
<p>在运行期，<code>StringConcatFactory</code>会自动把字符串连接操作优化为数组复制或者<code>StringBuilder</code>操作。</p>
</li>
</ol>
<h2 id="字符串常用方法"><a href="#字符串常用方法" class="headerlink" title="字符串常用方法"></a>字符串常用方法</h2><h3 id="判断字符串"><a href="#判断字符串" class="headerlink" title="判断字符串"></a>判断字符串</h3><ol>
<li><p><code>字符串.equals( 字符串 )</code> 来判断两个字符串是否相等。</p>
<p>本质上是判断两个实例是否相等。</p>
<blockquote>
<p>要忽略大小写比较，使用equalsIgnoreCase()方法。</p>
</blockquote>
</li>
<li><p><code>字符串.contains( 子串 )</code> 来判断是否包含字串。</p>
<pre><code>&quot;Hello&quot;.contains(&quot;ll&quot;); // true</code></pre></li>
<li><p><code>字符串.startsWith(子串)</code> 判断是否以…开头。</p>
<pre><code>&quot;Hello&quot;.startsWith(&quot;He&quot;); // true</code></pre></li>
<li><p><code>字符串.endsWith(子串)</code> 判断是否以…结尾。</p>
<pre><code>&quot;Hello&quot;.endsWith(&quot;lo&quot;); // true</code></pre></li>
<li><p><code>字符串.isEmpty(  )</code> 判断字符串是否为空。</p>
<pre><code>&quot;&quot;.isEmpty(  ); // true，因为字符串长度为0
&quot;  &quot;.isEmpty(  ); // false，因为字符串长度不为0</code></pre></li>
<li><p><code>字符串.isBlank(  )</code>  判断字符串是否为空白字符串。</p>
<pre><code>&quot;  \n&quot;.isBlank(  ); // true，因为只包含空白字符
&quot; Hello &quot;.isBlank(  ); // false，因为包含非空白字符</code></pre></li>
</ol>
<h3 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h3><ol>
<li><p><code>字符串.replaceAll( 需要替换的字符,替换的结果字符)</code> 来将字符串中的特定字符替换成其他字符并返回替换后的字符串。</p>
<blockquote>
<p>可以这个方法来将字符串中空格字符去掉：字符串.replaceAll(“ “,’’’’);</p>
</blockquote>
</li>
<li><p><code>字符串.trim(  )</code> 去掉首尾空白字符，但是中间的不行。</p>
<blockquote>
<p>空白字符包括空格，\t，\r，\n，但无法删除中文空格<code>&#39;\u3000&#39;</code>(2个字节的空格)。</p>
</blockquote>
<h4 id="替换子串"><a href="#替换子串" class="headerlink" title="替换子串"></a>替换子串</h4><ol>
<li><p>根据字符或字符串替换：</p>
<pre><code>&quot;hello&quot;.replace(&apos;l&apos;, &apos;w&apos;); // &quot;hewwo&quot;，所有字符&apos;l&apos;被替换为&apos;w&apos;
&quot;hello&quot;.replace(&quot;ll&quot;, &quot; ~~ &quot;); // &quot;he ~~ o&quot;，所有子串&quot;ll&quot;被替换为&quot; ~~ &quot;</code></pre></li>
<li><p>通过正则表达式替换：</p>
<pre><code>String s = &quot;A,,B;C ,D&quot;;             
s.replaceAll(&quot;[,;\\s]+&quot;, &quot;,&quot;); // &quot;A,B,C,D&quot;</code></pre></li>
</ol>
</li>
</ol>
<h3 id="查找字符串"><a href="#查找字符串" class="headerlink" title="查找字符串"></a>查找字符串</h3><ol>
<li><p><code>字符串.indexOf(子串)</code> 查找字符或者子串第一次出现的地方。</p>
<pre><code>&quot;Hello&quot;.indexOf(&quot;l&quot;); // 2</code></pre></li>
<li><p><code>字符串.lastIndexOf(子串)</code> 查找字符或者子串是后一次出现的地方。</p>
<pre><code>&quot;Hello&quot;.lastIndexOf(&quot;l&quot;); // 3</code></pre></li>
<li><p><code>字符串.substring(截取开始处下标，截取结束点下标)</code>  截取字符串中的子串。</p>
<pre><code>&quot;Hello&quot;.substring(2); // &quot;llo&quot;
&quot;Hello&quot;.substring(2, 4); &quot;ll&quot;</code></pre></li>
</ol>
   <div class="note info"><p>都使用下标表示位置。</p>
</div>

<h3 id="分割字符串"><a href="#分割字符串" class="headerlink" title="分割字符串"></a>分割字符串</h3><ol>
<li><code>字符串.split( 正则表达式 )</code> 将分割后的字符串存到一个字符串数组中并返回。<pre><code>String s = &quot;A,B,C,D&quot;; 
String[] ss = s.split(&quot;\\,&quot;); // {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;}</code></pre></li>
</ol>
<h3 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h3><ol>
<li><p><code>String.join(字符串,数组)</code> 用指定的字符串连接字符串数组元素。</p>
<pre><code>String[] arr = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;};                         
String s = String.join(&quot;!!&quot;, arr); // &quot;A!!B!!C&quot;</code></pre><blockquote>
<p>这个方法在内部使用了<code>StringJoiner</code>来拼接字符串，在不需要指定“开头”和“结尾”的时候，用<code>String.join()</code>更方便。</p>
</blockquote>
</li>
</ol>
<h3 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h3><ol>
<li><code>String.format()</code> 可以传入其他参数，替换占位符，然后生成新的字符串。<pre><code>String s = &quot;Hi %s, your score is %d!&quot;; 
System.out.println(String.format(s, &quot;Bob&quot;,60));   //Hi Bob, your score is 60!</code></pre></li>
</ol>
<h3 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h3><ul>
<li><code>String.valueOf()</code> 把任意基本类型或引用类型转换为字符串。<pre><code>String.valueOf(123); // &quot;123&quot;
String.valueOf(45.67); // &quot;45.67&quot;
String.valueOf(true); // &quot;true&quot;
String.valueOf(new Object()); // 类似java.lang.Object@636be97c</code></pre></li>
</ul>
<h3 id="字符串转换为其他类型"><a href="#字符串转换为其他类型" class="headerlink" title="字符串转换为其他类型"></a>字符串转换为其他类型</h3><ol>
<li><p><code>Integer.parseInt(字符串)</code> 字符串转int。</p>
<pre><code>int n1 = Integer.parseInt(&quot;123&quot;); // 123
   int n2 = Integer.parseInt(&quot;ff&quot;, 16); // 按十六进制转换，255</code></pre></li>
<li><p><code>Boolean.parseBoolean(字符串)</code> 字符串转boolean。</p>
<pre><code>boolean b1 = Boolean.parseBoolean(&quot;true&quot;); // true
boolean b2 = Boolean.parseBoolean(&quot;FALfsSE&quot;); // false</code></pre></li>
<li><p><code>String</code>和<code>char[]</code>的相互转换：</p>
<pre><code>char[] cs = &quot;Hello&quot;.toCharArray();   // String -&gt; char[]
String s = new String(cs);   // char[] -&gt; String</code></pre></li>
</ol>
<h3 id="字符串转换成其他编码"><a href="#字符串转换成其他编码" class="headerlink" title="字符串转换成其他编码"></a>字符串转换成其他编码</h3><ol>
<li><p><code>字符串.getBytes(编码)</code> 把字符串转换成其他编码，返回byte[]。</p>
<pre><code>byte[] b2 = &quot;Hello&quot;.getBytes(&quot;UTF-8&quot;); // 按UTF-8编码转换
byte[] b2 = &quot;Hello&quot;.getBytes(&quot;GBK&quot;); // 按GBK编码转换</code></pre></li>
<li><p>把已知编码的<code>byte[]</code>转换为<code>String</code>：</p>
<pre><code>byte[] b = ...
String s1 = new String(b, &quot;GBK&quot;); // 按GBK转换
String s2 = new String(b, StandardCharsets.UTF_8); // 按UTF-8转换</code></pre></li>
</ol>
<hr>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><h2 id="类基本知识"><a href="#类基本知识" class="headerlink" title="类基本知识"></a>类基本知识</h2><ol>
<li><p>创建新对象时，优先选用静态工厂方法而不是<code>new</code>操作符。</p>
</li>
<li><p>将字段声明为<code>private</code>的好处可以防止外部代码将字段设置为不合理的值,因为只有在本类方法中才能调用它，而在本类方法中可以对参数进行检查。</p>
<blockquote>
<p>所以在类中设置字段时，可以都将其设置为private，也许这是一个好习惯。</p>
</blockquote>
</li>
<li><p>在创建方法时，尽量完成对传入的参数的<strong>合理性判断</strong>。</p>
<blockquote>
<p>如对年龄字段限制在0~150等等。</p>
</blockquote>
</li>
<li><p>方法可变参数用：<code>类型... 变量名</code> 定义，可变参数可以当作数组类型使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Group</span> </span>&#123;<br><span class="hljs-keyword">private</span> String[] names;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNames</span><span class="hljs-params">(String...names)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.names = names;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>调用方式：对象名.setNames(<code>字符串,字符串,...</code>);</p>
</blockquote>
<p>若将形式参数改为<strong>String names[]</strong></p>
<blockquote>
<p>调用方式将变更为：对象名.setNames(<code>new String[] {&quot;刘力郡&quot;,陶俊杰&quot;}</code>);//会麻烦一些</p>
</blockquote>
</li>
<li><p>没有在构造方法中初始化字段时，<code>引用类型</code>的字段默认是<code>null</code>，<code>int</code>类型默认值是<code>0</code>，布尔类型默认值是<code>false</code>。</p>
</li>
<li><p>在类中定义字段时可以直接为<strong>字段初始化</strong></p>
<pre><code>如:class Student{ 
int age=10;                    
 }</code></pre></li>
<li><p>一个构造方法可以调用其他构造方法，这样做的目的是便于代码复用。调用其他构造方法的语法是<code>this(…)</code>。</p>
</li>
<li><p>方法名相同，但各自的参数不同，称为<strong>方法重载（Overload）</strong>。</p>
<blockquote>
<p>加上@Override可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名(参数)，编译器会报错。</p>
</blockquote>
</li>
<li><p>一个类中拥有着另一个类中的对象称为<strong>组合</strong>。</p>
</li>
</ol>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ol>
<li><p>继承的思想</p>
<p>所谓继承就是在原先有的类的基础上添加想要的功能。</p>
</li>
<li><p>继承的好处</p>
<p>继承可以复用代码，子类可以拿走父类的所有功能和属性，只需要为子类编写新的功能和属性就行了。</p>
<blockquote>
<p>编程的思想也就是继承：不用什么功能都自己来写，可以使用各种库中写好的方法，这样编程效率会快很多。</p>
</blockquote>
</li>
<li><p>构造方法不会被继承</p>
<p>任何class的构造方法，第一行语句必须是调用父类的构造方法。如果父类没有默认的构造方法，子类就必须显式调用super()并给出参数以便让编译器定位到父类的一个合适的构造方法。</p>
</li>
<li><p>在Java中，没有明确写<code>extends</code>的类，编译器会自动加上<code>extends Object</code>。</p>
<p>所以只有<code>Object</code>特殊，它没有父类。</p>
<p>所以除了<code>Object</code>类，所有的类都会显式或隐式使用<code>super(  )</code>调用父类的构造函数。</p>
</li>
</ol>
<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><ol>
<li><p>关于字段：</p>
<p>对于一个类的实例字段，可以用<code>final</code>修饰。用<code>final</code>修饰的字段在初始化(需要为它直接初始化或在构造方法中初始化)后不能被修改。</p>
<div class="note warning no-icon"><p>如果选择在构造方法中初始化的话，编译器会检查每个重载的构造方法都必须含有为<code>final</code>字段初始化的语句。</p>
</div>
</li>
<li><p>关于方法：</p>
<p>如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为<code>final</code>。</p>
<p>用<code>final</code>修饰的方法不能被<code>Override(重写)</code>。</p>
</li>
<li><p>关于类：</p>
<p>如果一个类不希望任何其他类继承自它，那么可以把这个类本身标记为<code>final</code>。</p>
<p>用<code>final</code>修饰的类不能被继承。</p>
</li>
</ol>
<h2 id="abstract关键字"><a href="#abstract关键字" class="headerlink" title="abstract关键字"></a>abstract关键字</h2><ol>
<li><p>把一个方法声明为<code>abstract</code>，表示它是一个抽象方法，本身没有实现任何方法语句。</p>
</li>
<li><p>包含抽象方法的类必须为抽象类。</p>
</li>
<li><p>抽象类<del>不能</del>实例化对象。</p>
</li>
</ol>
<h2 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口(interface)"></a>接口(interface)</h2><ol>
<li><p>接口的概念</p>
<p>interface是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有(抽象类是可以有字段和非抽象方法的)。</p>
<p>接口定义的所有方法默认都是<code>public abstract</code>的，所以这两个修饰符不需要写出来（写不写效果都一样）。</p>
</li>
<li><p>实现接口</p>
<p>当一个具体的class去实现一个interface时，需要使用<code>implements</code>关键字。</p>
</li>
<li><p>在Java中，一个类只能继承自另一个类，不能从多个类继承。但是，一个类可以实现多个<code>interface</code>。</p>
</li>
<li><p>接口继承</p>
<p>一个<code>interface</code>可以使用<code>extends</code>继承自另一个<code>interface</code>。</p>
</li>
<li><p>default方法</p>
<ul>
<li><p>实现类可以不必覆写<code>default</code>方法。</p>
</li>
<li><p>default方法的目的</p>
<p>当我们需要给接口新增一个方法时，会涉及到修改全部子类。</p>
<p>如果新增的是default方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p>
</li>
<li><p>default方法和抽象类的普通方法是有所不同的。</p>
<p><code>interface</code>没有字段，所以<code>default</code>方法无法访问字段，而抽象类的普通方法可以访问实例字段。</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>合理设计interface和abstract class的继承关系，可以充分复用代码。</p>
</blockquote>
<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><ol>
<li><p>静态字段</p>
<p>不推荐用 <code>实例变量.静态字段</code> 去访问静态字段，因为在Java程序中，实例对象并没有静态字段。</p>
<p>在代码中，实例对象能访问静态字段只是因为编译器可以根据实例类型自动转换为 <code>类名.静态字段</code> 来访问静态对象。</p>
<blockquote>
<p>推荐用类名来访问静态字段。可以把静态字段理解为描述class本身的字段（非实例字段）。</p>
</blockquote>
</li>
<li><p>静态方法</p>
<p>静态方法属于class而不属于实例，因此，静态方法内部，无法访问this变量，也无法访问实例字段，它只能访问静态字段。</p>
</li>
</ol>
<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><ol>
<li><p><code>import static</code>的语法，它可以导入一个类的静态字段和静态方法。</p>
<p>例如：导入<code>System</code>类的所有静态字段和静态方法:</p>
<pre><code>import static java.lang.System.*;</code></pre></li>
<li><p>编写<code>class</code>的时候，编译器会自动帮我们做两个<code>import</code>动作：</p>
<ul>
<li><p>默认自动<code>import</code>当前<code>package</code>的其他<code>class</code>。</p>
</li>
<li><p>默认自动<code>import java.lang.*</code>。</p>
</li>
</ul>
</li>
<li><p>在写<code>import</code>的时候，可以使用<code>*</code>，表示把这个包下面的所有<code>class</code>都导入进来（但不包括子包的class）。</p>
<ul>
<li><p>所以需要注意的是：</p>
<p>自动导入的是<code>java.lang</code>包，但类似<code>java.lang.reflect</code>这些包仍需要手动导入。</p>
</li>
</ul>
</li>
<li><p>为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用倒置的域名来确保唯一性。例如：</p>
<ul>
<li><p>org.apache</p>
</li>
<li><p>org.apache.commons.log</p>
</li>
<li><p>com.liaoxuefeng.sample</p>
</li>
</ul>
</li>
</ol>
<h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2><ol>
<li><p>public</p>
<p>定义为<code>public</code>的<code>class</code>、<code>interface</code>可以被其他任何类访问。</p>
</li>
<li><p>protected</p>
<p><code>protected</code>作用于继承关系。</p>
<p>定义为<code>protected</code>的字段和方法可以被子类访问，以及子类的子类。</p>
</li>
<li><p>private</p>
<p>定义为<code>private</code>的<code>field</code>、<code>method</code>无法被其他类访问，<code>private</code>访问权限被限定在该<code>class</code>的内部。</p>
<blockquote>
<p>推荐把private方法放到后面，因为public方法定义了类对外提供的功能，阅读代码的时候，应该先关注public方法。</p>
</blockquote>
</li>
</ol>
<h2 id="判断类所属"><a href="#判断类所属" class="headerlink" title="判断类所属"></a>判断类所属</h2>{% note default %}

**对象名 instanceof 类名** 判断一个对象所指向的实例是否是指定类型，或者这个类型的子类，返回逻辑值。

{% endnote %}

<ul>
<li><p>需要判断的原因是父类对象实例是不能下转为子类对象实例的，因为不能凭空多出子类的功能。</p>
</li>
<li><p>通常情况下，我们应该用<code>instanceof</code>判断数据类型，因为面向抽象编程的时候，我们不关心具体的子类型(只要可以上转即可)。</p>
<p>只有在需要精确判断一个类型是不是某个<code>class</code>的时候，我们才使用<code>==</code>判断<code>class</code>实例。</p>
</li>
</ul>
<hr>
<h1 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h1><h2 id="包装类型的作用"><a href="#包装类型的作用" class="headerlink" title="包装类型的作用"></a>包装类型的作用</h2><ol>
<li>将一个基本类型视为引用类型(对象)。</li>
<li>所有的整数和浮点数的包装类型都继承自Number，因此，可以非常方便地直接通过包装类型获取各种基本类型：<pre><code>Number num = new Integer(999);        // 向上转型为Number:
// 获取byte, int, long, float, double:
byte b = num.byteValue();
int n = num.intValue();
long ln = num.longValue();
float f = num.floatValue();
double d = num.doubleValue();</code></pre></li>
</ol>
<h2 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h2><h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3><ol>
<li><p>通过<code>new</code>操作符创建Integer实例(不推荐使用,会有编译警告)：</p>
<pre><code>Integer n1 = new Integer(100);</code></pre></li>
<li><p>通过静态方法<code>valueOf(int)</code>创建Integer实例:</p>
<pre><code>Integer n2 = Integer.valueOf(100);</code></pre></li>
<li><p>通过静态方法<code>valueOf(String)</code>创建Integer实例:</p>
<pre><code>Integer n3 = Integer.valueOf(&quot;100&quot;);</code></pre></li>
</ol>
<blockquote>
<p>方法2更好，因为方法1总是创建新的Integer实例，方法2把内部优化留给Integer的实现者去做，即使在当前版本没有优化，也有可能在下一个版本进行优化。</p>
</blockquote>
<h3 id="自动装拆"><a href="#自动装拆" class="headerlink" title="自动装拆"></a>自动装拆</h3><ul>
<li><p>Java编译器可以帮助我们自动在<code>int</code>和<code>Integer</code>之间转型:</p>
<pre><code>Integer n = 100; // 编译器自动使用Integer.valueOf(int)
int x = n; // 编译器自动使用Integer.intValue()</code></pre><p>这种直接把int变为Integer的赋值写法，称为自动装箱（Auto Boxing）。</p>
<p>反过来，把Integer变为int的赋值写法，称为自动拆箱（Auto Unboxing）。</p>
<div class="note info"><p>注意：自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码。</p>
</div>

</li>
</ul>
<h3 id="静态工厂方法"><a href="#静态工厂方法" class="headerlink" title="静态工厂方法"></a>静态工厂方法</h3><p>我们把能创建“新”对象的静态方法称为静态工厂方法。</p>
<ol>
<li><p><code>Integer.valueOf()</code>就是静态工厂方法，它尽可能地返回缓存的实例以节省内存。</p>
</li>
<li><p>静态方法<code>parseInt()</code>可以把字符串解析成一个整数。</p>
<pre><code>int x1 = Integer.parseInt(&quot;100&quot;); // 100
int x2 = Integer.parseInt(&quot;100&quot;, 16); // 256,因为按16进制解析</code></pre></li>
</ol>
<h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><ul>
<li>Integer还可以把整数格式化为指定进制的字符串<pre><code>System.out.println(Integer.toString(100)); // &quot;100&quot;,表示为10进制
System.out.println(Integer.toString(100, 36)); // &quot;2s&quot;,表示为36进制
System.out.println(Integer.toHexString(100)); // &quot;64&quot;,表示为16进制
System.out.println(Integer.toOctalString(100)); // &quot;144&quot;,表示为8进制
System.out.println(Integer.toBinaryString(100)); // &quot;1100100&quot;,表示为2进制</code></pre></li>
</ul>
<h3 id="包装类型定义的静态变量"><a href="#包装类型定义的静态变量" class="headerlink" title="包装类型定义的静态变量"></a>包装类型定义的静态变量</h3><ol>
<li><p>int可表示的最大/最小值:</p>
<pre><code>int max = Integer.MAX_VALUE; // 2147483647
int min = Integer.MIN_VALUE; // -2147483648</code></pre><blockquote>
<p>这里的作用就相当于获取int最大最小的表示范围</p>
</blockquote>
</li>
<li><p>long类型占用的bit和byte数量:</p>
<pre><code>int sizeOfLong = Long.SIZE; // 64 (bits)
int bytesOfLong = Long.BYTES; // 8 (bytes)</code></pre></li>
</ol>
<h2 id="处理无符号整型"><a href="#处理无符号整型" class="headerlink" title="处理无符号整型"></a>处理无符号整型</h2><ul>
<li><p>byte是有符号整型，范围是-128 ~ +127，但如果把byte看作无符号整型，它的范围就是0 ~ 255。</p>
<p>我们把一个负的byte按无符号整型转换为int：</p>
<pre><code>byte x = -1;
byte y = 127;
System.out.println(Byte.toUnsignedInt(x)); // 255
System.out.println(Byte.toUnsignedInt(y)); // 127</code></pre><blockquote>
<p>超过了byte可以表示的范围所以变成int类型了</p>
</blockquote>
</li>
</ul>
<hr>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Lunomi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://unomisa.github.io/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">https://unomisa.github.io/Java基础知识/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://unomisa.github.io" target="_blank">Lunomi Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/unomisa/photo-cloud/blogImg/6.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/Java%E5%B8%B8%E7%94%A8%E7%B1%BB/"><img class="prev-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/unomisa/photo-cloud/blogImg/5.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java基础类</div></div></a></div><div class="next-post pull-right"><a href="/java/"><img class="next-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/unomisa/photo-cloud/blogImg/U%7BK(I%5DFXA1FFAG)G%5BGEV$02.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">java</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/Java常用类/" title="Java基础类"><img class="cover" data-lazy-src="https://cdn.jsdelivr.net/gh/unomisa/photo-cloud/blogImg/5.jpg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-02</div><div class="title">Java基础类</div></div></a></div><div><a href="/Java进阶知识/" title="Java进阶知识"><img class="cover" data-lazy-src="https://cdn.jsdelivr.net/gh/unomisa/photo-cloud/blogImg/7.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-06</div><div class="title">Java进阶知识</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Lunomi</div><div class="framework-info"><span>框架 </span><a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener">Butterfly</a></div><div class="footer_custom_text">🦋</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    $.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js', function () {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      false && mermaid.init()
    })
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script id="canvas_nest" defer="defer" color="255,255,255" opacity="0.8" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script></div></body></html>